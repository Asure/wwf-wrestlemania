**************************************************************
*
* Software:		Jamie Rivett
* Initiated:		5/20/94
*
* COPYRIGHT (C) 1992 WILLIAMS ELECTRONICS GAMES, INC.
*
**************************************************************

	.file	"wrestle2.asm"
	.title	"wrestling game program cont..."
	.width	132
	.option	b,d,l,t
	.mnolist


	.include	"macros.h"
	.include	"mproc.equ"		;Mproc equates
	.include	"display.equ"		;Display proc equates
	.include	"gsp.equ"		;Gsp asm equates
	.include	"sys.equ"
	.include	"game.equ"
	.include	"audit.equ"
	.include	"plyr.equ"
	.include	"anim.equ"
	.include	"sound.h"
	.include	"sound.equ"
	.include	"ring.equ"

	.include	"imgtbl.glo"
	.include	"fontsimg.glo"
	.include	"bgndtbl.glo"
	.include	"miscimg.glo"
	.include	"jjxm.h"

	;temp! - 314
	.if DEBUG
	.include	"tmpdebug.h"
	.endif

******************************************************************************
* EXTERNAL REFERENCES

	.ref	PSTATUS,triple_sound,change_anim1a,set_rotate_anim
	.ref	get_rope_x,round_tickcount,get_process_ptr,NUM_OPPS
	.ref	PALFRAM,HALT,dma_bog,GAMSTATE,pal_getf,process_ptrs
	.ref	change_anim2a,announce_rnd_winner,GET_ADJ,pin_prompt
	.ref	change_image,match_time,is_final_match,is_8_on_1
	.ref	ADD_VOICE,p1oldwinstreak,match_winner,RNDRNG0

	.ref	calc_line_x,PCNT,drone_meters_on,FINAL_PTR
	.ref	dnk_climbthru_side_anim,dnk_climbthru_bot_anim
	.ref	dnk_climbthru_top_anim,dnk_climbin_bot_anim
	.ref	dnk_climbin_top_anim,dnk_climbin_side_anim
	.ref	get_opp_process,adjust_health,init_wres_life_data
	.ref	HRTPNK_P,HRTBLU_P,UNDBLK_P,DNKPRP_P,YOKPRP_P
	.ref	LEXPRP_P,RZRPRP_P,BAMYLW_P,SHNPRP_P

	.ref	wrestler_x,wrestler_y,wrestler_z,index1,index2

	.ref	dnk_climb_up_anim,shn_climb_up_anim,bam_climb_up_anim
	.ref	hrt_climb_up_anim,lex_climb_up_anim,und_climb_up_anim
	.ref	yok_climb_up_anim,rzr_climb_up_anim

	.ref	bam_climbin_side_anim,bam_climbthru_side_anim
	.ref	bam_climbin_top_anim,bam_climbthru_top_anim
	.ref	bam_climbin_bot_anim,bam_climbthru_bot_anim
	.ref	und_climbin_side_anim,und_climbthru_side_anim
	.ref	und_climbin_top_anim,und_climbthru_top_anim
	.ref	und_climbin_bot_anim,und_climbthru_bot_anim
	.ref	rzr_climbin_side_anim,rzr_climbthru_side_anim
	.ref	rzr_climbin_top_anim,rzr_climbthru_top_anim
	.ref	rzr_climbin_bot_anim,rzr_climbthru_bot_anim
	.ref	hrt_climbin_side_anim,hrt_climbthru_side_anim
	.ref	hrt_climbin_top_anim,hrt_climbthru_top_anim
	.ref	hrt_climbin_bot_anim,hrt_climbthru_bot_anim
	.ref	yok_climbin_side_anim,yok_climbthru_side_anim
	.ref	yok_climbin_top_anim,yok_climbthru_top_anim
	.ref	yok_climbin_bot_anim,yok_climbthru_bot_anim
	.ref	lex_climbin_side_anim,lex_climbthru_side_anim
	.ref	lex_climbin_top_anim,lex_climbthru_top_anim
	.ref	lex_climbin_bot_anim,lex_climbthru_bot_anim
	.ref	shn_climbin_side_anim,shn_climbthru_side_anim
	.ref	shn_climbin_top_anim,shn_climbthru_top_anim
	.ref	shn_climbin_bot_anim,shn_climbthru_bot_anim
	.ref	switches_cur,switches_down,switches_up
	.ref	dufus_msg_off,get_rnd_wrestler,royal_rumble
	.ref	START_HI_FLASHES,wrestler_count,buddy_mode_on
	.ref	reduce_bog,player_pal_pref,crowd_process
	.ref	wrestler_count,wrestler_count_proc,get_opp_plyrmode
	.ref	THIS_GAME_TIME,STORE_AUDIT,GET_AUD,CURRENT_LADDER
	.ref	AUD,match_start_time,PSTARTS,match_realtime
	.ref	wrestler_audits,current_round,AUD1

******************************************************************************
* SYMBOLS DEFINED IN THIS FILE

******************************************************************************
*
* a13 = * wrestler process
* a0  = stick_val_cur

 SUBR	climb_turnbuckle

	move	a0,a4

	btst	MOVE_UP_BIT,a4		;check if player should climb
	jrz	djfcnot_top		;up the turnbuckle

	move	*a13(INRING),a0
	jrnz	djfcno_climb

	move	*a13(OBJ_ZPOSINT),a0
	cmpi	RING_TOP+5,a0		;give 'em 5 pixels of leeway
	jrgt	djfcnot_top


	move	*a13(OBJ_XPOSINT),a0
	cmpi	RING_X_CENTER,a0
	jrgt	djfcright
;djfcleft
	calla	get_rope_x
	move	*a13(OBJ_COLLX1),a1
	subk	5,a1			;give 'em 5
	cmp	a0,a1			;a1-a0
	jrgt	djfcno_climb

	movk	MOVE_UP_LEFT,a3		;face top left turnbuckle
	cmp	a3,a4			;Make sure UP/LEFT is pressed
	jreq	djfcclimbit
	jruc	djfcno_climb

djfcright
	calla	get_rope_x
	move	*a13(OBJ_COLLX2),a1
	addk	5,a1			;give 'em 5
	cmp	a0,a1			;a1-a0
	jrlt	djfcno_climb

	movk	MOVE_UP_RIGHT,a3	;face top right turnbuckle
	cmp	a3,a4			;Make sure UP/RIGHT is pressed
	jrne	djfcno_climb


djfcclimbit

;If anybody is already on turnbuckles, ignore this
	movi	process_ptrs,a4
	movi	NUM_WRES,a5

djfcloop	move	*a4+,a0,L
	jrz	djfcnxt			;skip inactive

	move	*a0(PLYRMODE),a14
	cmpi	MODE_ONTURNBKL,a14
	jrz	djfcfound_climber
	cmpi	MODE_CLIMBTURNBKL,a14
	jrz	djfcfound_climber
	jruc	djfcnxt

djfcfound_climber
	;check to see if we're trying to climb the one he's on
	move	*a13(OBJ_XPOSINT),a14
	move	*a0(OBJ_XPOSINT),a10
	cmpi	RING_X_CENTER,a14
	jrgt	djfcck_rt

	;left tbukl
	cmpi	RING_X_CENTER,a10
	jrlt	djfcno_climb
	jruc	djfcnxt

djfcck_rt	;right tbukl
	cmpi	RING_X_CENTER,a10
	jrgt	djfcno_climb

djfcnxt	dsj	a5,djfcloop


	;we're going to climb - because we allow 'near misses' to climb,
	; we may have to glitch the guy to the corner.  do it here.
	movi	RING_TOP,a14
	move	a14,*a13(OBJ_ZPOSINT)

	move	*a13(WRESTLERNUM),a0
	X16	a0
	addi	djfcface_turnbuckle,a0
	move	*a0,a0				;flip facing?
	jrz	djfcno_flip
	xori	MOVE_UP|MOVE_DOWN|MOVE_LEFT|MOVE_RIGHT,a3	;opposite
djfcno_flip
	move	a3,*a13(NEW_FACING_DIR)
	move	*a13(FACING_DIR),a0
	cmp	a0,a3
	jreq	djfcclimb
	calla	set_rotate_anim
	calla	change_anim1a

	movi	djfcclimb,a0			;this routine gets executed
	move	a0,*a13(CODE_ADDR),L		;when the rotate anim
	SETMODE	WAITANIM			;finishes

	setc
	rets

djfcclimb
	move	*a13(WRESTLERNUM),a0
	X32	a0
	addi	djfcclimb_anims,a0
	move	*a0,a0,L
	calla	change_anim1a

	SETMODE	CLIMBTURNBKL

	setc
	rets

djfcnot_top
djfcno_climb
	clrc
	rets

;0 = face turnbuckle before climb
;1 = back to turnbuckle
djfcface_turnbuckle
	.word	1	;0 Bret Hart
	.word	1	;1 Razor Ramon
	.word	1	;2 Undertaker
	.word	0	;3 Yokozuna
	.word	0	;4 Shawn Michaels
	.word	1	;5 Bam Bam
	.word	0	;6 Doink
	.word	0	;7 Adam Bomb
	.word	1	;8 Lex Luger
	.word	0	;9 Referee


djfcclimb_anims
	.long	hrt_climb_up_anim	;0 Bret Hart
	.long	rzr_climb_up_anim	;1 Razor Ramon
	.long	und_climb_up_anim	;2 Undertaker
	.long	yok_climb_up_anim	;3 Yokozuna
	.long	shn_climb_up_anim	;4 Shawn Michaels
	.long	bam_climb_up_anim	;5 Bam Bam
	.long	dnk_climb_up_anim	;6 Doink
	.long	dnk_climb_up_anim	;7 Adam Bomb
	.long	lex_climb_up_anim	;8 Lex Luger
	.long	dnk_climb_up_anim	;9 Referee

*****************************************************************************
*
* CLIMB-INS/OUTS
*

 SUBR	ck_climb_out_bot

	move	*a13(PLYRMODE),a14
	cmpi	MODE_ATTACHED,a14
	jreq	cerqdone
	cmpi	MODE_RUNNING,a14
	jreq	cerqdone
	cmpi	MODE_OPPOVERHEAD,a14
	jreq	cerqdone

;	calla	get_opp_process
;	move	*a0(INRING),a0
;	jrz	cerqdone
	callr	any_opp_outside
	jrnc	cerqdone

	;Far enough away from posts?
	move	*a13(OBJ_XPOSINT),a0
	subi	RING_X_CENTER,a0
	abs	a0
	cmpi	10Dh,a0
	jrgt	cerqdone

	move	*a13(ANIMODE),a0
	btst	MODE_UNINT_BIT,a0
	jrnz	cerqdone

	;make sure we're at the bottom edge of the ring.
	move	*a13(OBJ_ZPOS),a0,L
	cmpi	[RING_BOT,0],a0
	jrne	cerqdone

	;dummy check
	callr	idiot_check
	jrc	cerqclimb

	;button press
	move	*a13(BUT_VAL_CUR),a0
	move	a0,a0
	jrz	cerqdone

cerqclimb	move	*a13(WRESTLERNUM),a0
	X32	a0
	addi	climbthru_bot_anims,a0
	move	*a0,a0,L
	calla	change_anim1a
	movk	2,a0
	move	a0,*a13(CLIMBING_THRU)

cerqdone	rets


********
 SUBR	ck_climb_in_top

	move	*a13(PLYRMODE),a14
	cmpi	MODE_ATTACHED,a14
	jreq	ejtmdone
	cmpi	MODE_DEAD,a14
	jreq	ejtmdone
	cmpi	MODE_RUNNING,a14
	jreq	ejtmdone
	cmpi	MODE_INAIR,a14
	jreq	ejtmdone
	cmpi	MODE_INAIR2,a14
	jreq	ejtmdone
	cmpi	MODE_OPPOVERHEAD,a14
	jreq	ejtmdone

	move	*a13(CLIMBING_THRU),a0		;1=Climbing thru ropes flag
	jrnz	ejtmdone

	move	*a13(OBJ_XPOSINT),a0
	subi	RING_X_CENTER,a0
	abs	a0
;Far enough away from posts?
	cmpi	0C0h,a0		;48h
	jrgt	ejtmdone

	move	*a13(ANIMODE),a0
	btst	MODE_UNINT_BIT,a0
	jrnz	ejtmdone

	;make sure we're at the top edge of the mat.
	move	*a13(OBJ_ZPOS),a0,L
	cmpi	[MAT_TOP-5,0],a0
	jrne	ejtmdone
	move	*a13(MOVE_DIR),a0
	btst	MOVE_DOWN_BIT,a0
	jrz	ejtmdone

	callr	idiot_check
	jrc	ejtmclimb

	move	*a13(BUT_VAL_CUR),a0
	move	a0,a0
	jrz	ejtmdone

ejtmclimb	

	move	*a13(WRESTLERNUM),a0
	X32	a0
	addi	climbin_top_anims,a0
	move	*a0,a0,L
	calla	change_anim1a
	movk	2,a0
	move	a0,*a13(CLIMBING_THRU)

ejtmdone	rets


********
 SUBR	ck_climb_out_top

	;roll right on through if we're a zombie.
	move	*a13(STATUS_FLAGS),a14
	btst	B_ZOMBIE,a14
	jrnz	bydxzombie

	move	*a13(PLYRMODE),a14
	cmpi	MODE_ATTACHED,a14
	jreq	bydxdone
	cmpi	MODE_RUNNING,a14
	jreq	bydxdone
	cmpi	MODE_OPPOVERHEAD,a14
	jreq	bydxdone

;	calla	get_opp_process
;	move	*a0(INRING),a0
;	jrz	bydxdone
	callr	any_opp_outside
	jrnc	bydxdone

	;Far enough away from posts?
	move	*a13(OBJ_XPOSINT),a0
	subi	RING_X_CENTER,a0
	abs	a0
	cmpi	0C0h,a0
	jrgt	bydxdone

	move	*a13(ANIMODE),a0
	btst	MODE_UNINT_BIT,a0
	jrnz	bydxdone

	;make sure we're at the top edge of the ring.
	move	*a13(OBJ_ZPOS),a0,L
	cmpi	[RING_TOP,0],a0
	jrne	bydxdone

	;dummy check
	callr	idiot_check
	jrc	bydxclimb

	;button press
	move	*a13(BUT_VAL_CUR),a0
	move	a0,a0
	jrz	bydxdone

bydxclimb	move	*a13(WRESTLERNUM),a0
	X32	a0
	addi	climbthru_top_anims,a0
	move	*a0,a0,L
	calla	change_anim1a
	movk	2,a0
	move	a0,*a13(CLIMBING_THRU)

bydxdone	rets

bydxzombie	move	*a13(WRESTLERNUM),a0
	X32	a0
	addi	rollthru_top_anims,a0
	move	*a0,a0,L

	move	*a13(ANIBASE),a14,L
	cmp	a0,a14
	jreq	bydxskp			;skip if we're already doing it.
	calla	change_anim1a
	movk	2,a0
	move	a0,*a13(CLIMBING_THRU)
bydxskp	rets


********
 SUBR	ck_climb_in_bot

	move	*a13(PLYRMODE),a14
	cmpi	MODE_ATTACHED,a14
	jreq	cfzhdone
	cmpi	MODE_DEAD,a14
	jreq	cfzhdone
	cmpi	MODE_RUNNING,a14
	jreq	cfzhdone
	cmpi	MODE_INAIR,a14
	jreq	cfzhdone
	cmpi	MODE_INAIR2,a14
	jreq	cfzhdone
	cmpi	MODE_OPPOVERHEAD,a14
	jreq	cfzhdone

	move	*a13(CLIMBING_THRU),a0		;1=Climbing thru ropes flag
	jrnz	cfzhdone

	;Far enough away from posts?
	move	*a13(OBJ_XPOSINT),a0
	subi	RING_X_CENTER,a0
	abs	a0
	cmpi	10Dh,a0
	jrgt	cfzhdone

	move	*a13(ANIMODE),a0
	btst	MODE_UNINT_BIT,a0
	jrnz	cfzhdone

	;make sure we're up against the bottom of the ring
	move	*a13(OBJ_ZPOS),a0,L
	cmpi	[MAT_BOT+5,0],a0
	jrne	cfzhdone

	move	*a13(MOVE_DIR),a0
	btst	MOVE_UP_BIT,a0
	jrz	cfzhdone

	;dummy check
	callr	idiot_check
	jrc	cfzhclimb

	;button press
	move	*a13(BUT_VAL_CUR),a0
	move	a0,a0
	jrz	cfzhdone

cfzhclimb  

	move	*a13(WRESTLERNUM),a0
	X32	a0
	addi	climbin_bot_anims,a0
	move	*a0,a0,L
	calla	change_anim1a
	movk	2,a0
	move	a0,*a13(CLIMBING_THRU)

cfzhdone	rets

********
 SUBR	ck_climb_out_side

	move	*a13(PLYRMODE),a14
	cmpi	MODE_ATTACHED,a14
	jreq	wkyjdone
	cmpi	MODE_RUNNING,a14
	jreq	wkyjdone
	cmpi	MODE_OPPOVERHEAD,a14
	jreq	wkyjdone

;	calla	get_opp_process
;	move	*a0(INRING),a1
;	jrz	wkyjdone
	callr	any_opp_outside
	jrnc	wkyjdone
	move	*a0(CLIMBING_THRU),a0
	CMPI	1,A0
	JREQ	wkyjdone

	;Far enough away from posts?
	move	*a13(OBJ_ZPOSINT),a0
	subi	RING_Z_CENTER,a0
	abs	a0
	cmpi	48h,a0
	jrgt	wkyjdone

	move	*a13(ANIMODE),a0
	btst	MODE_UNINT_BIT,a0
	jrnz	wkyjdone

	;make sure we're up against one of the sides
	calla	get_rope_x
	move	a0,a4
	cmpi	RING_X_CENTER,a0
	jrgt	wkyjrt

wkyjlf	move	*a13(STICK_VAL_CUR),a0
	btst	MOVE_LEFT_BIT,a0
	jrz	wkyjdone

	move	a4,a0
	move	*a13(OBJ_COLLX1),a1
	cmp	a0,a1
	jrle	wkyjout_lf
	jruc	wkyjdone

wkyjrt	move	*a13(STICK_VAL_CUR),a0
	btst	MOVE_RIGHT_BIT,a0
	jrz	wkyjdone

	move	a4,a0
	move	*a13(OBJ_COLLX2),a1
	cmp	a0,a1
	jrge	wkyjout_rt
	jruc	wkyjdone

wkyjout_lf	movk	MOVE_DOWN_LEFT,a2
	jruc	wkyjdummy

wkyjout_rt	movk	MOVE_DOWN_RIGHT,a2

wkyjdummy	;dummy check
	callr	idiot_check
	jrc	wkyjspecial_face

	;button press
	move	*a13(BUT_VAL_CUR),a0
	move	a0,a0
	jrz	wkyjdone

wkyjface	move	*a13(FACING_DIR),a1
	cmp	a2,a1
	jreq	wkyjclimb

	move	a2,*a13(NEW_FACING_DIR)
	calla	set_rotate_anim
	calla	change_anim1a

	movi	wkyjclimb,a0
	move	a0,*a13(CODE_ADDR),L
	SETMODE	WAITANIM
	movk	1,a0
	move	a0,*a13(CLIMBING_THRU)
	rets

wkyjclimb	move	*a13(WRESTLERNUM),a0
	X32	a0
	addi	climbthru_side_anims,a0
	move	*a0,a0,L
	calla	change_anim1a

	SETMODE	NORMAL

	movk	1,a0
	move	a0,*a13(CLIMBING_THRU)
wkyjdone	rets

wkyjspecial_face
	move	*a13(PLYRMODE),A1
	CMPI	MODE_WAITANIM,a1
	JREQ	wkyjdone
	jruc	wkyjface

********
 SUBR	ck_climb_in_side

	move	*a13(PLYRMODE),a14
	cmpi	MODE_ATTACHED,a14
	jreq	atfldone
	cmpi	MODE_DEAD,a14
	jreq	atfldone
	cmpi	MODE_OPPOVERHEAD,a14
	jreq	atfldone

	move	*a13(CLIMBING_THRU),a0		;1=Climbing thru ropes flag
	jrnz	atfldone

;Far enough away from posts?
	move	*a13(OBJ_ZPOSINT),a0
	subi	RING_Z_CENTER,a0
	abs	a0
	cmpi	0D8h,a0
	jrgt	atfldone

	;is he close enough to the ring?
	move	*a13(OBJ_XPOSINT),a0
	cmpi	RING_X_CENTER,a0
	jrlt	atflon_left

	;he's right of center
	movk	MOVE_LEFT_BIT,A2
	movi	vln_right_matedge2,a6
	movk	MOVE_DOWN_LEFT,a7
	move	*a13(OBJ_COLLX1),a14
	jruc	atfld_set

atflon_left
	;he's left of center
	movk	MOVE_RIGHT_BIT,A2
	movi	vln_left_matedge2,a6
	movk	MOVE_DOWN_RIGHT,a7
	move	*a13(OBJ_COLLX2),a14

atfld_set

	move	*a13(PLYRMODE),a0
	cmpi	MODE_RUNNING,a0
	jrne	no_special_check

	move	*a13(GETUP_TIME),a0
	jrnz	atfldone

	jruc	running_back_in_here

no_special_check
	move	*a13(ANIMODE),a0
	btst	MODE_UNINT_BIT,a0
	jrnz	atfldone

	move	*a13(PLYRMODE),a0
	cmpi	MODE_HEADHELD,a0
	jreq	atfldone
	cmpi	MODE_HEADHOLD,a0
	jreq	atfldone
	cmpi	MODE_INAIR,a0
	jreq	atfldone
	cmpi	MODE_INAIR2,a0
	jreq	atfldone

running_back_in_here
	calla	calc_line_x
	sub	a14,a0
	abs	a0
	cmpi	10,a0
	jrgt	atfldone

	move	*a13(MOVE_DIR),a0
	btst	A2,a0
	jrz	atfldone

	;idiot check
	callr	idiot_check
	jrc	atflclimb

	move	*a13(PLYRMODE),a0
	cmpi	MODE_RUNNING,a0
	jrz	atflclimb

	;button press
	move	*a13(BUT_VAL_CUR),a0
	move	a0,a0
	jrz	atfldone

atflclimb	;he's within five pixels of his mat edge.  face the ring
	move	*a13(FACING_DIR),a1
	cmp	a7,a1
	jreq	atfljump_in

	move	a7,*a13(NEW_FACING_DIR)
	calla	set_rotate_anim
	calla	change_anim1a

	movi	atfljump_in,a0
	move	a0,*a13(CODE_ADDR),L
	SETMODE	WAITANIM
	movk	1,a0
	move	a0,*a13(CLIMBING_THRU)
	rets

atfljump_in
	move	*a13(WRESTLERNUM),a0
	X32	a0
	addi	climbin_side_anims,a0
	move	*a0,a0,L
	calla	change_anim1a

	SETMODE	NORMAL
	movk	1,a0
	move	a0,*a13(CLIMBING_THRU)

atfldone	rets

climbthru_bot_anims
	.long	hrt_climbthru_bot_anim	;0 Bret Hart
	.long	rzr_climbthru_bot_anim	;1 Razor Ramon
	.long	und_climbthru_bot_anim	;2 Undertaker
	.long	yok_climbthru_bot_anim	;3 Yokozuna
	.long	shn_climbthru_bot_anim	;4 Shawn Michaels
	.long	bam_climbthru_bot_anim	;5 Bam Bam
	.long	dnk_climbthru_bot_anim	;6 Doink
	.long	dnk_climbthru_bot_anim	;7 Adam Bomb
	.long	lex_climbthru_bot_anim	;8 Lex Luger
	.long	dnk_climbthru_bot_anim	;9 Referee

climbthru_top_anims
	.long	hrt_climbthru_top_anim	;0 Bret Hart
	.long	rzr_climbthru_top_anim	;1 Razor Ramon
	.long	und_climbthru_top_anim	;2 Undertaker
	.long	yok_climbthru_top_anim	;3 Yokozuna
	.long	shn_climbthru_top_anim	;4 Shawn Michaels
	.long	bam_climbthru_top_anim	;5 Bam Bam
	.long	dnk_climbthru_top_anim	;6 Doink
	.long	dnk_climbthru_top_anim	;7 Adam Bomb
	.long	lex_climbthru_top_anim	;8 Lex Luger
	.long	dnk_climbthru_top_anim	;9 Referee

climbin_bot_anims
	.long	hrt_climbin_bot_anim	;0 Bret Hart
	.long	rzr_climbin_bot_anim	;1 Razor Ramon
	.long	und_climbin_bot_anim	;2 Undertaker
	.long	yok_climbin_bot_anim	;3 Yokozuna
	.long	shn_climbin_bot_anim	;4 Shawn Michaels
	.long	bam_climbin_bot_anim	;5 Bam Bam
	.long	dnk_climbin_bot_anim	;6 Doink
	.long	dnk_climbin_bot_anim	;7 Adam Bomb
	.long	lex_climbin_bot_anim	;8 Lex Luger
	.long	dnk_climbin_bot_anim	;9 Referee

climbin_top_anims
	.long	hrt_climbin_top_anim	;0 Bret Hart
	.long	rzr_climbin_top_anim	;1 Razor Ramon
	.long	und_climbin_top_anim	;2 Undertaker
	.long	yok_climbin_top_anim	;3 Yokozuna
	.long	shn_climbin_top_anim	;4 Shawn Michaels
	.long	bam_climbin_top_anim	;5 Bam Bam
	.long	dnk_climbin_top_anim	;6 Doink
	.long	dnk_climbin_top_anim	;7 Adam Bomb
	.long	lex_climbin_top_anim	;8 Lex Luger
	.long	dnk_climbin_top_anim	;9 Referee

climbthru_side_anims
	.long	hrt_climbthru_side_anim	;0 Bret Hart
	.long	rzr_climbthru_side_anim	;1 Razor Ramon
	.long	und_climbthru_side_anim	;2 Undertaker
	.long	yok_climbthru_side_anim	;3 Yokozuna
	.long	shn_climbthru_side_anim	;4 Shawn Michaels
	.long	bam_climbthru_side_anim	;5 Bam Bam
	.long	dnk_climbthru_side_anim	;6 Doink
	.long	dnk_climbthru_side_anim	;7 Adam Bomb
	.long	lex_climbthru_side_anim	;8 Lex Luger
	.long	dnk_climbthru_side_anim	;9 Referee

climbin_side_anims
	.long	hrt_climbin_side_anim	;0 Bret Hart
	.long	rzr_climbin_side_anim	;1 Razor Ramon
	.long	und_climbin_side_anim	;2 Undertaker
	.long	yok_climbin_side_anim	;3 Yokozuna
	.long	shn_climbin_side_anim	;4 Shawn Michaels
	.long	bam_climbin_side_anim	;5 Bam Bam
	.long	dnk_climbin_side_anim	;6 Doink
	.long	dnk_climbin_side_anim	;7 Adam Bomb
	.long	lex_climbin_side_anim	;8 Lex Luger
	.long	dnk_climbin_side_anim	;9 Referee

rollthru_top_anims
	REFLONG	hrt_rollthru_top_anim	;0 Bret Hart
	REFLONG	rzr_rollthru_top_anim	;1 Razor Ramon
	REFLONG	und_rollthru_top_anim	;2 Undertaker
	REFLONG	yok_rollthru_top_anim	;3 Yokozuna
	REFLONG	shn_rollthru_top_anim	;4 Shawn Michaels
	REFLONG	bam_rollthru_top_anim	;5 Bam Bam
	REFLONG	dnk_rollthru_top_anim	;6 Doink
	.long	0			;7 unused
	REFLONG	lex_rollthru_top_anim	;8 Lex Luger


*****************************************************************************
*
* Updates CLIMB_START and CLIMB_LAST, and returns carry if it's time to
* climb.  Note that we can't count on idiot_check being called only once
* per tick.  As of this writing (28 Feb) it's at least two, and sometimes
* three.  If CLIMB_LAST == PCNT, quit.  If CLIMB_LAST == PCNT - 1, set
* CLIMB_LAST = PCNT, and compare CLIMB_LAST - CLIMB_START against
* IDIOT_COUNT. On GE, setc and return, else clrc and return.  If CLIMB_LAST
* isn't PCNT or PCNT-1, set it and CLIMB_START to PCNT, clrc, and rets.
*		

ktfcIDIOT_COUNT	.equ	21

 SUBRP	idiot_check

	move	*a13(CLIMB_LAST),a14
	move	@PCNT,a0
	cmp	a0,a14
	jreq	ktfcno

	inc	a14
	cmp	a0,a14
	jreq	ktfccont

	;new stick.
	move	a0,*a13(CLIMB_START)
	move	a0,*a13(CLIMB_LAST)
ktfcno	clrc
	rets

ktfccont	move	a0,*a13(CLIMB_LAST)
	move	*a13(CLIMB_START),a14
	sub	a14,a0
	cmpi	ktfcIDIOT_COUNT,a0
	jrlt	ktfcno

	;climb!
	setc
	rets

;*****************************************************************************
;*
;* a13 = wrestler process
;
; SUBR	clear_damage_log
;
;	move	a13,a2
;	addi	DAMAGE_HIST,a2		;start of damage stucture
;
;	clr	a0
;	movk	20,a1			;8 longs
;ktfcclr_loop
;	move	a0,*a2+,L
;	dsj	a1,ktfcclr_loop
;
;	rets
;
;
;*****************************************************************************
;*
;* a13 = wrestler process
;* a0  = damage amount (only if negative)
;
; SUBR	log_damage
;
;	move	a0,a0
;	jrnn	ktfcnot_damage
;
;	PUSH	a1,a2,a3
;
;	move	a13,a1
;	move	a13,a2
;
;	addi	DAMAGE_HIST+19*32,a1	;start at end of structure and
;	addi	DAMAGE_HIST+20*32,a2	;move everything down 1 long
;
;	movk	19,a3
;ktfclp	move	-*a1,-*a2,L
;	dsjs	a3,ktfclp
;
;	move	a0,a1			;damage amount
;	neg	a1
;	sll	16,a1
;	move	@round_tickcount,a2	;ticks since match started
;	andi	0ffffh,a2
;	or	a1,a2
;	move	a2,*a13(DAMAGE_HIST),L
;
;	PULL	a1,a2,a3
;
;ktfcnot_damage
;	rets
;
;
;*****************************************************************************
;*
;* ARGS:		a13 = wrestler process
;*		 a0 = timespan (in ticks)
;*
;* RETURNS:	 a0 = damage total
;*
;* TRASHES:	a1-a6,a14
;*
;
; SUBR	tally_damage
;
;	move	@round_tickcount,a4	;ticks since match started
;	clr	a5			;damage tally
;
;	move	a13,a1
;	addi	DAMAGE_HIST,a1		;start of damage stucture
;
;	movk	20,a6
;ktfcloop
;	move	*a1+,a2			;tick count
;	jrz	ktfcexit			;can't have a 0 tick count
;	move	*a1+,a3			;damage
;
;	move	a4,a14
;	sub	a2,a14
;	cmp	a0,a14			;> timespan?
;	jrgt	ktfcexit
;
;	add	a3,a5
;	dsj	a6,ktfcloop
;
;ktfcexit
;	move	a5,a0
;	rets
;
*****************************************************************************
*
* a10 = player number (0 to NUM_WRES-1)

GETUP_SIZE	equ	80 ;102	;174	;99
MAX_TIME	equ	6*TSEC
INV_MULT	equ	256*GETUP_SIZE/MAX_TIME
ONSCR_X		equ	173
OFFSCR_X	equ	221

	STRUCTPD
	LONG	IPTR_FRAME
	LONG	IPTR_GREEN
	WORD	DISPLAY_VAL

 SUBR	getup_meter

	;HACK ALERT: In royal rumble mode, player 1 is on PLAYER 0's TEAM,
	; so this code is gonna want to put his getup meter on the left.
	; To get it over on the right where it belongs, we temporarily put
	; him on the other team.  This shouldn't break anything.

	move	@royal_rumble,a14
	jrz	fwimnorum
	cmpi	1,a10		;(plyrnum)
	jrne	fwimnorum
	movk	1,a9		;act like plyr 1 is on team 1.
fwimnorum

	move	a10,a11			;a11 is PLYRNUM
	move	a10,a1
	calla	get_process_ptr
	move	a0,a10			;a10 is our wrestler process

	SLEEPK	2

	;first off, figure out if this guy is even allowed to have a getup
	; meter.  Humans always get them.  A drone teammate of a human
	; doesn't get one.  Otherwise, drones only get them if the GETUP
	; powerup is set and they're the only drone on their team.

	move	*a10(PLYR_TYPE),a14
	cmpi	PTYPE_PLAYER,a14
	jreq	fwimyes		;humans get getup meters

	movk	NUM_WRES,a0
	movi	process_ptrs,a1
	move	*a10(PLYR_SIDE),a2	;we'll need that later anyway.
fwimlp0	move	*a1+,a3,L
	jrz	fwimnxt0		;skip inactive
	cmp	a3,a10
	jreq	fwimnxt0		;skip self
	move	*a3(PLYR_SIDE),a14
	cmp	a14,a2
	jrne	fwimnxt0		;skip other team
	move	*a3(PLYR_TYPE),a14
	cmpi	PTYPE_PLAYER,a14
	jreq	fwimdie		;we have a human teammate so we don't get one
	jruc	fwimnxt0

fwimdie	clr	a14
	move	a14,*a10(METER_PROC),L
	DIE			;multi-drone team--no meters

fwimnxt0	dsjs	a0,fwimlp0

	;we got through the loop and found no teammates, so we're a lone
	; drone and we get a meter only if GETUP_POWER is set.
;	move	@GETUP_POWER,a14
	move	@drone_meters_on,a14
	jrz	fwimdie		;no GETUP_POWER--no meter

	move	@NUM_OPPS,a1
	cmpi	2,a1	   
	jrge	fwimdie


fwimyes	clr	a0
	move	a0,*a13(DISPLAY_VAL)

	;set our x-position based on PLYR_SIDE
	movi	[OFFSCR_X,0],a10
	move	a9,a9
	jrnz	fwimp2

	dec	a10
	neg	a10
fwimp2

	movi	RECVRBLK,a2			;* image (green bar)
	movi	[109,0],a1			;y pos
	movi	1801h,a3			;z pos
	callr	fwimbegin_obj
	move	a8,*a13(IPTR_GREEN),L
	movi	RECVR_R,a2			;* image (frame)
	move	a9,a9
	jrnz	fwimp2_meter
	movi	RECVR_L,a2			;* image (frame)
fwimp2_meter
	movi	[189,0],a1			;y pos
	movi	1800h,a3			;z pos
	callr	fwimbegin_obj
	move	a8,*a13(IPTR_FRAME),L

	move	a11,a1
	calla	get_process_ptr
	move	a0,a10

	move	a13,*a10(METER_PROC),L

 SUBR 	slide_offscr

;Don't allow a meter to come out for awhile (unless flung)
	movi	18*60,a0	;13
	move	a0,*a10(DELAY_METER)

	movk	10,a11
fwimoffscr_loop
	move	a11,a11
	jrz	fwimupdate
	dec	a11
	jruc	fwimcont
fwimupdate
	movi	[OFFSCR_X,0],a0
	callr	fwimset_x

	move	*a10(WHOHITME),A0,L
	move	*a0(COMBO_COUNT),A14
	jrnz	fwimcont
	move	*a10(DELAY_METER),a14
	jrnz	fwimcont
	move	*a10(PLYRMODE),a14
	cmpi	MODE_DEAD,a14
	jrz	fwimcont
;If health meter is down low, don't have getup meter come out.
;Unless it was a fling!
	move	*a10(PLYRNUM),a1
	.ref	get_health
	calla	get_health
	cmpi	20,a0
	jrgt	fwimnorm
	move	*a10(GETUP_TIME),a14
	cmpi	FLUNG_TIME,a14
	jrz	fwimonscr

fwimnorm
	move	*a10(GETUP_TIME),a14
	jrnz	fwimonscr

fwimcont
	SLEEPK	1
	jruc	fwimoffscr_loop


fwimonscr
	move	a14,a11

	movi	GETUP_SIZE,a0
	move	a0,*a13(DISPLAY_VAL)

	MOVI	0BDH,A0			;Meter announce sound
	CALLA	triple_sound

	movi	120,a6
	move	*a10(GETUP_TIME),a5

fwimonscr_loop

	movi	[ONSCR_X,0],a0
	callr	fwimset_x

	move	*a10(GETUP_TIME),a7

	;if a7 (current getup) is greater than a11 (starting getup), our
	; scale will be messed up.  In this case, just move a7 into a11.
	cmp	a11,a7
	jrle	fwimrescale
	move	a7,a11

fwimrescale
	movi	GETUP_SIZE,a0
	mpyu	a0,a7			;* GETUP_SIZE
	divu	a11,a7			;/ INITIAL GETUP TIME

	move	*a13(DISPLAY_VAL),a0
	cmp	a0,a7			;has getup been incremented?
	jrle	fwimok1

	move	a7,a11
	movi	GETUP_SIZE,a0
	mpyu	a0,a7			;* GETUP_SIZE
	divu	a11,a7			;/ INITIAL GETUP TIME
fwimok1
	.ref	dufus_msg_on

	subk	1,a6
	jrnz	fwimdont_bother
	move	*a10(GETUP_TIME),a0
	sub	a0,a5
	cmpi	175,a5
	jrgt	fwimdont_bother
	PUSH	a2,a7,a9
	movk	2,a9
	CREATE	4000h|AWARD_PID,dufus_msg_on
	PULL	a2,a7,a9
fwimdont_bother

	PUSH	a5,a6
	callr	fwimupdate_meter
	PULL	a5,a6

	move	a7,a7
	jrz	slide_offscr

	move	*a10(PLYRMODE),a0
	cmpi	MODE_DEAD,a0
	jrz	slide_offscr

	PUSHP	a5,a6
	SLEEPK	1
	PULLP	a5,a6
	jruc	fwimonscr_loop


**********
 SUBRP	fwimset_x

	move	a9,a9
	jrnz	fwimp22
	neg	a0
fwimp22
	addi	[200-1,0],a0			;center of screen
	move	a13,a14
	addi	IPTR_FRAME,a14
	move	*a14,a8,L
	move	*a8(OXVAL),a1,L
	sub	a1,a0
	sra	2,a0
	movk	3-1,a1
fwimlp	move	*a14+,a8,L
	move	*a8(OXVAL),a2,L
	add	a0,a2
	move	a2,*a8(OXVAL),L
	dsj	a1,fwimlp
	rets


**********
 SUBRP	fwimbegin_obj

	movi	[200-1,0],a0			;x pos
	add	a10,a0

	movi	DMAWNZ|M_SCRNREL,a4		;DMA flags
	clr	a5				;object ID
	clr	a6				;x vel
	clr	a7				;y vel
	calla	BEGINOBJ
	rets


**********
 SUBRP	fwimupdate_meter

	move	*a13(DISPLAY_VAL),a0
	add	a0,a7
	srl	1,a7
	move	a7,*a13(DISPLAY_VAL)
	move	a7,a1

	neg	a1
	addi	GETUP_SIZE,a1
	jrp	fwimok
	clr	a1
fwimok	movi	GETUP_SIZE,a0
	cmp	a0,a1				;meter can't be taller
	jrle	fwimok2				;than GETUP_SIZE pixels
	move	a0,a1
fwimok2	move	*a13(IPTR_GREEN),a8,L

	MOVI	GETUP_SIZE,A2
	SUB	A1,A2
	MOVE	A2,*A8(OSIZEY)
	MOVI	RECVRBLK,A0
	MOVE	*A0(ICTRL),A5
	SRL	12,A5
	MOVE	A1,A3
	MPYU	A5,A3
	MOVE	*A0(ISIZEX),A5
	MPYU	A5,A3
	MOVE	*A0(ISAG),A0,L
	ADD	A3,A0
	MOVE	A0,*A8(OSAG),L

	rets

*****************************************************************************
*
* makes your getup meter go away if you've got one out.

 SUBR	ditch_getup_meter_a9
	PUSH	a13
	move	a9,a13
	callr	ditch_getup_meter
	PULL	a13
	rets

 SUBR	ditch_getup_meter

	move	*a13(GETUP_TIME),a0
	jrz	laphcont
	move	*a13(PLYR_DIZZY),a0
	jrnz	laphcont

;This guy has a getup meter on screen and is running out of control!
;Cause getup meter to slide off screen.

	move	*a13(METER_PROC),a0,L
	jrz	laphcont		;skip if we don't have a meter.
	PUSH	a8,a9,a10
	move	*a0(PA8),a8,L
	move	*a0(PA9),a9,L
	move	*a0(PA10),a10,L
	movi	GETUP_PID,a1
	movi	slide_offscr,a7
	calla	XFERPROC
	PULL	a8,a9,a10

laphcont	rets

*****************************************************************************
*
*	a0  = # ticks to add
*	a13 = * wrestler process

 SUBR	inc_getup_time

	PUSH	a14
	move	*a13(GETUP_TIME),a14
	cmpi	20,a14
	jrlt	gcfuexit
	add	a0,a14
	move	a14,*a13(GETUP_TIME)
gcfuexit
	PULL	a14
	rets

*****************************************************************************
*
* do rolls for any wrestler
*
* args : a13 = * wrestler process
*
* returns : Z=1 if didn't roll

 SUBR	do_roll

	move	*a13(OBJ_ZPOSINT),a0
	move	*a13(Z_BOUND),a14
	jrz	ultjreg

	sub	a0,a14
	abs	a14		;<-new!
	cmpi	6,a14
	jrle	ultjno_roll
ultjreg
	move	*a13(STICK_VAL_CUR),a0
	andi	MOVE_UP|MOVE_DOWN,a0
	jrz	ultjno_roll

	move	*a13(WRESTLERNUM),a14
	X32	a14
	addi	ultjroll_table,a14
	move	*a14,a14,L

	move	*a14+,a1		;roll speed
	move	*a14+,a2,L		;z velocity

	btst	MOVE_DOWN_BIT,a0
	jrnz	ultjdown
	neg	a1			;must be up
	neg	a2
ultjdown
	move	a2,*a13(OBJ_ZVEL),L

	move	*a13(ROLL_POS),a0
	add	a0,a1
	andi	0ffh,a1
	move	a1,*a13(ROLL_POS)
	move	*a14+,a0,L		;inv multiplier
	mpyu	a0,a1
	srl	16,a1			;/65536
	X32	a1
	add	a1,a14
	move	*a14,a0,L
 .if DEBUG
	jrnz	ultjok
 	LOCKUP
ultjok
 .endif

	move	*a0,a0,L
 .if DEBUG
	jrnz	ultjok2
 	LOCKUP
ultjok2
 .endif

	move	a0,*a13(CUR_FRAME),L
	rets


ultjno_roll
	clr	a0
	move	a0,*a13(OBJ_ZVEL),L
	rets


ultjroll_table
	REFLONG	hrt_roll_frames	;0 Bret Hart
	REFLONG	rzr_roll_frames	;1 Razor Ramon
	REFLONG	und_roll_frames	;2 Undertaker
	REFLONG	yok_roll_frames	;3 Yokozuna
	REFLONG	shn_roll_frames	;4 Shawn Michaels
	REFLONG	bam_roll_frames	;5 Bam Bam
	REFLONG	dnk_roll_frames	;6 Doink
	.long	0		;7 unused
	REFLONG	lex_roll_frames	;8 Lex Luger


;
;*****************************************************************************
;
; SUBR	check_dizzy
;
;	movi	4*TSEC,a0
;	calla	tally_damage
;
;;Is this the right way to causes dizzies?
;;If one move is super powerful, we will tend to get dizzies when we don't want
;;them.  Maybe it should be based on hits over time, not damage.
;
;;A combination of the two is needed here! 10/5/94
;
;;We need less resolution on the damage that is recorded!
;;Perhaps 1-3?
;
;;We should allow this to happen only once per round!
;
;	cmpi	65,a0
;
;	jrlt	ultjno_dizzy
;
;	jruc	ultjno_dizzy
;
;
;	calla	clear_damage_log
;
;;Don't allow dizzies if your health meter is real low!
;;Killer Instinct sucks....
;	move	*a13(PLYRNUM),a1
;	.ref	get_health
;	calla	get_health
;	cmpi	30,a0
;	jrlt	ultjno_dizzy
;
;;Too many dizzies this round?
;	move	*a13(PLYR_DIZZY_CNT),a0
;	cmpi	1,a0				;Max dizzies per round
;	jrge	ultjno_dizzy
;
;	inc	a0
;	move	a0,*a13(PLYR_DIZZY_CNT)
;
;
;	movk	1,a0	;return TRUE
;	move	a0,*a13(PLYR_DIZZY)
;	rets
;
;ultjno_dizzy
;	clr	a0	;return FALSE
;	rets

*****************************************************************************

 SUBR	form_button_value

	;Combine the val_cur of the block bit with the val_down of the rest.

	move	*a13(BUT_VAL_CUR),a0
	andi	PLAYER_BLOCK_VAL,a0
	move	a0,a1
	move	*a13(BUT_VAL_DOWN),a0
	or	a1,a0
	rets

;
;*****************************************************************************
;
; SUBR	start_whack
;
;;a10=plyr proc
;;Turn on whack button graphic, animate it for a bit
;
;frame_z		.equ	202
;
;	movk	1,a0
;	move	a0,*a10(WHACK_CNT)
;
;	movi	[0f6h,0],a1
;	movi	[44h,0],a0
;	move	*a10(PLYRNUM),a2
;	jrz	zsltok
;	movi	[401-44h,0],a0
;zsltok
;	movi	WHAK0001,a2
;	movi	frame_z+2,a3			;Z
;	movi	DMAWNZ|M_3D|M_SCRNREL,a4	;DMA flags
;	movi	OVRHED_PID,a5
;	clr	a6
;	clr	a7
;	calla	BEGINOBJ
;	move	a8,a11
;
;	movi	[0f6h,0],a1
;	movi	[44h,0],a0
;	move	*a10(PLYRNUM),a2
;	jrz	zsltok2
;	movi	[401-44h,0],a0
;zsltok2
;	movi	WKBUTT01,a2
;	movi	frame_z+3,a3			;Z
;	movi	DMAWNZ|M_3D|M_SCRNREL,a4	;DMA flags
;	movi	OVRHED_PID,a5
;	clr	a6
;	clr	a7
;	calla	BEGINOBJ
;
;zsltstart
;	movi	butn_l,a9
;
;zsltlp	move	*a10(GETUP_TIME),a0
;	jrz	zsltdie
;
;	move	*a9+,a0,L
;	jrz	zsltstart
;	move	*a8(OCTRL),a1
;	calla	obj_aniq
;zsltnoani
;	SLEEPK	3
;	jruc	zsltlp			;Going up?
;
;zsltdie
;	SLEEPK	10
;
;	move	a11,a0
;	calla	DELOBJ
;	jauc	DELOBJDIE
;
;
;butn_l
;	.long	WKBUTT01
;	.long	WKBUTT02
;	.long	WKBUTT03
;	.long	WKBUTT02
;     ;	.long	0
*****************************************************************************
*
* Gets the animation point of a multipart object.  Find the highest x and y
* offset values among all the pieces.
*
* 0a0H = object table pointer
* <a0 = [Yoff,Xoff]

 SUBR	get_mpart_offsets
	PUSH	a1,a2,a9

	;reg use
	; a1 = current hi xoff
	; a2 = current hi yoff
	; a9 = loop counter

	move	*a0(IPCOUNT),a9

	.if DEBUG
	jrle	weckbad
	cmpi	5,a9
	jrgt	weckbad
	jruc	weckok
weckbad	LOCKUP
weckok
	.endif

	move	*a0(IANIOFFX),a1
	move	*a0(IANIOFFY),a2
	addi	ICBZ,a0
	dec	a9
	jrle	weckdone

weckloop
	move	*a0(IANIOFFX),a14
	cmp	a1,a14
	jrle	weckxc
	move	a14,a1			;new hi x

weckxc
	move	*a0(IANIOFFY),a14
	cmp	a2,a14
	jrle	weckyc
	move	a14,a2			;new hi y

weckyc
	addi	ICPBZ,a0
	dsj	a9,weckloop

weckdone
	sla	16,a2
	move	a2,a0
	zext	a1			;clear out sign
	or	a1,a0
	PULL	a1,a2,a9
	rets

*****************************************************************************
*
* Gets the combined X size of a multi-part object.  The correct answer is
* (hi anipt) + hi (size - anipt)
*
* 0a0H = object table pointer
* <a0 = Xsize

 SUBR	get_mpart_xsize
	PUSH	a1,a2,a3,a9

	;reg use
	; a1 = current hi anipt
	; a2 = current hi size - anipt
	; a9 = loop counter

	move	*a0(IPCOUNT),a9

	move	*a0(IANIOFFX),a1
	move	*a0(ISIZEX),a2
	sub	a1,a2
	addi	ICBZ,a0
	dec	a9
	jrz	ndcudone

ndculoop
	move	*a0(IANIOFFX),a14
	cmp	a1,a14
	jrle	ndcuac
	move	a14,a1			;new hi x

ndcuac
	move	*a0(ISIZEX),a14
	move	*a0(IANIOFFX),a3
	sub	a3,a14
	cmp	a2,a14
	jrle	ndcusac
	move	a14,a2			;new hi y

ndcusac
	addi	ICPBZ,a0
	dsj	a9,ndculoop

ndcudone
	move	a2,a0
	add	a1,a0
	PULL	a1,a2,a3,a9
	rets

*****************************************************************************
*
* Zero yer TGT_YOFF.  Do this anytime you target an opponent who's on the
* ground.

 SUBR	tgt_ground

	clr	a14
	move	a14,*a13(TGT_YOFF)
	rets

*****************************************************************************
*
* Halves wrestler's X-velocity if he's moving backwards.

 SUBR	halve_bk_xvel

	move	*a13(OBJ_XVEL),a0,L
	move	*a13(FACING_DIR),a14
	btst	MOVE_RIGHT_BIT,a14
	jrnz	kxbeabs
	neg	a0
kxbeabs
	move	a0,a0
	jrnn	kxbeok

	move	*a13(OBJ_XVEL),a0,L
	sra	1,a0
	move	a0,*a13(OBJ_XVEL),L
kxbeok
	rets


*****************************************************************************
*
* scroll_world moves the screen based on the midpoint of a segment connecting
* two wrestlers.  Rules:
*
* - If there are two and only two active wrestlers, track on them.
* - If there are more than two active wrestlers and two are human, track
*   on the humans.
* - If there are more than two active wrestlers, but only one is human,
*   count his live opponents:
*	0: track on only the human player
*	1: track on human and his one live opponent
*	2: track on the human and the mean position of the two live ones.
*	3: track on the human and the mean position of the three live ones,
*	   with the closest counted twice.
* - If there are more than two active wrestlers, and NONE of them are
*   human, look for a live one.  If none are alive, track on the first
*   dead one and his closest opponent.  If one or more is alive, track
*   on the first live one and his closest opponent.
* - Don't let any human players off the top of the screen.
* - In royal rumble mode, just track on the average position of all live
*   wrestlers.  If this results in everyone being offscreen, so be it.
* - And finally, on top of everything else, if there's only one human
*   player, under no circumstances will the scroller let him off-screen.
*   He'll remain entirely on the screen regardless of whatever else might
*   be going on. (as yet unimplemented.  coming soon...)
*


vdeiBUFFER	equ	[20,0]

vdeiXMINUSX	.equ	0
vdeiYMINUSX	.equ	vdeiXMINUSX+32*(NUM_WRES+1)
vdeiZMINUSX	.equ	vdeiYMINUSX+32*(NUM_WRES+1)

LIMITXL	.EQU	[12FH,0]
LIMITXR	.EQU	[5E8H,0]
LIMITYT	.EQU	[200H,0]
LIMITYB	.EQU	[97h,0]


 SUBR	scroll_world

	MMTM	SP,A8,A9,A10,A11

	.ref	in_finish_move

	move	@in_finish_move,a0
	jrnz	vdeix

	move	@HALT,a0
	jrnz	vdeix

	;first, check for a royal rumble
	move	@royal_rumble,a14
	jrnz	vdeirumble

	;check for two human players
	move	@PSTATUS,a0
	jrz	vdeino_humans
	cmpi	3,a0
	jrne	vdeione_human

	;two humans.  track on them.
	clr	a2
	movk	1,a3
	jruc	vdeiindices_set

vdeione_human
	;okay, we have only one player.  If this is one-on-one, track on
	; him and the drone.  (also, get the human's process ptr in a8)
	move	a0,a8
	dec	a8
	X32	a8
	addi	process_ptrs,a8
	move	*a8,a8,L

	move	@NUM_OPPS,a14
	dec	a14
	jrnz	vdeione_v_many

	;plyr v. one drone
	move	*a8(PLYRNUM),a2
	movk	2,a3
	jruc	vdeiindices_set

vdeione_v_many
	;count live opponents.  If there is one, track the human and his
	; closest opponent, which should be the live drone. If there are
	; none or more than one, track only on the human.
	;NOTE: Don't count opponents who are live but have different INRING
	; values.
	movk	NUM_WRES-2,a0
	movi	process_ptrs+40h,a1
	move	*a8(PLYR_SIDE),a2
	move	*a8(INRING),a5
	clr	a4		;live enemy counter
vdeilp0	move	*a1+,a3,L
	jrz	vdeidone0		;quit at first inactive since we're only
				;looking at drones
	move	*a3(PLYRMODE),a14
	cmpi	MODE_DEAD,a14
	jreq	vdeinxt0		;skip dead

	move	*a3(PLYR_SIDE),a14
	cmp	a2,a14
	jreq	vdeinxt0		;skip teammates

	move	*a3(INRING),a14
	cmp	a5,a14
	jrne	vdeinxt0		;skip bad INRINGS

	inc	a4
vdeinxt0	dsj	a0,vdeilp0

vdeidone0	dec	a4
	jrn	vdeitrack_human_only	;0 live opponents
	jrz	vdei1opp			;1 live opponent
	dec	a4
	jrz	vdei2ops			;2 live opponents
	jruc	vdei3ops			;3 live opponents


	;for the three cases (vdei2ops, vdei3ops, vdeirumble) where we're tracking on
	; a mean position rather than an actual wrestler, we store the mean
	; position in the long word immediately before wrestler_[xyz].
	; There's extra space allocated there.

	;reggies:
	;	a5 = x accumulator
	;	a6 = y accumulator
	;	a7 = z accumulator


vdeirumble	;There are anywhere from 1 to 4 live wrestlers.  Track on the live
	; ones.  If there's three, double-weight the one with the dead
	; teammate.  Since we've only got space for one artificial set
	; of coordinates, if we get all four alive, compute the average
	; position of all four, put that in the artificial slot, and track
	; on it twice.

	;first, count live wrestlers (drone and human)
	movi	process_ptrs,a0
	movk	4,a1		;only interested in plyrnum's 0-3
	clr	a3		;live count
	clr	a4		;PLYRNUMS
	clr	a5		; of
	clr	a6		;  live
	clr	a7		;   wrestlers
vdeilp3	move	*a0+,a2,L
	move	*a2(PLYRMODE),a14
	cmpi	MODE_DEAD,a14
	jreq	vdeinxt3
	move	*a2(I_WILL_DIE),a14
	jrnz	vdeinxt3
	inc	a3
	move	a6,a7
	move	a5,a6
	move	a4,a5
	move	*a2(PLYRNUM),a4
vdeinxt3	dsj	a1,vdeilp3

	;okay, branch based on the live count
	dec	a3
	jrn	vdeirr0liv		;none alive?  shouldn't happen.
	jrz	vdeirr1liv
	subk	2,a3
	jrn	vdeirr2liv
	jrz	vdeirr3liv
	jruc	vdeirr4liv

vdeirr0liv	;none alive(!?)  Track on the humans
	clr	a2
	movk	1,a3
	jruc	vdeiindices_set

vdeirr1liv	;one alive.  Track on him.
	move	a4,a2
	move	a4,a3
	jruc	vdeiindices_set

vdeirr2liv	;two alive.  Track on them.
	move	a4,a2
	move	a5,a3
	jruc	vdeiindices_set

vdeirr3liv	;three alive.  Since one human CAN'T be dead, the dead one must
	; be a drone.  Track on the drone and the average position of the
	; wrestlers. (a5 and a6 must be the humans, a4 the drone)

	;vdei0 (human)
	movi	wrestler_x,a0
	move	*a0(vdeiXMINUSX),a5,L
	move	*a0(vdeiYMINUSX),a6,L
	move	*a0(vdeiZMINUSX),a7,L

	;vdei1 (human)
	movi	wrestler_x+20h,a0
	move	*a0(vdeiXMINUSX),a14,L
	add	a14,a5
	move	*a0(vdeiYMINUSX),a14,L
	add	a14,a6
	move	*a0(vdeiZMINUSX),a14,L
	add	a14,a7

	;divide
	sra	1,a5
	sra	1,a6
	sra	1,a7

	;store
	movi	wrestler_x-20h,a0
	move	a5,*a0(vdeiXMINUSX),L
	move	a6,*a0(vdeiYMINUSX),L
	move	a7,*a0(vdeiZMINUSX),L

	;go
	movi	-1,a2
	move	a4,a3
	jruc	vdeiindices_set


vdeirr4liv	;four alive.  Track on all of 'em.

	;vdei0
	movi	wrestler_x,a0
	move	*a0(vdeiXMINUSX),a5,L
	move	*a0(vdeiYMINUSX),a6,L
	move	*a0(vdeiZMINUSX),a7,L

	;vdei1
	movi	wrestler_x+20h,a0
	move	*a0(vdeiXMINUSX),a14,L
	add	a14,a5
	move	*a0(vdeiYMINUSX),a14,L
	add	a14,a6
	move	*a0(vdeiZMINUSX),a14,L
	add	a14,a7

	;vdei2
	movi	wrestler_x+40h,a0
	move	*a0(vdeiXMINUSX),a14,L
	add	a14,a5
	move	*a0(vdeiYMINUSX),a14,L
	add	a14,a6
	move	*a0(vdeiZMINUSX),a14,L
	add	a14,a7

	;vdei3
	movi	wrestler_x+60h,a0
	move	*a0(vdeiXMINUSX),a14,L
	add	a14,a5
	move	*a0(vdeiYMINUSX),a14,L
	add	a14,a6
	move	*a0(vdeiZMINUSX),a14,L
	add	a14,a7

	;divide
	sra	2,a5
	sra	2,a6
	sra	2,a7

	;store
	movi	wrestler_x-20h,a0
	move	a5,*a0(vdeiXMINUSX),L
	move	a6,*a0(vdeiYMINUSX),L
	move	a7,*a0(vdeiZMINUSX),L

	;go
	movi	-1,a2
	movi	-1,a3
	jruc	vdeiindices_set


vdei3ops	;opponents must be plyrnum's 2, 3, and 4.

	;closest
	move	*a8(CLOSEST_NUM),a0
	X32	a0
	addi	wrestler_x,a0
	move	*a0(vdeiXMINUSX),a5,L
	move	*a0(vdeiYMINUSX),a6,L
	move	*a0(vdeiZMINUSX),a7,L

	;vdei2
	movi	wrestler_x+40h,a0
	move	*a0(vdeiXMINUSX),a14,L
	add	a14,a5
	move	*a0(vdeiYMINUSX),a14,L
	add	a14,a6
	move	*a0(vdeiZMINUSX),a14,L
	add	a14,a7

	;vdei3
	movi	wrestler_x+60h,a0
	move	*a0(vdeiXMINUSX),a14,L
	add	a14,a5
	move	*a0(vdeiYMINUSX),a14,L
	add	a14,a6
	move	*a0(vdeiZMINUSX),a14,L
	add	a14,a7

	;vdei4
	movi	wrestler_x+80h,a0
	move	*a0(vdeiXMINUSX),a14,L
	add	a14,a5
	move	*a0(vdeiYMINUSX),a14,L
	add	a14,a6
	move	*a0(vdeiZMINUSX),a14,L
	add	a14,a7

	;divide
	sra	2,a5
	sra	2,a6
	sra	2,a7

	;store
	movi	wrestler_x-20h,a0
	move	a5,*a0(vdeiXMINUSX),L
	move	a6,*a0(vdeiYMINUSX),L
	move	a7,*a0(vdeiZMINUSX),L

	;go
	move	*a8(PLYRNUM),a2
	movi	-1,a3
	jruc	vdeiindices_set

vdei2ops	;opponents could have 2, 3, or 4.  loop.
	clr	a5
	clr	a6
	clr	a7
	movk	NUM_WRES-2,a9		;only check drones
	movi	process_ptrs+40h,a1
	move	*a8(PLYR_SIDE),a2
	move	*a8(INRING),a11
vdeilp2	move	*a1+,a0,L
	jrz	vdeidone2		;quit at first inactive--only checking drones

	move	*a0(PLYRMODE),a14
	cmpi	MODE_DEAD,a14
	jreq	vdeinxt2		;skip dead

	move	*a0(PLYR_SIDE),a14
	cmp	a14,a2
	jreq	vdeinxt2		;skip teammates

	move	*a0(INRING),a14
	cmp	a14,a11
	jrne	vdeinxt2		;skip bad INRINGs

	move	*a0(OBJ_XPOS),a14,L
	add	a14,a5
	move	*a0(OBJ_YPOS),a14,L
	add	a14,a6
	move	*a0(OBJ_ZPOS),a14,L
	add	a14,a7

vdeinxt2	dsj	a9,vdeilp2

vdeidone2	;divide
	sra	1,a5
	sra	1,a6
	sra	1,a7

	;store
	movi	wrestler_x-20h,a0
	move	a5,*a0(vdeiXMINUSX),L
	move	a6,*a0(vdeiYMINUSX),L
	move	a7,*a0(vdeiZMINUSX),L

	;go
	move	*a8(PLYRNUM),a2
	movi	-1,a3
	jruc	vdeiindices_set


vdei1opp	move	*a8(PLYRNUM),a2
	move	*a8(CLOSEST_NUM),a3
	jruc	vdeiindices_set

vdeitrack_human_only
	move	*a8(PLYRNUM),a2
	move	a2,a3
	jruc	vdeiindices_set

vdeino_humans
	;attract mode play.  track on first live drone and his closest
	; opponent.
	movk	NUM_WRES,a0
	movi	process_ptrs,a1
vdeilp1	move	*a1+,a2,L
	jrz	vdeinxt1		;skip inactive
	move	*a2(PLYRMODE),a14
	cmpi	MODE_DEAD,a14
	jreq	vdeinxt1		;skip dead (shouldn't happen)

	;found a live drone.  track on him and his closest opp
	move	*a2(CLOSEST_NUM),a3
	move	*a2(PLYRNUM),a2
	jruc	vdeiindices_set

vdeinxt1	dsj	a0,vdeilp1

	;bizarre.  everyone's dead in the attract mode.  Just track on
	; first two drones.
	movk	2,a2
	movk	3,a3
	;fall through to vdeiindices_set

vdeiindices_set
	;a2 and a3 are PLYRNUM's of wrestlers to track on.  They MAY be
	; the same.
	move	a2,a0
	move	a2,a10
	move	a2,a8
	X32	a0
	X32	a10
	X32	a8
	addi	wrestler_x,a0
	addi	wrestler_y,a10
	addi	wrestler_z,a8

	move	a3,a1
	move	a3,a11
	move	a3,a9
	X32	a1
	X32	a11
	X32	a9
	addi	wrestler_x,a1
	addi	wrestler_y,a11
	addi	wrestler_z,a9

	;wrestler1 (*x,*y,*z) = (a0,a10,a8)
	;wrestler2 (*x,*y,*z) = (a1,a11,a9)

vdeivalues_set
	move	*a0,a0,L
	move	*a1,a1,L
	add	a0,a1
	sra	1,a1
	subi	[200,0],a1		;middle of screen

	move	@WORLDTLX,a2,L
	sub	a2,a1
	jrp	vdeipos

	addi	vdeiBUFFER,a1
	jrp	vdeiwide
	jruc	vdeicont

vdeipos	subi	vdeiBUFFER,a1
	jrn	vdeiwide

vdeicont	sra	3,a1
	add	a1,a2

	cmpi	[12fh,0],a2
	jrlt	vdeiwide
	cmpi	[648h,0],a2
	jrgt	vdeiwide

	move	a2,@WORLDTLX,L

vdeiwide	move	*a8,a0,L
	move	*a9,a1,L
	add	a0,a1
	sra	1+16,a1
	movi	Y_SCALE_MULTIPLIER,a0
	mpys	a0,a1
	move	a1,a2

	move	*a10,a0,L
	move	*a11,a1,L
	add	a0,a1
	sra	1,a1
	sub	a1,a2
	subi	[0d8h,0],a2		;middle of screen

	;Check for SCROLL_CTRL bits on active wrestlers.
	movi	process_ptrs,a0
	movk	NUM_WRES,a9
vdeilp4	move	*a0+,a3,L
	jrz	vdeinxt4		;skip inactive

	move	*a3(STATUS_FLAGS),a14
	btst	B_SCROLL_CTRL,a14
	jrz	vdeinxt4

	;control found.  On screen in X?
	move	*a3(OBJ_XPOS),a1,L
	move	@WORLDTLX,a14,L
	subi	[60,0],a14
	cmp	a14,a1
	jrlt	vdeinxt4
	addi	[400+120,0],a14
	cmp	a14,a1
	jrgt	vdeinxt4

	;calc hi pt
	move	*a3(OBJ_ZPOSINT),a1
	movi	Y_SCALE_MULTIPLIER,a14
	mpys	a14,a1
	move	*a3(OBJ_YPOS),a14,L
	sub	a14,a1
	move	*a3(SCROLL_Y),a14
	sla	16,a14
	sub	a14,a1

	cmp	a2,a1
	jrge	vdeinxt4
	
vdeitop_ok	move	a1,a2

vdeinxt4	dsj	a9,vdeilp4



vdeisc_done
	move	@WORLDTLY,a1,L
	sub	a1,a2
	sra	2,a2
	add	a2,a1

	;Don't allow scroller to go past front fence
	cmpi	[97h,0],a1
	jrgt	vdeilow
	move	a1,@WORLDTLY,L
vdeilow
vdeix	MMFM	SP,A8,A9,A10,A11
	rets

*****************************************************************************
*
* this is called before the velocity add and
* it's goal is to keep either wrestler from moving
* offscreen if one or both are outside the ring

ftaeBUFF1	equ	185
ftaeBUFF2	equ	185	;140

 SUBR	keep_onscreen

	;confine only in two-player game.
	move	@PSTATUS,a14
	cmpi	3,a14			;is it a 2-player game?
	jrne	ftaeno_2_player

	move	@WORLDTLX+16,a0		;world x int
	addi	200,a0			;center of screen

	move	a0,a1

	cmpi	RING_X_CENTER,a0
	jrgt	ftaeright_side

ftaeleft_side
	subi	ftaeBUFF2,a0	;left edge
	addi	ftaeBUFF1,a1	;right edge
	jruc	ftaecont

ftaeright_side
	subi	ftaeBUFF1,a0
	addi	ftaeBUFF2,a1
ftaecont
	move	@process_ptrs,a10,L	;player 1
	move	@process_ptrs+20h,a11,L	;player 2

;	move	*a10(DEC_DELAY),a14
;	jrnz	ftaeinring
;	move	*a11(DEC_DELAY),a14
;	jrnz	ftaeinring

	.ref	allow_offscrn

	move	@allow_offscrn,a14
	jrz	ftaeok
	dec	a14
	move	a14,@allow_offscrn
	jrnz	ftaeinring
ftaeok
	move	*a10(INRING),a14
	jrnz	ftaeoutside

	move	*a11(INRING),a14
	jrz	ftaeinring


ftaeoutside	;at least 1 player outside the ring

	move	a10,a9
	callr	ftaedo_check
	move	a11,a9
	callr	ftaedo_check

ftaeinring
ftaeno_2_player
	rets

ftaedo_check
	move	*a9(OBJ_XPOSINT),a14
	cmp	a0,a14
	jrgt	ftaeok1

;past left edge
	move	*a9(OBJ_XVEL),a14,L
	jrz	ftaedone
	jrn	ftaeclrx
	rets
ftaeok1
	cmp	a1,a14
	jrlt	ftaeok2

;past right edge
	move	*a9(OBJ_XVEL),a14,L
	jrz	ftaedone
	jrn	ftaedone
ftaeclrx
	move	*a9(CLIMBING_THRU),a14	;1=Climbing thru ropes flag
	jrnz	ftaedone

	clr	a14
	move	a14,*a9(OBJ_XVEL),L

	move	*a9(PLYRMODE),a14
	cmpi	MODE_RUNNING,a14
	jrne	ftaedone

	movi	MODE_NORMAL,a14
	move	a14,*a9(PLYRMODE)
	move	a14,*a9(ANIMODE)

	callr	ditch_getup_meter_a9

ftaeok2
ftaedone
	rets


*****************************************************************************

MAX_YVEL	equ	-1000000h	;-40000h

 SUBR	wrestler_veladd

	move	@HALT,a0
	jrnz	vaaux

	move	*a13(OBJ_XPOS),a0,L
	move	*a13(OBJ_XVEL),a1,L
	add	a1,a0
	move	a0,*a13(OBJ_XPOS),L

	move	*a13(GROUND_Y),a2
	sll	16,a2
	move	*a13(OBJ_YPOS),a0,L
	sub	a2,a0			;- GROUND_Y
	move	*a13(OBJ_YVEL),a1,L
	add	a1,a0
	jrnn	vaauyok

	;under ground.  clr Yvel unless we're attached and MODE_GHOST
	move	*a13(ATTACH_PROC),a14,L
	jrz	vaauset_yvel
	move	*a14(ATTACH_PROC),a14,L
	cmp	a13,a14			;valid link?
	jrne	vaauset_yvel
	move	*a13(ANIMODE),a14,L
	btst	MODE_GHOST_BIT,a14
	jrnz	vaauyok
	move	a1,a1			;if yvel is positive then keep
	jrn	vaauset_yvel		;velocity & put at ground level
	clr	a0
	jruc	vaauyok

vaauset_yvel
	;we've hit the ground -- if our WAITHITOPP bit is set, stuff
	; a 1 in ANICNT.
	move	*a13(ANIMODE),a14
	btst	MODE_WAITHITOPP_BIT,a14
	jrz	vaaunwho
	movk	1,a14
	move	a14,*a13(ANICNT)

vaaunwho	clr	a0
	move	a0,*a13(OBJ_YVEL),L
vaauyok
	add	a2,a0			;+ GROUND_Y
	move	a0,*a13(OBJ_YPOS),L



	calla	calc_ground_y

	move	*a13(OBJ_YPOS),a0,L

	move	*a13(GROUND_Y),a2
	sll	16,a2
	cmp	a0,a2			;a2-a0
	jrlt	vaauok
	;we're under ground...  Unless we're attached and set MODE_GHOST,
	; stay above.
	move	*a13(ATTACH_PROC),a14,L
	jrz	vaauset_ground_y
	move	*a14(ATTACH_PROC),a14,L
	jrz	vaauset_ground_y
	move	*a13(ANIMODE),a14,L
	btst	MODE_GHOST_BIT,a14
	jrnz	vaauok

vaauset_ground_y
	move	a2,a0
vaauok
	move	a0,*a13(OBJ_YPOS),L

	move	*a13(OBJ_ZPOS),a0,L
	move	*a13(OBJ_ZVEL),a1,L
	add	a1,a0
	move	a0,*a13(OBJ_ZPOS),L

	move	*a13(ANIMODE),a0
	btst	MODE_NOGRAVITY_BIT,a0
	jrnz	vaauno_gravity

	move	*a13(GROUND_Y),a0
	sll	16,a0
	move	*a13(OBJ_YPOS),a1,L
	cmp	a0,a1
	jreq	vaauno_gravity

	move	*a13(OBJ_YVEL),a0,L
	move	*a13(OBJ_GRAVITY),a14,L
	sub	a14,a0
	cmpi	MAX_YVEL,a0
	jrge	vaaugrav_ok
	movi	MAX_YVEL,a0
vaaugrav_ok
	move	a0,*a13(OBJ_YVEL),L
vaauno_gravity

vaaux
	rets


*****************************************************************************

 SUBRP	calc_ground_y

	move	*a13(INRING),a0
	jrz	axvbinring

	movi	117,a1
	move	*a13(OBJ_ZPOSINT),a0
	cmpi	05bdh,a0
	jrgt	axvbsetit

	movi	103,a1
	jruc	axvbsetit

axvbinring
	movi	112,a1

axvbsetit
	move	a1,*a13(OBJ_PRIORITY)

	movi	vln_right_matedge,a6
	calla	calc_line_x
	move	*a13(OBJ_XPOSINT),a1
	cmp	a0,a1			;a1-a0
	jrge	axvboutside

	movi	vln_left_matedge,a6
	calla	calc_line_x
	move	*a13(OBJ_XPOSINT),a1
	cmp	a0,a1			;a1-a0
	jrle	axvboutside


	;an unsuccessful attempt to fix throw-into-ring bug
	;-we fucked up climbins from behind
	;trying again - climbin top and bottom weren't setting this flag!
	move	*a13(CLIMBING_THRU),a14
	jrz	axvbskip

	movi	MAT_Y,a0
	move	a0,*a13(GROUND_Y)

	clr	a0
	move	a0,*a13(INRING)
	rets

axvboutside
	clr	a0
	move	a0,*a13(GROUND_Y)
	MOVE	@GAMSTATE,A0
	CMPI	INPREGAME2,A0
	jreq	axvbskip

	movk	1,a0
	move	a0,*a13(INRING)
axvbskip
	rets


*****************************************************************************
 .if 0

PATCH FOR SCROLLER

eauvMAX_DIST	equ	380

	move	@PSTATUS,a14
	cmpi	3,a14			;is it a 2-player game?
	jrne	eauvno_2_player

	move	@process_ptrs,a10,L	;player 1
	move	@process_ptrs+20h,a11,L	;player 2

	move	*a10(OBJ_XPOSINT),a0	;p1 x
	move	*a11(OBJ_XPOSINT),a1	;p2 x

	sub	a0,a1			;a1-a0
	abs	a1
	cmpi	eauvMAX_DIST,a1
	jrlt	eauvok

;the 2 human wrestlers are too far apart
;now bias towards the guy in the ring -
;(since the only way this should be able to happen is when
;both guys are outside the ring, and 1 jumps back in - ignoring
;the keep_onscreen code).


eauvok
eauvno_2_player


 .endif

*****************************************************************************
*
* a0 = * wrestler process
*

 SUBR	wres_get_but_val_down

	move	*a0(PLYR_TYPE),a14
	jrnz	rfqqdrndt
	move	*a0(PLYRNUM),a0
	callr	get_but_val_down
	rets

rfqqdrndt
	move	*a0(DRN_BUTDT),a0
	rets

*****************************************************************************

 SUBR	wres_get_but_val_cur

	move	*a0(PLYR_TYPE),a14
	jrnz	czikdrndt
	move	*a0(PLYRNUM),a0
	callr	get_but_val_cur
	rets

czikdrndt
	move	*a0(DRN_BUT),a0
	rets

*****************************************************************************

 SUBR	wres_get_but_val_up

	move	*a0(PLYR_TYPE),a14
	jrnz	oakmdrnut
	move	*a0(PLYRNUM),a0
	callr	get_but_val_up
	rets

oakmdrnut
	move	*a0(DRN_BUTUT),a0
	rets

*****************************************************************************

 SUBR	wres_get_stick_val_cur

	move	*a0(PLYR_TYPE),a14
	jrnz	drn_joy
	move	*a0(PLYRNUM),a0
	callr	get_stick_val_cur
	rets

drn_joy
	move	*a0(DRN_JOY),a0
	rets


*****************************************************************************

  SUBR	wres_get_stick_rel_cur


	move	*a0(PLYR_TYPE),a14
	jrnz	drn_joy
	move	*a0(OBJ_CONTROL),a14
	move	*a0(PLYRNUM),a0
	callr	get_stick_val_cur
	btst	B_FLIPH,a14
	jrz	sakpdone

	X16	a0
	addi	sakpxflip_table,a0
	move	*a0,a0
sakpdone
	rets



;returns a value only if stick val
;has changed (but not zero)

  SUBR	wres_get_stick_rel_new


	move	*a0(PLYR_TYPE),a14
	jrnz	sakpnot_human2

;shawn - this needs patching too...

	push	a1,a10

	move	a0,a10
	move	*a10(PLYRNUM),a0
	callr	get_stick_val_up
	push	a0

	move	*a10(PLYRNUM),a0
	callr	get_stick_val_down
	pull	a1
	or	a1,a0
	jrz	sakpdone2		;no stick

	move	*a10(OBJ_CONTROL),a14
	move	*a10(PLYRNUM),a0
	callr	get_stick_val_cur
	btst	B_FLIPH,a14
	jrz	sakpdone2

	X16	a0
	addi	sakpxflip_table,a0
	move	*a0,a0
sakpdone2
	pull	a1,a10
	rets


sakpnot_human2
	move	a0,a14
	move	*a14(DRN_JOYDT),a0
	move	*a14(DRN_JOYUT),a1
	or	a1,a0
	jrz	sakpdx
	move	*a14(DRN_JOY),a0
	move	*a14(OBJ_CONTROL),a14
	btst	B_FLIPH,a14
	jrz	sakpdx

	X16	a0
	addi	sakpxflip_table,a0
	move	*a0,a0
sakpdx
	rets


sakpxflip_table	;convert to forward / away  if facing left
	.word	0000b	;0
	.word	0001b	;1
	.word	0010b	;2
	.word	0011b	;3
	.word	1000b	;4
	.word	1001b	;5
	.word	1010b	;6
	.word	1011b	;7
	.word	0100b	;8
	.word	0101b	;9
	.word	0110b	;10
	.word	0111b	;11
	.word	1100b	;12
	.word	1101b	;13
	.word	1110b	;14
	.word	1111b	;15

*****************************************************************************

 SUBR	wres_get_stick_val_down

	move	*a0(PLYR_TYPE),a14
	jrnz	szfedrnjoy
	move	*a0(PLYRNUM),a0
	callr	get_stick_val_down
	rets

szfedrnjoy
	move	*a0(DRN_JOYDT),a0
	rets

*****************************************************************************

 SUBR	wres_get_stick_val_up

	move	*a0(PLYR_TYPE),a14
	jrnz	ekxcnot_human
	move	*a0(PLYRNUM),a0
	callr	get_stick_val_up
	rets

ekxcnot_human
	move	*a0(DRN_JOYUT),a0
	rets

*****************************************************************************
*
* INPUT:	a0 = player number (0-1)
*-----------------------------------------------------------------------------
*
* RETURN:	a0 = button bits
*-----------------------------------------------------------------------------

 SUBR	get_but_val_cur


	PUSH	a1
	move	a0,a1
	sll	4,a1			;x 16 bits
	addi	but_offs2,a1
	move	*a1,a1
	addi	switches_cur,a1
	move	*a1,a1
	andi	011000b,a1

	sll	4,a0			;x 16 bits
	addi	but_offs,a0
	move	*a0,a0
	addi	switches_cur,a0
	move	*a0,a0
	andi	0111b,a0
	or	a1,a0
	PULL	a1

	rets

*****************************************************************************
*
* INPUT:	a0 = player number (0-3)
*-----------------------------------------------------------------------------
*
* RETURN:	a0 = joy switch bits
*-----------------------------------------------------------------------------

  SUBR	get_stick_val_cur


	sll	4,a0			;x 16 bits
	addi	joy_offs,a0
	move	*a0,a0
	addi	switches_cur,a0
	move	*a0,a0
	andi	01111b,a0
	rets

******************************************************************************
*
* INPUT:	a0 = player number (0-3)
*-----------------------------------------------------------------------------
*
* RETURN:	a0 = joy switch bits
*-----------------------------------------------------------------------------

  SUBR	get_stick_val_down

	sll	4,a0			;x 16 bits
	addi	joy_offs,a0
	move	*a0,a0
	addi	switches_down,a0
	move	*a0,a0
	andi	01111b,a0
	rets

******************************************************************************
*
* INPUT:	a0 = player number (0-3)
*-----------------------------------------------------------------------------
*
* RETURN:	a0 = joy switch bits
*-----------------------------------------------------------------------------

  SUBR	get_stick_val_up

	sll	4,a0			;x 16 bits
	addi	joy_offs,a0
	move	*a0,a0
	addi	switches_up,a0
	move	*a0,a0
	andi	01111b,a0
	rets

joy_offs	.word	00h,08h,20h,28h

******************************************************************************
*
* INPUT:	a0 = player number (0-1)
*-----------------------------------------------------------------------------
*
* RETURN:	a0 = button bits
*-----------------------------------------------------------------------------

 SUBR	get_but_val_down

	PUSH	a1
	move	a0,a1
	sll	4,a1			;x 16 bits
	addi	but_offs2,a1
	move	*a1,a1
	addi	switches_down,a1
	move	*a1,a1
	andi	011000b,a1

	sll	4,a0			;x 16 bits
	addi	but_offs,a0
	move	*a0,a0
	addi	switches_down,a0
	move	*a0,a0
	andi	0111b,a0
	or	a1,a0
	PULL	a1

	rets


******************************************************************************
*
* INPUT:	a0 = player number (0-1)
*-----------------------------------------------------------------------------
*
* RETURN:	a0 = button bits
*-----------------------------------------------------------------------------

 SUBR	get_but_val_up

	PUSH	a1
	move	a0,a1
	sll	4,a1			;x 16 bits
	addi	but_offs2,a1
	move	*a1,a1
	addi	switches_up,a1
	move	*a1,a1
	andi	011000b,a1

	sll	4,a0			;x 16 bits
	addi	but_offs,a0
	move	*a0,a0
	addi	switches_up,a0
	move	*a0,a0
	andi	0111b,a0
	or	a1,a0
	PULL	a1

	rets

but_offs	.word	04h,0ch,24h,2ch
but_offs2	.word	20h-3,24h-3

*****************************************************************************
*
* sacrifice clarity for speed
* this reads all switch transitions once
* and stuffs them into the PDATA area


 SUBR	read_switches

;evibwait
;	move	@vcount,a0
;	andi	31,a0
;	jrnz	evibwait
;	TINTON

	movi	process_ptrs,a9
	movk	NUM_WRES,a11
evibnext
	move	*a9+,a10,L
	jrz	evibskip

	;ignore all switches if wrestler is immobilized
	move	*a10(IMMOBILIZE_TIME),a14
	jrp	evibimmob

	move	*a10(PLYR_TYPE),a14
	jrz	evibno_drone

evibdrone
	move	*a10(DRN_BUT),*a10(BUT_VAL_CUR)
	move	*a10(DRN_BUTDT),*a10(BUT_VAL_DOWN)
	move	*a10(DRN_BUTUT),*a10(BUT_VAL_UP)

	move	*a10(DRN_JOY),*a10(STICK_VAL_CUR)
	move	*a10(DRN_JOYDT),*a10(STICK_VAL_DOWN)
	move	*a10(DRN_JOYUT),*a10(STICK_VAL_UP)
	jruc	evibcont

evibimmob	clr	a14
	move	a14,*a10(BUT_VAL_CUR)
	move	a14,*a10(BUT_VAL_DOWN)
	move	a14,*a10(BUT_VAL_UP)
	move	a14,*a10(STICK_VAL_CUR)
	move	a14,*a10(STICK_VAL_DOWN)
	move	a14,*a10(STICK_VAL_UP)
	move	a14,*a10(STICK_REL_CUR)
	move	a14,*a10(STICK_REL_NEW)
	jruc	evibskip

evibno_drone
	move	*a10(PLYRNUM),a8

	move	a8,a1
	X16	a1
	move	a1,a0
	addi	joy_offs,a0
	move	*a0,a5		;joy offset

	move	a1,a0
	addi	but_offs,a0
	move	*a0,a6		;switch offset1

	move	a1,a0
	addi	but_offs2,a0
	move	*a0,a7		;switch offset2

;wres_get_but_val_cur

	move	a7,a1		;switch offset2
	addi	switches_cur,a1
	move	*a1,a1
	andi	011000b,a1

	move	a6,a0		;switch offset1
	addi	switches_cur,a0
	move	*a0,a0
	andi	0111b,a0
	or	a1,a0
	move	a0,*a10(BUT_VAL_CUR)


;wres_get_but_val_down

	move	a7,a1		;switch offset2
	addi	switches_down,a1
	move	*a1,a1
	andi	011000b,a1

	move	a6,a0		;switch offset1
	addi	switches_down,a0
	move	*a0,a0
	andi	0111b,a0
	or	a1,a0
	move	a0,*a10(BUT_VAL_DOWN)


;wres_get_but_val_up

	move	a7,a1		;switch offset2
	addi	switches_up,a1
	move	*a1,a1
	andi	011000b,a1

	move	a6,a0		;switch offset1
	addi	switches_up,a0
	move	*a0,a0
	andi	0111b,a0
	or	a1,a0
	move	a0,*a10(BUT_VAL_UP)


;wres_get_stick_val_cur
	move	a5,a0		;joy offset
	addi	switches_cur,a0
	move	*a0,a0
	andi	01111b,a0
	move	a0,*a10(STICK_VAL_CUR)


;wres_get_stick_val_down
	move	a5,a0		;joy offset
	addi	switches_down,a0
	move	*a0,a0
	andi	01111b,a0
	move	a0,*a10(STICK_VAL_DOWN)


;wres_get_stick_val_up
	move	a5,a0		;joy offset
	addi	switches_up,a0
	move	*a0,a0
	andi	01111b,a0
	move	a0,*a10(STICK_VAL_UP)

evibcont
;wres_get_stick_rel_cur
;facing reletive joystick value

	move	*a10(STICK_VAL_CUR),a0
	move	*a10(FACING_DIR),a14
	btst	PLAYER_RIGHT_BIT,a14
	jrnz	evibno_flip
	X16	a0
	addi	evibxflip_table,a0
	move	*a0,a0
evibno_flip
	move	a0,*a10(STICK_REL_CUR)


;wres_get_stick_rel_new
;returns a value only if stick val
;has changed (but not zero)

	move	*a10(STICK_VAL_UP),a0
	move	*a10(STICK_VAL_DOWN),a1
	or	a1,a0
	jrz	evibno_stick
	move	*a10(STICK_VAL_CUR),a0
	move	*a10(FACING_DIR),a14
	btst	PLAYER_RIGHT_BIT,a14
	jrnz	evibno_flip2
	X16	a0
	addi	evibxflip_table,a0
	move	*a0,a0
evibno_flip2
evibno_stick
	move	a0,*a10(STICK_REL_NEW)


evibskip
	dsj	a11,evibnext
; TINTOFF

	rets



evibxflip_table	;convert to forward / away  if facing left
	.word	0000b	;0
	.word	0001b	;1
	.word	0010b	;2
	.word	0011b	;3
	.word	1000b	;4
	.word	1001b	;5
	.word	1010b	;6
	.word	1011b	;7
	.word	0100b	;8
	.word	0101b	;9
	.word	0110b	;10
	.word	0111b	;11
	.word	1100b	;12
	.word	1101b	;13
	.word	1110b	;14
	.word	1111b	;15


;*****************************************************************************
;*
;* puts you in mode_blocking if your safe_time is set. (or if you're a drone)
;* called from anim scripts with an ANI_CODE.
;
; SUBR	block_if_safe
;
;	move	*a13(PLYR_TYPE),a14
;	cmpi	PTYPE_DRONE,a14
;	jreq	evibsafe
;
;	move	*a13(SAFE_TIME),a14
;	jrz	evibnot_safe
;
;evibsafe	movk	MODE_BLOCK,a14
;	move	a14,*a13(PLYRMODE)
;
;evibnot_safe
;	rets

*****************************************************************************
*
* Call at the beginning of any turnbuckle attack.  This sets the NOCONFINE
* bit if any live opponents are outside the ring, or clears it otherwise.
*
* HOWEVER, if everyone is dead, it checks simply for active wrestlers outside,
* not just live ones.
*
* ...except for yoko.  He can't jump out.
*

 SUBR	set_tbukl_confine

	move	*a13(WRESTLERNUM),a14
	cmpi	W_YOKO,a14
	jreq	qjhxclear_noconfine

	;a3 is the 'everyone is dead' flag.
	clr	a3
	move	*a13(CLOSEST_NUM),a1
	calla	get_process_ptr
	move	*a0(PLYRMODE),a14
	cmpi	MODE_DEAD,a14
	jrne	qjhxdfset

	inc	a3		;entire other team is dead.

qjhxdfset	movi	process_ptrs,a0,L
	movk	NUM_WRES,a10
	move	*a13(PLYR_SIDE),a2
qjhxloop
	move	*a0+,a1,L
	jrz	qjhxnxt		;skip inactive

	cmp	a1,a13
	jreq	qjhxnxt		;skip self

	move	*a1(PLYR_SIDE),a14
	cmp	a14,a2
	jreq	qjhxnxt		;skip teammates

	;skip the dead check if everyone on enemy side is dead
	TEST	a3
	jrnz	qjhxnsd

	move	*a1(PLYRMODE),a14
	cmpi	MODE_DEAD,a14
	jreq	qjhxnxt		;skip dead

qjhxnsd	move	*a1(INRING),a14
	jrnz	qjhxset_noconfine

qjhxnxt	dsj	a10,qjhxloop
	;fall through
qjhxclear_noconfine

	;he might have drifted out already, so we gotta yank 'em back in.
	move	*a13(INRING),a14
	jrz	qjhxin

	;rats.  he's out.  fix it.
	clr	a14
	move	a14,*a13(INRING)
	movi	MAT_Y,a14
	move	a14,*a13(GROUND_Y)
	move	*a13(OBJ_ZPOSINT),a14
	cmpi	RING_TOP,a14
	jrge	qjhxzok
	movi	RING_TOP,a14
	move	a14,*a13(OBJ_ZPOSINT)
qjhxzok	move	*a13(OBJ_XPOSINT),a2
	cmpi	RING_X_CENTER,a2
	jrgt	qjhxrt

	;on left
	movi	vln_left_rope,a6
	calla	calc_line_x
	jrz	qjhxxok		;bad news.  leave it alone.
	cmp	a0,a2
	jrge	qjhxxok
	move	a0,*a13(OBJ_XPOSINT)
	jruc	qjhxxok

qjhxrt	;on right
	movi	vln_right_rope,a6
	calla	calc_line_x
	jrz	qjhxxok		;bad news.  leave it alone.
	cmp	a0,a2
	jrle	qjhxxok
	move	a0,*a13(OBJ_XPOSINT)

qjhxxok
qjhxin	move	*a13(ANIMODE),a14
	andni	MODE_NOCONFINE,a14
	jruc	qjhxcont

qjhxset_noconfine
	move	*a13(ANIMODE),a14
	ori	MODE_NOCONFINE,a14
qjhxcont
	move	a14,*a13(ANIMODE)
	rets


;*****************************************************************************
;*
;* Call with ANI_CODE when a turnbuckle attack misses.  This does four pixels
;* of damage, or health-1, whichever is less.
;
; SUBR	tbukl_miss_damage
;
;	move	*a13(PLYRNUM),a1
;	calla	get_health
;	dec	a0
;	jrle	qjhxdone
;	movk	4,a14
;	cmp	a14,a0
;	jrle	qjhxok
;	move	a14,a0
;qjhxok	neg	a0
;	clr	a10
;	calla	adjust_health
;qjhxdone	rets


	.if DEBUG
*****************************************************************************
	.ref	CPUAVG

 SUBR	draw_dma_meter

	movi	DIAGP,a0
	calla	pal_getf
	move	a0,a1
	ori	00E0E0000H,a1
	movi	[1,400],a2
	move	@dma_bog,a3
	sll	16,a3
	clr	a4
	movi	DMACAL,a5
	calla	QDMAN
	rets

*****************************************************************************

 SUBR	draw_cpu_meter

	movi	DIAGP,a0
	calla	pal_getf
	move	a0,a1
	ori	00D0D0000H,a1
	movi	[1,400],a2
	move	@CPUAVG,a3
	sll	14,a3
	clr	a4
	movi	DMACAL,a5
	calla	QDMAN
	rets

	.endif

*****************************************************************************

 SUBR	COLRPRC
	movi	COLRPID,a0
	calla	KIL1C		;KILL ALL COLOR UPDATE PROCESSES
	clr	a0
	move	a0,@PALFRAM,L
;	movi	scorep,a0	;Score area palette
	jauc	pal_getf


*****************************************************************************
*
* call this at the top of any anim sequence that requires that you be
* attached before you get there, like any of the pile-drivers, vertical
* suplexes, and so forth.  This checks for a good link, and bitches up
* a storm if it doesn't find one.

 SUBR	link_check

	.if DEBUG
	move	*a13(ATTACH_PROC),a14,L
	jrnz	zqopok1

	LOCKUP	;I'm not attached!
	nop

zqopok1	move	*a14(ATTACH_PROC),a14,L
	jrnz	zqopok2
	LOCKUP	;I'm attached, but he's not attached to me!
	nop

zqopok2	cmp	a14,a13
	jreq	zqopok3
	LOCKUP	;We're both attached, but not to each other!
	nop

	.endif
zqopok3	rets

*****************************************************************************
*
* clears CLIMBING_THRU flag and sets SAFE_TIME to 1, which won't do you
* any good unless you're holding block.  Call this at the end of any
* rope climb-through anim.

 SUBR	clr_climb

	clr	a0
	move	a0,*a13(CLIMBING_THRU)		;1=Climbing thru ropes flag

	inc	a0
	move	a0,*a13(SAFE_TIME)

	rets


*****************************************************************************
*
* returns carry set if one of a13's teammates has done a pin this round.
*
* trashes scratch

 SUBR	ck_teammate_pin

	PUSH	a2,a3

	movk	NUM_WRES,a0
	movi	process_ptrs,a1
	move	*a13(PLYR_SIDE),a2

lhzplp	move	*a1+,a3,L
	jrz	lhzpnxt		;skip inactive

	cmp	a3,a13
	jreq	lhzpnxt		;skip self

	move	*a3(PLYR_SIDE),a14
	cmp	a14,a2
	jrne	lhzpnxt		;skip enemies

	move	*a3(STATUS_FLAGS),a14
	btst	B_DID_PIN,a14
	jrz	lhzpnxt		;skip guys who didn't pin

	;got a pinning teammate
	PULL	a2,a3
	setc
	rets

lhzpnxt	dsj	a0,lhzplp

	;no pinning teammates
	PULL	a2,a3
	clrc
	rets

*****************************************************************************
*
* rummage through process_ptrs and decide which pal this wrestler should
* get.  return pal ptr in b0
*
* trashes a0,a1,a2,a3, and a14.

 SUBR	choose_pal

	;assign pals in PLYRNUM order.  There's four in the table for
	; each wrestler.

	.if 1
	; First check to see if there are 2 human players and they are
	; playing the same wrestler
	move	@PSTATUS,a14		; Get status
	cmpi	3,a14			; Do we have 2 humans playing ?
	jrnz	rwlapp_go			; br = no

	;if buddy mode, choose special pals
	move	@buddy_mode_on,a14
	jrnz	rwlabuddy_mode

	clr	a2
	clr	a14
	neg	a14
	movi	process_ptrs,a0
rwlaf_loop
	move	*a0+,a3,L
	jrz	rwlaf_done
	move	*a3(PLYRNUM),a4
	jrnz	rwlanot_p1
	move	*a3(WRESTLERNUM),a2
rwlanot_p1
	cmpi	1,a4
	jrnz	rwlanot_p2
	move	*a3(WRESTLERNUM),a14
rwlanot_p2
	jruc	rwlaf_loop
rwlaf_done
	move	a14,a14			; Does player 2 exist ?
	jrn	rwlapp_go			; br = no
	cmp	a2,a14			; Are player 1 and 2 same wrestler ?
	jrnz	rwlapp_go			; br = no (no need to adjust pals)
	move	@player_pal_pref,a0	; Get player 1 palette preference
	cmpi	7,a0			; Is it last palette ?
	jrnz	rwlaset_pal		; br = no
	movk	2,a0			; force a palette above what'll be used by drones
rwlaset_pal
	move	a0,@player_pal_pref+10h	; Set player 2 palette
rwlapp_go
	.endif

	;count identical wrestlers with lower PLYRNUMs.
	movi	process_ptrs,a0
	clr	a4			; match count
	move	*a13(PLYRNUM),a2	; Get player number
	cmpi	2,a2			; Are we human ?
	jrge	rwlanot_player		; br = no
	X16	a2			; Get playre palette preference
	addi	player_pal_pref,a2
	move	*a2,a4			; Init the counter to preference
rwlanot_player
	move	*a13(WRESTLERNUM),a1

	;loop from 0 to our PLYRNUM looking for matches, UNLESS we're a
	; drone doink, in which case we just check 0 and 1.
	move	*a13(PLYRNUM),a2
	jrz	rwlaend0
	cmpi	2,a2		;first drone is okay too.
	jrle	rwlalp0
	cmpi	W_DOINK,a1
	jrne	rwlalp0
	movk	2,a2
rwlalp0	move	*a0+,a3,L
	jrz	rwlanxt0		;skip inactive
	move	*a3(WRESTLERNUM),a14
	cmp	a1,a14
	jrne	rwlanxt0
	inc	a4		;got a match--inc count
rwlanxt0	dsj	a2,rwlalp0
rwlaend0	andi	7,a4
	X32	a4
	X256	a1
	add	a1,a4
	addi	rwlawrestler_pal_table,a4
	move	*a4,a14,L	
	move	a14,b0
	rets

rwlabuddy_mode
	move	*a13(WRESTLERNUM),a0
	X64	a0
	move	*a13(PLYR_SIDE),a14
	X32	a14
	add	a14,a0
	addi	rwlabuddy_mode_pals,a0
	move	*a0,a14,L
	move	a14,b0
	rets

rwlawrestler_pal_table
	;                                            pnch     ppnch    kick     pkick
	REFLONG	HRTPNK_P,HRTBLU_P,HRTORG_P,HRTYEL_P,HRTRED_P,HRTGRN_P,HRTPRP_P,HRTGRY_P	;(Bret)
	REFLONG	RZRGRN_P,RZRPRP_P,RZRYEL_P,RZRORG_P,RZRPNK_P,RZRBLU_P,RZRRED_P,RZRGRY_P	;(Razor)
	REFLONG	UNDPRP_P,UNDBLK_P,UNDGRN_P,UNDORG_P,UNDPNK_P,UNDBLU_P,UNDYEL_P,UNDRED_P	;(Taker)
	REFLONG	YOKRED_P,YOKPRP_P,YOKYEL_P,YOKORG_P,YOKPNK_P,YOKBLU_P,YOKGRN_P,YOKGRY_P	;(Yoko)
	REFLONG	SHNRED_P,SHNPRP_P,SHNORG_P,SHNGRN_P,SHNPNK_P,SHNBLU_P,SHNYEL_P,SHNGRY_P	;(Shawn)
	REFLONG	BAMBLU_P,BAMYLW_P,BAMPRP_P,BAMORG_P,BAMPNK_P,BAMRED_P,BAMGRN_P,BAMGRY_P	;(Bam Bam)
	REFLONG	DNKBLU_P,DNKPRP_P,DNKORG_P,DNKRED_P,DNKPNK_P,DNKGRN_P,DNKYEL_P,DNKGRY_P	;(Doink)
	.long	0,0,0,0,0,0,0,0
	REFLONG	LEXWHT_P,LEXPRP_P,LEXRED_P,LEXYEL_P,LEXGRN_P,LEXPNK_P,LEXORG_P,LEXGRY_P	;(Lex)

rwlabuddy_mode_pals
	.long	HRTBLU_P,HRTRED_P
	.long	RZRBLU_P,RZRRED_P
	.long	UNDBLU_P,UNDRED_P
	.long	YOKBLU_P,YOKRED_P
	.long	SHNBLU_P,SHNRED_P
	.long	BAMBLU_P,BAMRED_P
	.long	DNKBLU_P,DNKRED_P
	.long	0,0
	.long	LEXPRP_P,LEXRED_P

*****************************************************************************
* Sets PLYR_TYPE to PTYPE_PLAYER if PLYRNUM < 2.
*
* 0a13H = process *

 SUBR	drone_change_back

	move	*a13(PLYRNUM),a14
	cmpi	2,a14
	jrge	cyhedone			;don't check real drones

	;don't bother checking if they're a drone or not.  In either case,
	; turning them human again won't hurt.
	movi	PTYPE_PLAYER,a14
	move	a14,*a13(PLYR_TYPE)
cyhedone	rets


*****************************************************************************
* (called by animation system)
*

 SUBR	start_run_flung

	.word	ANI_SETMODE,MODE_UNINT|MODE_NOAUTOFLIP
	.word	ANI_SETFACING		;so the offset works properly
	WL	ANI_CODE,qjrgx_flip
	.word	ANI_OFFSET,20,0,0
	WL	ANI_CODE,qjrgok2
	.word	ANI_GETUP,FLUNG_TIME			;Flung time
	.word	ANI_END

 SUBR	start_run_anim

	.word	ANI_SETMODE,MODE_UNINT|MODE_NOAUTOFLIP
;Is this a good idea?
	.word	ANI_DETACH
	WL	ANI_CODE,qjrgsetup_run
	.word	ANI_END

qjrgsetup_run
;	move	a13,a0
;	calla	wres_get_stick_val_cur
	PUSH	a1
;	movk	4,a1
	movk	1,a1
	calla	dufus_msg_off
	PULL	a1
	move	*a13(STICK_VAL_CUR),a0
	andi	MOVE_LEFT+MOVE_RIGHT,a0
	jrnz	qjrguse_joy1

	move	*a13(FACING_DIR),a0	;use facing
	andi	MOVE_LEFT+MOVE_RIGHT,a0
qjrguse_joy1
	move	*a13(FACING_DIR),a1
	andi	MOVE_LEFT+MOVE_RIGHT,a1
	cmp	a0,a1
	jrz	qjrgok1

;He wants to run in the opposite direction than he is facing
;Rotate him around first.

	move	*a13(FACING_DIR),a1
	andi	MOVE_UP+MOVE_DOWN,a1
	or	a1,a0
	move	a0,*a13(NEW_FACING_DIR)
	move	a0,*a13(FACING_DIR)

;	callr	set_rotate_anim
;	move	a13,a2				;a2 = * process
;	calla	change_anim_anim

qjrgok1
;	movi	qjrgdorun,a0			;this routine gets executed
	jruc	qjrgdorun
	jruc	qjrgcontx
qjrgok2
;Whenever you fling someone, a meter can & will appear
	clr	a0
	move	a0,*a13(DELAY_METER)
	movi	qjrgdorun_flung,a0			;this routine gets executed
qjrgcontx
	move	a0,*a13(CODE_ADDR),L		;when the rotate anim
	SETMODE	WAITANIM			;finishes

	move	*a13(OBJ_XVEL),a0,L
	sra	1,a0
	move	a0,*a13(OBJ_XVEL),L
	clr	a0
	move	a0,*a13(OBJ_ZVEL),L

	rets

qjrgx_flip
	move	*a13(FACING_DIR),a14
	xori	00CH,a14
	move	a14,*a13(FACING_DIR)
	rets

qjrgdorun
	clr	a0
	move	a0,*a13(GETUP_TIME)	;in control

qjrgdorun_flung
	clr	a0
	move	a0,*a13(USR_VAR1)	;with x-xel
	move	a0,*a13(RUN_TIME)


;Bogosity..
	move	*a13(FACING_DIR),a0	;use facing
;;	move	*a13(NEW_FACING_DIR),a0	;use facing

;	move	*a13(WHOHITME),a14,L
;	move	*a14(FACING_DIR),a0
;	andi	MOVE_LEFT+MOVE_RIGHT,a0
;	xori	0ch,a0

qjrgok
	move	a0,*a13(MOVE_DIR)

	move	*a13(NEW_FACING_DIR),a1
	andi	MOVE_UP+MOVE_DOWN,a1
	or	a0,a1			;LEFT or RIGHT
	move	a1,*a13(FACING_DIR)	;face same dir as run

	move	*a13(WRESTLERNUM),a0
	X32	a0
	addi	qjrgrun_anims,a0
	move	*a0,a0,L		;run anim
	calla	change_anim1a

	SETMODE	RUNNING

	movk	1,a0
	move	a0,*a13(DELAY_BUTNS)

	rets

	.ref	bam_run_anim
	.ref	dnk_run_anim
	.ref	hrt_run_anim
	.ref	lex_run_anim
	.ref	rzr_run_anim
	.ref	shn_run_anim
	.ref	und_run_anim
	.ref	yok_run_anim

qjrgrun_anims
	.long	hrt_run_anim	;0 Bret Hart
	.long	rzr_run_anim	;1 Razor Ramon
	.long	und_run_anim	;2 Undertaker
	.long	yok_run_anim	;3 Yokozuna
	.long	shn_run_anim	;4 Shawn Michaels
	.long	bam_run_anim	;5 Bam Bam
	.long	dnk_run_anim	;6 Doink
	.long	dnk_run_anim	;7 spare
	.long	lex_run_anim	;8 Lex Luger
	.long	dnk_run_anim	;9 Referee


*****************************************************************************

 SUBR	flash_white

	movi	[1111h,0000h],a1	;[color,pal]
	movi	[256,400],a2		;[Ysz,Xsz]
	clr	a3			;[Ypos,Xpos]
	clr	a4			;SAG
	movi	DMACAL,a5		;[offset,ctrl]
	calla	QDMAN
	rets

 SUBR	flash_red

	movi	[1b1bh,0000h],a1	;[color,pal]
	movi	[256,400],a2		;[Ysz,Xsz]
	clr	a3			;[Ypos,Xpos]
	clr	a4			;SAG
	movi	DMACAL,a5		;[offset,ctrl]
	calla	QDMAN
	rets

*****************************************************************************
*
* return carry set if wrestler a0 has any living teammates. (excluding self)
*
* trashes scratch

 SUBR	ck_live_teammates

	PUSH	a2,a3,a4

	move	*a0(PLYR_SIDE),a1
	movi	process_ptrs,a2
	movk	NUM_WRES,a3
atzblp	move	*a2+,a4,L
	jrz	atzbnxt		;skip inactive
	cmp	a4,a0
	jreq	atzbnxt		;skip self
	move	*a4(PLYR_SIDE),a14
	cmp	a14,a1
	jrne	atzbnxt		;skip other team
	move	*a4(PLYRMODE),a14
	cmpi	MODE_DEAD,a14
	jreq	atzbnxt		;skip dead

	;found live teammate.
	PULL	a2,a3,a4
	setc
	rets

atzbnxt	dsj	a3,atzblp
	PULL	a2,a3,a4
	clrc
	rets
	
	

*****************************************************************************
*
* return carry set if wrestler a0 has any teammates, living or dead.
*
* trashes scratch

 SUBR	ck_any_teammates

	PUSH	a2,a3,a4

	move	*a0(PLYR_SIDE),a1
	movi	process_ptrs,a2
	movk	NUM_WRES,a3
abznlp	move	*a2+,a4,L
	jrz	abznnxt		;skip inactive
	cmp	a4,a0
	jreq	abznnxt		;skip self
	move	*a4(PLYR_SIDE),a14
	cmp	a14,a1
	jrne	abznnxt		;skip other team

	;found a teammate.
	PULL	a2,a3,a4
	setc
	rets

abznnxt	dsj	a3,abznlp
	PULL	a2,a3,a4
	clrc
	rets
	
	

*****************************************************************************
*
* set smart_attack bit and set smart_target to *a13(WHOIHIT).
*

 SUBR	target_whoihit

	move	*a13(STATUS_FLAGS),a14
	ori	M_SMART_ATTACK,a14
	move	a14,*a13(STATUS_FLAGS)

	move	*a13(WHOIHIT),*a13(SMART_TARGET),L
	rets

*****************************************************************************
*
* If all of a13's opponents are dead and !zombie, and a13 is either outside
* or all his opponents are outside, setc and rets.  else clrc and rets.

 SUBR	raisearm_check

	;if a13 is human and this is a royal rumble, make sure @FINAL_PTR is
	;FFh.  If it isn't, don't raise arm.
	move	@royal_rumble,a14
	jrz	didehack_done
	move	*a13(PLYR_TYPE),a14
	jrnz	didehack_done		;PLAYER=0
	move	@FINAL_PTR,a14,L
	move	*a14,a14
	jrn	didehack_done
	jruc	dideclrc			;no good
didehack_done

	move	*a13(PLYR_SIDE),a0

	movk	NUM_WRES,a1
	movi	process_ptrs,a2
	clr	a4		;'is any opponent inside' flag.

didelp	move	*a2+,a3,L
	jrz	didenxt		;skip inactive

	move	*a3(PLYR_SIDE),a14
	cmp	a14,a0
	jreq	didenxt		;skip a13 and teammates

	move	*a3(PLYRMODE),a14
	cmpi	MODE_DEAD,a14
	jrne	dideclrc		;opp dead?

	move	*a3(STATUS_FLAGS),a14,L
	btst	B_ZOMBIE,a14
	jrnz	dideclrc		;zombie?

	move	*a3(INRING),a3
	jrnz	didenxt

	;dead !zombie bad guy is inside.  set a4
	inc	a4
didenxt	dsj	a1,didelp

	;okay, all our opponents are dead and staying that way.  now check
	; the inside/outside stuff.
	move	*a13(INRING),a14
	jrnz	didesetc		;am I outside?

	TEST	a4
	jrnz	dideclrc		;is any opponent inside?

didesetc	setc
	rets

dideclrc	clrc
	rets

*****************************************************************************
*
* Set WHOIHIT to closest opponent.  Call this after you do a LEAPAT in your
* pin.  Since pins don't actually attack, we need to do this so that WHOIHIT
* is correct when we call grnd_hit.  We can't use CLOSEST in grnd_hit, since
* it's possible to land closer to someone else than the guy you meant to pin.
* ONLY USE THIS IN PINS!!!!!!!!!!!!!! Cuz it also sets the PINNED bit.
*

 SUBR	hit_nearest

	;set WHOIHIT and victim WHOPINNEDME
	move	*a13(CLOSEST_NUM),a0
	X32	a0
	addi	process_ptrs,a0
	move	*a0,a0,L
	move	a0,*a13(WHOIHIT),L
	move	a13,*a0(WHOPINNEDME),L

	;set victim's PINNED bit.
	move	*a0(STATUS_FLAGS),a14
	ori	M_PINNED,a14
	move	a14,*a0(STATUS_FLAGS)

	rets

*****************************************************************************
*
* Change into another wrestler and re-enter the battle.  This should probably
* only be used in the king of the ring match.
*
* 0a13H = pointer to process to change
*

 SUBR	change_wrestler

****	;change wrestlernum
	move	*a13(NEW_WRESTLERNUM),*a13(WRESTLERNUM)

****	;make the new special move processes
	callr	init_smoves

****	;change palette
	calla	choose_pal
	move	b0,a0
	calla	pal_getf

	move	a0,*a13(OBJ_PAL)
	move	a0,*a13(MY_PAL)
	movk	MAX_PIECES-1,a9
	move	*a13(OBJ_BASE),a1,L
	addk	20h,a1			;skip shadow
dqskglnxt	move	*a1+,a8,L
	move	a0,*a8(OPAL)
	dsj	a9,dqskglnxt

****	;re-initialize animation
	movi	MODE_NORMAL,a14
	move	a14,*a13(PLYRMODE)
	move	*a13(WRESTLERNUM),a9
	X64	a9
	addi	dqskinit_anims,a9
	move	*a9+,a0,L
	calla	change_anim1a
	move	*a9,a0,L
	calla	change_anim2a

****	;reset STATUS_FLAGS
	clr	a14
	move	a14,*a13(STATUS_FLAGS),L

****	;reset life and combo data
	calla	init_wres_life_data

****	;clear I_WILL_DIE
	clr	a14
	move	a14,*a13(I_WILL_DIE)

****	;set new position
	movi	dqskinit_positions,a0
dqsklp1	move	*a0(dqskNXT),a14,W
	jrn	dqskusea0		;if last entry, use by default.

	;use current entry if:
	; X <= WORLDTLX-30 or
	; X >= WORLDTLX+400+30

	move	*a0(dqskXPOS),a1
	move	@WORLDTLX,a14,L
	sra	16,a14
	subk	30,a14
	cmp	a14,a1
	jrle	dqskusea0
	addi	460,a14
	cmp	a14,a1
	jrge	dqskusea0


dqsknxt1	addi	dqskSIZE,a0
	jruc	dqsklp1

dqskusea0	move	*a0(dqskXPOS),*a13(OBJ_XPOSINT)
	move	*a0(dqskZPOS),*a13(OBJ_ZPOSINT)
	move	*a0(dqskYPOS),*a13(OBJ_YPOSINT)
	move	*a0(dqskYPOS),*a13(GROUND_Y)
	move	*a0(dqskINRING),*a13(INRING)

****	;clear old velocities
	clr	a14
	move	a14,*a13(OBJ_XVEL),L
	move	a14,*a13(OBJ_YVEL),L
	move	a14,*a13(OBJ_ZVEL),L

	rets


dqskinit_anims
	REFLONG	hrt_stand4_anim,hrt_torso4_anim
	REFLONG	rzr_stand4_anim,rzr_torso4_anim
	REFLONG	und_stand4_anim,und_torso4_anim
	REFLONG	yok_stand4_anim,yok_torso4_anim
	REFLONG	shn_stand4_anim,shn_torso4_anim
	REFLONG	bam_stand4_anim,bam_torso4_anim
	REFLONG	dnk_stand4_anim,dnk_torso4_anim
	.long	0,0
	REFLONG	lex_stand4_anim,lex_torso4_anim


	;possible starting positions.  hunt until you find one that's
	; offscreen, then use it.  If none of them are offscreen (should
	; never happen,) use the last entry in the table.

	STRUCT	0
	WORD	dqskXPOS
	WORD	dqskZPOS
	WORD	dqskYPOS
	WORD	dqskINRING
	LABEL	dqskSIZE
	WORD	dqskNXT	;first element of NEXT entry. check for -1.

	;XPOSINT, ZPOSINT, YPOSINT/GROUND_Y, INRING
dqskinit_positions
	.word	RING_X_CENTER,RING_Z_CENTER,MAT_Y,0	;center
	.word	RING_TOP_LEFT,RING_Z_CENTER,MAT_Y,0	;center left
	.word	RING_TOP_RIGHT,RING_Z_CENTER,MAT_Y,0	;center right
	.word	RING_BOT_LEFT,RING_BOT,MAT_Y,0		;bottom left
	.word	RING_BOT_RIGHT,RING_BOT,MAT_Y,0		;bottom right
	.word	024Fh,060Eh,0,1				;outside left
	.word	060Eh,04ABh,0,1				;outside right
	.word	-1

*****************************************************************************
*
* Kill all my special move processes.
*

 SUBR	kill_smove_procs

	PUSH	a2,a3

	;loop through the processes. Anything with a PID of SMOVE_PID, and
	; a PA8 that matches our a13 must go.
	move	@ACTIVE,a3,L
zwsulp0	move	a3,a2		;a2 = p->this
	jrz	zwsudone0
	move	*a2,a3,L	;a3 = p->next
	move	*a2(PROCID),a14
	cmpi	SMOVE_PID,a14
	jrne	zwsulp0
	move	*a2(PA8),a14,L
	cmp	a14,a13
	jrne	zwsulp0

	;match.  kill this one
	move	a2,a0
	calla	KILL
	jruc	zwsulp0

zwsudone0	PULL	a2,a3
	rets

*****************************************************************************
*
* Check to make sure your opponent is at rest and staying that way.  Check
* to see if he's in the xxx_dead_anim.  And make sure he's in range.
* Oh, and make sure there aren't any zombies either.
*

 SUBR	can_pin

	;no pin if there are any zombies or live wrestler on other team
	movi	process_ptrs,a0
	movk	NUM_WRES,a1
	move	*a13(PLYR_SIDE),a3
lazrlp0	move	*a0+,a2,L
	jrz	lazrnxt0			;skip inactive
	move	*a2(PLYR_SIDE),a14
	cmp	a14,a3
	jreq	lazrnxt0			;skip teammates
	move	*a2(PLYRMODE),a14
	cmpi	MODE_DEAD,a14
	jrne	lazrclrc
	move	*a2(STATUS_FLAGS),a14
	btst	B_ZOMBIE,a14
	jrnz	lazrclrc
lazrnxt0	dsjs	a1,lazrlp0

	;check range
	move	*a13(CLOSEST_DIST),a0
	cmpi	70h,a0
	jrgt	lazrclrc
	move	*a13(CLOSEST_ZDIST),a0
	cmpi	50h,a0
	jrgt	lazrclrc

	calla	get_opp_process

	move	*a0(STATUS_FLAGS),a14
	btst	B_PINABLE,a14
	jrz	lazrclrc

lazrsetc	;just to be safe, set the PINNED bit on the guy
	move	*a0(STATUS_FLAGS),a14
	ori	M_PINNED,a14
	move	a14,*a0(STATUS_FLAGS)

	;and set his WHOPINNEDME
	move	a13,*a0(WHOPINNEDME),L

	;and zero his velocities
	clr	a14
	move	a14,*a0(OBJ_XVEL),L
	move	a14,*a0(OBJ_YVEL),L
	move	a14,*a0(OBJ_ZVEL),L

	;and set his PTIME to one and clear his KOD bit, 'cuz he's probably
	; been KO'd if he's a drone.
	movk	1,a14
	move	a14,*a0(PTIME)
	move	*a0(STATUS_FLAGS),a14
	andni	M_KOD,a14
	move	a14,*a0(STATUS_FLAGS)

	setc
	rets

lazrclrc	clrc
	rets

*****************************************************************************
*
* Dead wrestlers sit here.

 SUBR	xxx_dead_anim

	.word	ANI_SETMODE,MODE_NOAUTOFLIP|MODE_UNINT
	.word	ANI_SETPLYRMODE,MODE_DEAD

	WL	ANI_CODE,hitlset_pinable_bit

	WL	ANI_CODE,hitlko_if_drone

	.word	ANI_ROT		;just sit and do nothing



*****
* KO my process if I'm a drone.

 SUBRP	hitlko_if_drone

	;don't go to sleep if this is an 8-on-1 or 8-on-2 match, UNLESS
	; wrestler_count is 0, which means there's no hope of becoming
	; a zombie.
	move	@royal_rumble,a14
	jrnz	hitlis8
	calla	is_8_on_1
	jrnc	hitlnot8
hitlis8	move	@wrestler_count,a14
	jrnz	hitlrets
hitlnot8

	move	*a13(PLYR_TYPE),a14
	cmpi	PTYPE_DRONE,a14
	jrne	hitlrets

	;don't KO if I've been pinned
	move	*a13(STATUS_FLAGS),a14
	btst	B_PINNED,a14
	jrnz	hitlrets

	;don't KO if our NO_KO bit is set.
	btst	B_NO_KO,a14
	jrnz	hitlrets

	ori	M_KOD,a14
	move	a14,*a13(STATUS_FLAGS)

hitlrets	rets

*****
* set the PINABLE bit in STATUS_FLAGS

 SUBRP	hitlset_pinable_bit

	move	*a13(STATUS_FLAGS),a14
	ori	M_PINABLE,a14
	move	a14,*a13(STATUS_FLAGS)
	rets

*****************************************************************************
*
* This gets called once each MATCH for every wrestler, not each round.
* It creates the set of 'watchdog' processes that look out for special
* moves that the usual method can't handle; specifically, stuff that
* involves charging up with a stick, detailed control over timing, or
* proximity to the bad guy.
*

 SUBR	init_smoves

	move	*a13(WRESTLERNUM),a2,W
	X32	a2
	addi	xtqjspecial_moves,a2
	move	*a2,a2,L
	jrz	xtqjdone

xtqjloop
	move	*a2+,a7,L
	jrz	xtqjdone
	movi	SMOVE_PID,a1
	move	a13,a8
	calla	GETPRC_INSERT

	;store reset address
	move	*a0(PWAKE),*a0(SM_RESET_ADDRESS),L
	jruc	xtqjloop

xtqjdone
	rets


xtqjspecial_moves
	REFLONG	hrt_smove_table		;Bret
	REFLONG	rzr_smove_table		;Razor
	REFLONG	und_smove_table		;Taker
	REFLONG	yok_smove_table		;Yoko
	REFLONG	shn_smove_table		;Shawn
	REFLONG	bam_smove_table		;Bam Bam
	REFLONG	dnk_smove_table		;Doink
	.long	0			;spare
	REFLONG	lex_smove_table		;Lex

*****************************************************************************

	.bss	krngpin_timeout,16		;pin idiot check cntdown
	.bss	krnglast_dead,16		;PCNT last time we had a one-team
					; dead condition.	

 SUBR	match_timer

	movk	9,a0
	move	a0,@match_time		;10's
	move	a0,@match_time+10h	;1's
	clr	a0
	move	a0,@match_time+20h	;fractional

	callr	krngcreate_timer

	SLEEP	TSEC*2

	movk	ADJSPEED,a0		;game timer speed (1-5)
	calla	GET_ADJ
	BADCHK	a0,1,5,3		;reg,lo,hi,val
	X16	a0			;x 16 bits
	addi	timer_table-10h,a0
	move	*a0,a1

	;slow the clock to 1/3 speed if this is the royal rumble
	move	@royal_rumble,a14
	jrnz	krngisrum

	;slow the clock (2/3 speed) if it's 1v3.
	move	@PSTATUS,a14
	jrz	krngnfin
	cmpi	3,a14
	jreq	krngnfin

	move	@NUM_OPPS,a14
	cmpi	3,a14
	jrne	krngnfin

krngisrum	movi	0AAAAH,a14
	mpyu	a14,a1
	srl	16,a1

	;slow it yet again (down to 1/3 speed) if this is the final battle,
	calla	is_final_match
	jrc	krngisfin
	move	@royal_rumble,a14
	jrz	krngnfin
krngisfin	sra	1,a1

krngnfin	move	a1,a10

	;initialize krnglast_dead
	clr	a14
	move	a14,@krnglast_dead

	;initialize krngpin_timeout - we need to do this because one time in
	; 2^16, when we hit our first all-dead condition, PCNT will be 1,
	; and the code will think that this isn't a new condition and it
	; won't reset this value.  Hey, it could happen.
	movi	4*TSEC,a14
	move	a14,@krngpin_timeout

krngloop
	SLEEPK	1

	move	@HALT,a0
	jrnz	krngloop

	move	@match_time,a0,L
	jrz	krngloop

	;call krngdec_timer and update_timer only if there's a live member
	; of every team. (for this purpose, zombies count as live members)

	callr	get_live_bits
	move	a0,a3

	cmpi	3,a3
	jrne	krng1tmded		;a team is completely dead

	callr	krngdec_timer
	callr	update_timer

	jruc	krngloop

krng1tmded	;one team is completely dead - wait five seconds, and if there's
	; no pin by then, award the round to the team that's sitting on
	; it's silly drone ass instead of pinning.

	;check krnglast_dead to see if this is a new all-dead condition or
	; an old one.  if it's a new one, we need to reset krngpin_timeout.
	move	@PCNT,a14
	move	@krnglast_dead,a0
	sub	a0,a14
	dec	a14
	jrz	krngold

	;new dead condition.  reset krngpin_timeout.
	;temp! - 314
	.if DEBUG
	DBEVENT	BDE_ALL_DEAD,a13,L,a13,L,a13,L
	.endif

	movi	5*TSEC,a14
	move	a14,@krngpin_timeout

	;clear reduce_bog.  if we're in 8-on-1 or 8-on-2 mode, clear this
	; only if the human team is dead, or the drones are dead and no
	; more are coming.
	move	@royal_rumble,a14
	jrnz	krngck8_2
	calla	is_8_on_1
	jrnc	krngcrb

krngck8_1	;check the 8-on-1 case
	move	@PSTATUS,a14
	and	a3,a14		;a3 is bit of live team
	jrz	krngcrb		;on z, human team is dead
	jruc	krngdtd		;else dead team is drones

krngck8_2	;check the 8-on-2 case
	btst	0,a3		;team 0 is always humans in 8 on 2
	jrz	krngcrb		;on z, human team is dead

krngdtd	;dead team is drones
	move	@wrestler_count,a14
	cmpi	1,a14
	jrge	krngncrb

krngcrb	clr	a14
	move	a14,@reduce_bog

	;wake the crowd
	move	@crowd_process,a0,L
	movk	1,a14
	move	a14,*a0(PTIME)


krngncrb	;create the PIN HIM message process.
	move	a3,a9
	xori	3,a9
	srl	1,a9		;a8 is dead team (0 or 1)
	CREATE	PINHIM_ANIM_PID,pin_prompt

krngold	;update krnglast_dead
	move	@PCNT,a14
	move	a14,@krnglast_dead

	;dec pin_timeout and call the round if time's up.
	move	@krngpin_timeout,a14
	jrz	krngloop			;we've already called this round
	dec	a14
	jrz	krngend			;time's up - do it.
	move	a14,@krngpin_timeout
	jruc	krngloop

krngend
	CREATE	ANNC_PID,announce_rnd_winner
	.if DEBUG
	move	a13,*a0(PDATA),L	;krngCREATOR (pdata)
	movi	$,a14
	move	a14,*a0(PDATA+20h),L	;krngORIGIN
	.endif

	;stuff a 0 in krngpin_timeout so we'll know that there's no further
	; action to be taken on this all-dead condition.
	clr	a14
	move	a14,@krngpin_timeout
	jruc	krngloop


********************

krngcreate_timer

	;set pal
	movi	WGFS_W_P,b0
	calla	is_8_on_1
	jrnc	krngnfin2
	movi	WGSF_Y_P,b0

krngnfin2	movi	[186,0],a0			;x pos
	movi	[21,0],a1			;y pos
	movi	WGSF20_9,a2
	movi	200,a3			;z pos
	movi	DMAWNZ|M_3D|M_SCRNREL,a4	;DMA flags
	movi	TYPTIMERDIGIT,a5
	clr	a6				;x vel
	clr	a7				;y vel
	PUSH	b0
	calla	BEGINOBJP
	PULL	b0
	move	a8,*a13(PDATA+20h),L		;10's image pointer

	movi	[200+2,0],a0			;x pos
	movi	[21,0],a1			;y pos
	movi	WGSF20_9,a2
	calla	BEGINOBJP
	move	a8,*a13(PDATA),L		;1's image pointer

	rets

********************

krngdec_timer
	move	@match_time,a0,L
	cmpi	090009h,a0
	jrne	krngno_reset_pal
	movi	WGFS_W_P,a0
	calla	is_8_on_1
	jrnc	krngnfin3
	movi	WGSF_Y_P,a0

krngnfin3	calla	pal_getf
	move	*a13(PDATA+20h),a8,L	;10's image pointer
	move	a0,*a8(OPAL)
	move	*a13(PDATA),a8,L	;10's image pointer
	move	a0,*a8(OPAL)

krngno_reset_pal

	move	@match_time+20h,a0	;fractional
	sub	a10,a0

	move	a0,@match_time+20h
	jrnc	krngno_change

	move	@match_time+10h,a0	;1's
	dec	a0
	move	a0,@match_time+10h
	jrnc	krngno_borrow

	movk	9,a0
	move	a0,@match_time+10h

	move	@match_time,a0		;10's
	dec	a0
	move	a0,@match_time

	cmpi	0,a0

	jrne	krngno_borrow
	movi	WGSF_R_P,a0
	calla	pal_getf
	move	*a13(PDATA+20h),a8,L	;10's image pointer
	move	a0,*a8(OPAL)
	move	*a13(PDATA),a8,L	;10's image pointer
	move	a0,*a8(OPAL)

krngno_borrow
	;if time is less than 15, make noise
	move	@match_time,a0,L
	move	a0,a1
	sra	16,a0
	andi	0Fh,a1
	sla	4,a1
	or	a1,a0
	cmpi	10h,a0
	jrgt	krngno_change
	movk	10,a0			;Time warning sound
	calla	triple_sound

krngno_change
	rets

timer_table
	.asg	1500,BASETM	;2100	;16

	.word	BASETM-BASETM*30/100	;1 (slowest)	;76.6 seconds/round
	.word	BASETM-BASETM*15/100	;2 (slower)
	.word	BASETM			;3 (default)	;53.6 seconds/round
	.word	BASETM+BASETM*15/100	;4 (faster)
	.word	BASETM+BASETM*30/100	;5 (fastest)	;41.2 seconds/round


********************

 SUBR	update_timer

	move	@match_time,a0		;10's
	.if DEBUG
	cmpi	10,a0
	jrlt	krngok1

	;clock digit out of range!
	LOCKUP
krngok1
	.endif

	X32	a0
	addi	digit_tbl,a0
	move	*a0,a0,L		;* image
	move	*a13(PDATA+20h),a8,L	;10's image pointer
	move	*a8(OCTRL),a1		;DMA flags
	calla	change_image

	move	@match_time+10h,a0	;1's
	.if DEBUG
	cmpi	10,a0
	jrlt	krngok2

	;clock digit out of range!
	LOCKUP
	.endif
krngok2

	X32	a0
	addi	digit_tbl,a0
	move	*a0,a0,L		;* image
	move	*a13(PDATA),a8,L	;1's image pointer
	move	*a8(OCTRL),a1		;DMA flags
	calla	change_image

	rets

**********************************************
*
*

 SUBR	wrestler_counter

	movk	8,a9			; Initial wrestler count
	move	a9,@wrestler_count	; Initialize the count

;Turn on remaining word
	movi	[126h,0],a0
	clr	a11
	move	@PSTATUS,a14
	cmpi	3,a14
	jrz	qmndno_adj
	btst	1,a14
	jrz	qmndno_adj
	movi	[11ah,0],a11
qmndno_adj
	sub	a11,a0
	movi	[32h,0],a1
	movi	remaining,a2
name_z		equ	9
	movi	name_z,a3		;Z
	movi	DMAWNZ|M_SCRNREL,a4	;DMA flags
	movi	TYPWCCOUNT,a5		;Delete the last string
	clr	a6
	clr	a7
	movi	WSF_Y_P,b0
	calla	BEGINOBJP
	move	a8,a10

	movi	[17eh,0],a0
	sub	a11,a0
	movi	[32h,0],a1
	movi	WSF10_8,a2
	movi	name_z,a3		;Z
	movi	DMAWNZ|M_SCRNREL,a4	;DMA flags
	movi	TYPWCCOUNT,a5		;Delete the last string
	clr	a6
	clr	a7
	movi	WSF_Y_P,b0
	calla	BEGINOBJP

qmndwc_loop
	SLEEP	07fffh			; Sleep until woken up

	move	@wrestler_count,a14	; Get current count
	jrz	qmndwc_exit		; Is it 0 ? - br = yes
	cmp	a9,a14			; Has it changed from last time ?
	jrz	qmndwc_loop
	move	a14,a9			; Save for reprint

	move	@wrestler_count,a0	; Get current count
	X32	a0
	addi	qmnddigit10_tbl,a0
	move	*a0,a0,L		;* image
	move	*a8(OCTRL),a1		;DMA flags
	calla	change_image
	
	jruc	qmndwc_loop		; Go redo it

qmndwc_exit
	clr	a0
	move	a0,@wrestler_count_proc,L

	calla	DELOBJA8
	move	a10,a8
	jauc	DELOBJDIE


qmnddigit10_tbl
	.long	WSF10_0
	.long	WSF10_1
	.long	WSF10_2
	.long	WSF10_3
	.long	WSF10_4
	.long	WSF10_5
	.long	WSF10_6
	.long	WSF10_7
	.long	WSF10_8
	.long	WSF10_9


digit_tbl
	.long	WGSF20_0,WGSF20_1,WGSF20_2,WGSF20_3,WGSF20_4
	.long	WGSF20_5,WGSF20_6,WGSF20_7,WGSF20_8,WGSF20_9

*****************************************************************************

 SUBR	maybe_do_flashes
ihwqtop	SLEEPK	5
	move	@reduce_bog,a1
	jrnz	ihwqdie
	MOVE	@WORLDTLY,A0,L
	CMPI	[0ff97H,0],A0
	JRGT	ihwqtop
	CALLA	START_HI_FLASHES
	SLEEPK	30
	JRUC	ihwqtop
ihwqdie	DIE

*****************************************************************************
*
* sets our DID_RAISEARM bit.

 SUBR	set_raisearm_bit

	move	*a13(STATUS_FLAGS),a14,L
	ori	M_DID_RAISEARM,a14
	move	a14,*a13(STATUS_FLAGS),L

	rets


*****************************************************************************
*
* check our DID_RAISEARM bit--set MODE_STATUS bit if it's clear (ANI_CODE)

 SUBR	check_raisearm_bit

	move	*a13(STATUS_FLAGS),a14,L
	btst	B_DID_RAISEARM,a14
	jrz	ipzvset

ipzvclr	move	*a13(ANIMODE),a14
	andni	MODE_STATUS2,a14
	move	a14,*a13(ANIMODE)
	rets

ipzvset	move	*a13(ANIMODE),a14
	ori	MODE_STATUS2,a14
	move	a14,*a13(ANIMODE)
	rets


*****************************************************************************
*
* choose buddies for buddy mode.  return the wrestlernums in a0 and a1.

 SUBR	choose_buddies

	;prepare an exclusion mask
	clr	a7
	movk	1,a0
	move	@index1,a14
	sll	a14,a0
	or	a0,a7

	movk	1,a0
	move	@index2,a14
	sll	a14,a0
	or	a0,a7

	;count excluded wrestlers
	move	a7,a14
	clr	a8
	movk	8,a0
ydxxlp1	srl	1,a14
	jrnc	ydxxnxt1
	inc	a8
ydxxnxt1	dsj	a0,ydxxlp1

	;get the first one
	calla	get_rnd_wrestler
	PUSH	a0		;store first WRESTLERNUM

	;now exclude him and get another one.
	inc	a8		;inc exclusion count
	movk	1,a14
	sll	a0,a14
	or	a14,a7
	calla	get_rnd_wrestler
	PULL	a1		;retrieve first WRESTLERNUM

	rets

*****************************************************************************
*
* Return carry set if wrestler *a14 is behind wrestler *a13, clear otherwise.
*
* trashes a14 (isn't allowed to trash a0 or a1!)

 SUBR	is_a14_behind

	PUSH	a1

	move	*a14(OBJ_XPOSINT),a1
	move	*a13(OBJ_XPOSINT),a14
	sub	a1,a14
	jrn	piqmonrt

piqmonlt	;opponent on my left
	move	*a13(FACING_DIR),a14
	btst	MOVE_LEFT_BIT,a14
	jrz	piqmbehind
;	jruc	piqmahead

piqmahead	PULL	a1
	clrc
	rets

piqmonrt	;opponent on my right
	move	*a13(FACING_DIR),a14
	btst	MOVE_RIGHT_BIT,a14
	jrnz	piqmahead
;	jruc	piqmbehind

piqmbehind	PULL	a1
	setc
	rets

*****************************************************************************
*
* Call this when a match has just ended.  Does an appropriate sound if
* someone's winning streak has just ended.

 SUBR	loser_snd

	move	@PSTATUS,a14
	cmpi	3,a14
	jrne	sehkrets

	move	@match_winner,a1
	NOT	A1
	ANDI	3,A1
	DEC	A1
	X16	A1

	ADDI	p1oldwinstreak,A1
	MOVE	*A1,A1
	jrz	sehkrets
	MOVK	2,A0
	CALLA	RNDRNG0
	SLL	4,A0
	ADDI	sehkspeech,A0
	MOVE	*A0,A0
	CALLA	ADD_VOICE
sehkrets	rets

sehkspeech	;.word	CONGRATULATIONS
	.word	SOMEHOW_I_DONT_THINK
;	.word	L_CONGRATS
	.word	L_BACK_TO_SANDBOX
	.word	ARE_YOU_TOUGH_ENOUGH

;	.WORD	L_SIGN_YOUR_NAME
;	.WORD	THIS_IS_FOR_ALL
;	.WORD	SIGN_HERE_PLEASE


*****************************************************************************
*

 SUBR	postgame_audits

	;battle over accounting.

	;compute match_realtime
	move	@match_start_time,a14,L
	move	@PCNT,a1,L
	sub	a14,a1
	movi	55,a14
	divu	a14,a1
	move	a1,@match_realtime

	;skip all this crap after a royal_rumble
	move	@royal_rumble,a14
	jrnz	naykrets

	;increment AUD_VSHUMF or AUD_VSCPUF (and AUD_CPUWIN)
	movi	AUD_VSHUMF,a0
	move	@PSTATUS,a14
	cmpi	03h,a14
	jreq	naykvshum
	movi	AUD_VSCPUF,a0
naykvshum	calla	AUD1

	;add to AUD_2PBTIME, AUD_CPUWINTIME, or AUD_CPULOSETIME
	move	@PSTATUS,a14
	cmpi	03h,a14
	jreq	nayk2pbtime

	move	@match_winner,a0
	and	a0,a14
	jrnz	naykcpulosetime
	jruc	naykcpuwintime

nayk2pbtime
	movi	AUD_2PBTIME,a0
	jruc	naykaddtime

naykcpuwintime
	MOVE	@PSTARTS,A0
	JRZ	NO_UPDATE_ANYTHING

	MOVI	AUD_CREDLEN,A0
	MOVE	@THIS_GAME_TIME,A1
	CALLA	AUD
	MOVI	AUD_CREDLENNUM,A0
	CALLA	AUD1
	CLR	A0
	MOVE	A0,@THIS_GAME_TIME
	MOVE	A0,@PSTARTS

NO_UPDATE_ANYTHING
	movi	AUD_CPUWIN,a0
	calla	AUD1
	movi	AUD_CPUWINTIME,a0
	jruc	naykaddtime
naykcpulosetime
	movi	AUD_CPULOSETIME,a0
	jruc	naykaddtime

naykaddtime
	move	@match_realtime,a1
	calla	AUD

	;update record speeds
	move	@PSTATUS,a14
	cmpi	03h,a14
	jreq	naykfast_2p

	move	@match_winner,a0
	and	a0,a14
	jrnz	naykfast_cpulose
	jruc	naykfast_cpuwin

naykfast_2p
	movi	AUD_FASTHDH,a0
	calla	GET_AUD
	jrz	naykno_prior_hdh
	move	@match_realtime,a2
	cmp	a1,a2
	jrge	naykrecordspeed_done
naykno_prior_hdh
	movi	AUD_FASTHDH,a0
	move	@match_realtime,a1
	calla	STORE_AUDIT
	jruc	naykrecordspeed_done

naykfast_cpulose
	movi	AUD_FASTHDC,a0
	calla	GET_AUD
	jrz	naykno_prior_hdc
	move	@match_realtime,a2
	cmp	a1,a2
	jrge	naykrecordspeed_done
naykno_prior_hdc
	movi	AUD_FASTHDC,a0
	move	@match_realtime,a1
	calla	STORE_AUDIT
	jruc	naykrecordspeed_done

naykfast_cpuwin
	movi	AUD_FASTCDH,a0
	calla	GET_AUD
	jrz	naykno_prior_cdh
	move	@match_realtime,a2
	cmp	a1,a2
	jrge	naykrecordspeed_done
naykno_prior_cdh
	movi	AUD_FASTCDH,a0
	move	@match_realtime,a1
	calla	STORE_AUDIT

naykrecordspeed_done
;No speedy victories in 3 rnd matches!
	move	@current_round,a0
	cmpi	3,a0
	jrz	naykrets


	;increment the proper wrestler use thingies

	MOVE	@PSTATUS,A0
	CMPI	3,A0
	JREQ	nayk2pmatch

	;it's a one-player match.
	move	@index1,a2
	CLR	A1
	SRL	1,A0
	JRC	AUDIT_THE_HUMAN
	move	@index2,a2
	MOVK	1,A1

AUDIT_THE_HUMAN
	CALLR	naykaudit_wrestler

	move	@NUM_OPPS,a14
	cmpi	1,a14
	jrne	naykrets		;don't audit 1-vs-many matches

	;audit the computer
	move	@CURRENT_LADDER,a0,L
	move	*a0,a2,L
	sll	24,a2
	srl	24,a2		;CPU wrestlernum in a2

	;convert 7 to 8.
	cmpi	7,a2
	jrne	naykvok0
	inc	a2
naykvok0

	move	@PSTATUS,a1
	xori	3,a1
	srl	1,a1		;CPU side in a3 (!PSTATUS >> 1)

	callr	naykaudit_wrestler

	rets
	

;human vs. human match
nayk2pmatch
	;player 1
	move	@index1,a2
	CLR	A1
	CALLR	naykaudit_wrestler

	;player 2
	move	@index2,a2
	MOVK	1,A1
	CALLR	naykaudit_wrestler

naykrets	RETS

******************
* a2 = WRESTLERNUM
* a1 = PLYR_SIDE

 SUBRP	naykaudit_wrestler

	TEST	a2
	jrnn	naykok
	.if DEBUG
	LOCKUP
	.endif
	rets
naykok
	X64	a2			;x 4 words
	addi	wrestler_audits,a2

	move	@PSTATUS,a0
	btst	A1,a0
	jrnz	naykp1hum
	addi	20h,a2			;skip 2 words
naykp1hum
	move	*a2+,a0,W		;increment uses
	calla	AUD1

	move	@match_winner,a0
	btst	A1,a0
	jrz	naykp1_audited
	move	*a2+,a0,W		;increment wins
	calla	AUD1

naykp1_audited
	RETS


****************************************************************************
*
* Returns bits of teams with live members in a0.
*

 SUBR	get_live_bits

	PUSH	a1,a2,a3

	movk	NUM_WRES,a0
	movi	process_ptrs,a1
	clr	a3

cauflp1	move	*a1+,a2,L
	jrz	caufnxt1		;skip inactive

	move	*a2(PLYRMODE),a14
	cmpi	MODE_DEAD,a14
	jrne	cauflive

	move	*a2(STATUS_FLAGS),a14
	btst	B_ZOMBIE,a14
	jrz	caufnxt1		;skip dead &! zombie

cauflive	;live wrestler.  flag his team
	move	*a2(PLYR_SIDE),a14
	jrnz	cauft2

	;member of team 1
	ori	01h,a3	
	jruc	caufnxt1

cauft2	;member of team 2
	ori	02h,a3

caufnxt1	dsj	a0,cauflp1
	move	a3,a0
	PULL	a1,a2,a3

	rets

*****************************************************************************
*
* Returns carry set if any of a13's live opponents are outside the ring.
* Trashes a0, a1, a14
*

 SUBRP	any_opp_outside

	PUSH	a3

	movi	process_ptrs,a0
	movi	NUM_WRES,a1
	move	*a13(PLYR_SIDE),a2
gvdblp0	move	*a0+,a3,L
	jrz	gvdbnxt0			;skip inactive
	move	*a3(PLYR_SIDE),a14
	cmp	a14,a2
	jreq	gvdbnxt0			;skip teammates
	move	*a3(PLYRMODE),a14
	cmpi	MODE_DEAD,a14
	jreq	gvdbnxt0			;skip dead guys
	move	*a3(INRING),a14
	jrnz	gvdbsetc			;is outside?
gvdbnxt0	dsj	a1,gvdblp0

	PULL	a3
	clrc
	rets

gvdbsetc	PULL	a3
	setc
	rets

*****************************************************************************
*
* Sets a13's PLYRMODE to INAIR2 if his nearest opponent is dead, INAIR
* otherwise.
*

 SUBR	set_tbukl_airmode

	calla	get_opp_plyrmode
	cmpi	MODE_DEAD,a0
	jreq	emtudead
	movi	MODE_INAIR2,a0
	jruc	emtugo

emtudead	movi	MODE_INAIR,a0
emtugo	move	a0,*a13(PLYRMODE)
	rets
	
*****************************************************************************
*
* set MODE_STATUS bit if switches are AWAY & PUNCH.

 SUBR	free_toss_check

	move	*a13(ANIMODE),a0
	ori	MODE_STATUS2,a0

	move	*a13(CLOSEST_NUM),a14
	X32	a14
	addi	process_ptrs,a14
	move	*a14,a14,L

	move	*a14(OBJ_ZPOS),a14,L
	move	*a13(OBJ_ZPOS),a1,L
	sub	a1,a14
	abs	a14
	srl	16,a14
	cmpi	15,a14
	jrlt	avyaset


;	move	*a13(STICK_REL_CUR),a14
;	btst	MOVE_AWAY_BIT,a14
;	jrz	avyaclr

	move	*a13(BUT_VAL_CUR),a14
	cmpi	PLAYER_BLOCK_VAL,a14
	jreq	avyaset
;avyaclr
	andni	MODE_STATUS2,a0
avyaset
	move	a0,*a13(ANIMODE)
	rets

*****************************************************************************
*
* We're gonna do a free hiptoss.  Do all the neccesary setup here.  Set our
* PLYRMODE to normal, IMMOBILIZE the bad guy, clear velocities, etc.

 SUBR	setup_freetoss

	;mode normal
	SETMODE	NORMAL

	;immobilize bad guy
	move	*a13(WHOIHIT),a0,L
	movk	20,a14
	move	a14,*a0(IMMOBILIZE_TIME)

	;smart-target bad guy
	SMRTTGT	a13,WHOIHIT

	rets

******************************************************************************

	.end

