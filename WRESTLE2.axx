**************************************************************
*
* Software:		Jamie Rivett
* Initiated:		5/20/94
*
* COPYRIGHT (C) 1992 WILLIAMS ELECTRONICS GAMES, INC.
*
**************************************************************

	.file	"wrestle2.asm"
	.title	"wrestling game program cont..."
	.width	132
	.option	b,d,l,t
	.mnolist


	.include	"macros.h"
	.include	"mproc.equ"		;Mproc equates
	.include	"display.equ"		;Display proc equates
	.include	"gsp.equ"		;Gsp asm equates
	.include	"sys.equ"
	.include	"game.equ"
	.include	"audit.equ"
	.include	"plyr.equ"
	.include	"anim.equ"
	.include	"sound.h"
	.include	"sound.equ"
	.include	"ring.equ"

	.include	"imgtbl.glo"
	.include	"fontsimg.glo"
	.include	"bgndtbl.glo"
	.include	"miscimg.glo"
	.include	"jjxm.h"

	;temp! - 314
	.if DEBUG
	.include	"tmpdebug.h"
	.endif

******************************************************************************
* EXTERNAL REFERENCES

	.ref	PSTATUS2,triple_sound,change_anim1a,set_rotate_anim
	.ref	get_rope_x,round_tickcount,get_process_ptr,NUM_OPPS
	.ref	PALFRAM,HALT,dma_bog,GAMSTATE,pal_getf,process_ptrs
	.ref	change_anim2a,announce_rnd_winner,GET_ADJ,pin_prompt
	.ref	change_image,match_time,is_final_match,is_8_on_1
	.ref	ADD_VOICE,p1oldwinstreak,match_winner,RNDRNG0

	.ref	calc_line_x,PCNT,drone_meters_on,FINAL_PTR
	.ref	dnk_climbthru_side_anim,dnk_climbthru_bot_anim
	.ref	dnk_climbthru_top_anim,dnk_climbin_bot_anim
	.ref	dnk_climbin_top_anim,dnk_climbin_side_anim
	.ref	get_opp_process,adjust_health,init_wres_life_data
	.ref	HRTPNK_P,HRTBLU_P,UNDBLK_P,DNKPRP_P,YOKPRP_P
	.ref	LEXPRP_P,RZRPRP_P,BAMYLW_P,SHNPRP_P

	.ref	wrestler_x,wrestler_y,wrestler_z,index1,index2

	.ref	dnk_climb_up_anim,shn_climb_up_anim,bam_climb_up_anim
	.ref	hrt_climb_up_anim,lex_climb_up_anim,und_climb_up_anim
	.ref	yok_climb_up_anim,rzr_climb_up_anim

	.ref	bam_climbin_side_anim,bam_climbthru_side_anim
	.ref	bam_climbin_top_anim,bam_climbthru_top_anim
	.ref	bam_climbin_bot_anim,bam_climbthru_bot_anim
	.ref	und_climbin_side_anim,und_climbthru_side_anim
	.ref	und_climbin_top_anim,und_climbthru_top_anim
	.ref	und_climbin_bot_anim,und_climbthru_bot_anim
	.ref	rzr_climbin_side_anim,rzr_climbthru_side_anim
	.ref	rzr_climbin_top_anim,rzr_climbthru_top_anim
	.ref	rzr_climbin_bot_anim,rzr_climbthru_bot_anim
	.ref	hrt_climbin_side_anim,hrt_climbthru_side_anim
	.ref	hrt_climbin_top_anim,hrt_climbthru_top_anim
	.ref	hrt_climbin_bot_anim,hrt_climbthru_bot_anim
	.ref	yok_climbin_side_anim,yok_climbthru_side_anim
	.ref	yok_climbin_top_anim,yok_climbthru_top_anim
	.ref	yok_climbin_bot_anim,yok_climbthru_bot_anim
	.ref	lex_climbin_side_anim,lex_climbthru_side_anim
	.ref	lex_climbin_top_anim,lex_climbthru_top_anim
	.ref	lex_climbin_bot_anim,lex_climbthru_bot_anim
	.ref	shn_climbin_side_anim,shn_climbthru_side_anim
	.ref	shn_climbin_top_anim,shn_climbthru_top_anim
	.ref	shn_climbin_bot_anim,shn_climbthru_bot_anim
	.ref	switches_cur,switches_down,switches_up
	.ref	dufus_msg_off,get_rnd_wrestler,royal_rumble
	.ref	START_HI_FLASHES,wrestler_count,buddy_mode_on
	.ref	reduce_bog,player_pal_pref,crowd_process
	.ref	wrestler_count,wrestler_count_proc,get_opp_plyrmode
	.ref	THIS_GAME_TIME,STORE_AUDIT,GET_AUD,CURRENT_LADDER
	.ref	AUD,match_start_time,PSTARTS,match_realtime
	.ref	wrestler_audits,current_round,AUD1

******************************************************************************
* SYMBOLS DEFINED IN THIS FILE

******************************************************************************
*
* a13 = * wrestler process
* a0  = stick_val_cur

 SUBR	climb_turnbuckle

	move	a0,a4

	btst	MOVE_UP_BIT,a4		;check if player should climb
	jrz	whbnot_top		;up the turnbuckle

	move	*a13(INRING),a0
	jrnz	whbno_climb

	move	*a13(OBJ_ZPOSINT),a0
	cmpi	RING_TOP+5,a0		;give 'em 5 pixels of leeway
	jrgt	whbnot_top


	move	*a13(OBJ_XPOSINT),a0
	cmpi	RING_X_CENTER,a0
	jrgt	whbright
;whbleft
	calla	get_rope_x
	move	*a13(OBJ_COLLX1),a1
	subk	5,a1			;give 'em 5
	cmp	a0,a1			;a1-a0
	jrgt	whbno_climb

	movk	MOVE_UP_LEFT,a3		;face top left turnbuckle
	cmp	a3,a4			;Make sure UP/LEFT is pressed
	jreq	whbclimbit
	jruc	whbno_climb

whbright
	calla	get_rope_x
	move	*a13(OBJ_COLLX2),a1
	addk	5,a1			;give 'em 5
	cmp	a0,a1			;a1-a0
	jrlt	whbno_climb

	movk	MOVE_UP_RIGHT,a3	;face top right turnbuckle
	cmp	a3,a4			;Make sure UP/RIGHT is pressed
	jrne	whbno_climb


whbclimbit

;If anybody is already on turnbuckles, ignore this
	movi	process_ptrs,a4
	movi	NUM_WRES,a5

whbloop	move	*a4+,a0,L
	jrz	whbnxt			;skip inactive

	move	*a0(PLYRMODE),a14
	cmpi	MODE_ONTURNBKL,a14
	jrz	whbfound_climber
	cmpi	MODE_CLIMBTURNBKL,a14
	jrz	whbfound_climber
	jruc	whbnxt

whbfound_climber
	;check to see if we're trying to climb the one he's on
	move	*a13(OBJ_XPOSINT),a14
	move	*a0(OBJ_XPOSINT),a10
	cmpi	RING_X_CENTER,a14
	jrgt	whbck_rt

	;left tbukl
	cmpi	RING_X_CENTER,a10
	jrlt	whbno_climb
	jruc	whbnxt

whbck_rt	;right tbukl
	cmpi	RING_X_CENTER,a10
	jrgt	whbno_climb

whbnxt	dsj	a5,whbloop


	;we're going to climb - because we allow 'near misses' to climb,
	; we may have to glitch the guy to the corner.  do it here.
	movi	RING_TOP,a14
	move	a14,*a13(OBJ_ZPOSINT)

	move	*a13(WRESTLERNUM),a0
	X16	a0
	addi	whbface_turnbuckle,a0
	move	*a0,a0				;flip facing?
	jrz	whbno_flip
	xori	MOVE_UP|MOVE_DOWN|MOVE_LEFT|MOVE_RIGHT,a3	;opposite
whbno_flip
	move	a3,*a13(NEW_FACING_DIR)
	move	*a13(FACING_DIR),a0
	cmp	a0,a3
	jreq	whbclimb
	calla	set_rotate_anim
	calla	change_anim1a

	movi	whbclimb,a0			;this routine gets executed
	move	a0,*a13(CODE_ADDR),L		;when the rotate anim
	SETMODE	WAITANIM			;finishes

	setc
	rets

whbclimb
	move	*a13(WRESTLERNUM),a0
	X32	a0
	addi	whbclimb_anims,a0
	move	*a0,a0,L
	calla	change_anim1a

	SETMODE	CLIMBTURNBKL

	setc
	rets

whbnot_top
whbno_climb
	clrc
	rets

;0 = face turnbuckle before climb
;1 = back to turnbuckle
whbface_turnbuckle
	.word	1	;0 Bret Hart
	.word	1	;1 Razor Ramon
	.word	1	;2 Undertaker
	.word	0	;3 Yokozuna
	.word	0	;4 Shawn Michaels
	.word	1	;5 Bam Bam
	.word	0	;6 Doink
	.word	0	;7 Adam Bomb
	.word	1	;8 Lex Luger
	.word	0	;9 Referee


whbclimb_anims
	.long	hrt_climb_up_anim	;0 Bret Hart
	.long	rzr_climb_up_anim	;1 Razor Ramon
	.long	und_climb_up_anim	;2 Undertaker
	.long	yok_climb_up_anim	;3 Yokozuna
	.long	shn_climb_up_anim	;4 Shawn Michaels
	.long	bam_climb_up_anim	;5 Bam Bam
	.long	dnk_climb_up_anim	;6 Doink
	.long	dnk_climb_up_anim	;7 Adam Bomb
	.long	lex_climb_up_anim	;8 Lex Luger
	.long	dnk_climb_up_anim	;9 Referee

*****************************************************************************
*
* CLIMB-INS/OUTS
*

 SUBR	ck_climb_out_bot

	move	*a13(PLYRMODE),a14
	cmpi	MODE_ATTACHED,a14
	jreq	cuxdone
	cmpi	MODE_RUNNING,a14
	jreq	cuxdone
	cmpi	MODE_OPPOVERHEAD,a14
	jreq	cuxdone

;	calla	get_opp_process
;	move	*a0(INRING),a0
;	jrz	cuxdone
	callr	any_opp_outside
	jrnc	cuxdone

	;Far enough away from posts?
	move	*a13(OBJ_XPOSINT),a0
	subi	RING_X_CENTER,a0
	abs	a0
	cmpi	10Dh,a0
	jrgt	cuxdone

	move	*a13(ANIMODE),a0
	btst	MODE_UNINT_BIT,a0
	jrnz	cuxdone

	;make sure we're at the bottom edge of the ring.
	move	*a13(OBJ_ZPOS),a0,L
	cmpi	[RING_BOT,0],a0
	jrne	cuxdone

	;dummy check
	callr	idiot_check
	jrc	cuxclimb

	;button press
	move	*a13(BUT_VAL_CUR),a0
	move	a0,a0
	jrz	cuxdone

cuxclimb	move	*a13(WRESTLERNUM),a0
	X32	a0
	addi	climbthru_bot_anims,a0
	move	*a0,a0,L
	calla	change_anim1a
	movk	2,a0
	move	a0,*a13(CLIMBING_THRU)

cuxdone	rets


********
 SUBR	ck_climb_in_top

	move	*a13(PLYRMODE),a14
	cmpi	MODE_ATTACHED,a14
	jreq	wdfdone
	cmpi	MODE_DEAD,a14
	jreq	wdfdone
	cmpi	MODE_RUNNING,a14
	jreq	wdfdone
	cmpi	MODE_INAIR,a14
	jreq	wdfdone
	cmpi	MODE_INAIR2,a14
	jreq	wdfdone
	cmpi	MODE_OPPOVERHEAD,a14
	jreq	wdfdone

	move	*a13(CLIMBING_THRU),a0		;1=Climbing thru ropes flag
	jrnz	wdfdone

	move	*a13(OBJ_XPOSINT),a0
	subi	RING_X_CENTER,a0
	abs	a0
;Far enough away from posts?
	cmpi	0C0h,a0		;48h
	jrgt	wdfdone

	move	*a13(ANIMODE),a0
	btst	MODE_UNINT_BIT,a0
	jrnz	wdfdone

	;make sure we're at the top edge of the mat.
	move	*a13(OBJ_ZPOS),a0,L
	cmpi	[MAT_TOP-5,0],a0
	jrne	wdfdone
	move	*a13(MOVE_DIR),a0
	btst	MOVE_DOWN_BIT,a0
	jrz	wdfdone

	callr	idiot_check
	jrc	wdfclimb

	move	*a13(BUT_VAL_CUR),a0
	move	a0,a0
	jrz	wdfdone

wdfclimb	

	move	*a13(WRESTLERNUM),a0
	X32	a0
	addi	climbin_top_anims,a0
	move	*a0,a0,L
	calla	change_anim1a
	movk	2,a0
	move	a0,*a13(CLIMBING_THRU)

wdfdone	rets


********
 SUBR	ck_climb_out_top

	;roll right on through if we're a zombie.
	move	*a13(STATUS_FLAGS),a14
	btst	B_ZOMBIE,a14
	jrnz	jlhzombie

	move	*a13(PLYRMODE),a14
	cmpi	MODE_ATTACHED,a14
	jreq	jlhdone
	cmpi	MODE_RUNNING,a14
	jreq	jlhdone
	cmpi	MODE_OPPOVERHEAD,a14
	jreq	jlhdone

;	calla	get_opp_process
;	move	*a0(INRING),a0
;	jrz	jlhdone
	callr	any_opp_outside
	jrnc	jlhdone

	;Far enough away from posts?
	move	*a13(OBJ_XPOSINT),a0
	subi	RING_X_CENTER,a0
	abs	a0
	cmpi	0C0h,a0
	jrgt	jlhdone

	move	*a13(ANIMODE),a0
	btst	MODE_UNINT_BIT,a0
	jrnz	jlhdone

	;make sure we're at the top edge of the ring.
	move	*a13(OBJ_ZPOS),a0,L
	cmpi	[RING_TOP,0],a0
	jrne	jlhdone

	;dummy check
	callr	idiot_check
	jrc	jlhclimb

	;button press
	move	*a13(BUT_VAL_CUR),a0
	move	a0,a0
	jrz	jlhdone

jlhclimb	move	*a13(WRESTLERNUM),a0
	X32	a0
	addi	climbthru_top_anims,a0
	move	*a0,a0,L
	calla	change_anim1a
	movk	2,a0
	move	a0,*a13(CLIMBING_THRU)

jlhdone	rets

jlhzombie	move	*a13(WRESTLERNUM),a0
	X32	a0
	addi	rollthru_top_anims,a0
	move	*a0,a0,L

	move	*a13(ANIBASE),a14,L
	cmp	a0,a14
	jreq	jlhskp			;skip if we're already doing it.
	calla	change_anim1a
	movk	2,a0
	move	a0,*a13(CLIMBING_THRU)
jlhskp	rets


********
 SUBR	ck_climb_in_bot

	move	*a13(PLYRMODE),a14
	cmpi	MODE_ATTACHED,a14
	jreq	mardone
	cmpi	MODE_DEAD,a14
	jreq	mardone
	cmpi	MODE_RUNNING,a14
	jreq	mardone
	cmpi	MODE_INAIR,a14
	jreq	mardone
	cmpi	MODE_INAIR2,a14
	jreq	mardone
	cmpi	MODE_OPPOVERHEAD,a14
	jreq	mardone

	move	*a13(CLIMBING_THRU),a0		;1=Climbing thru ropes flag
	jrnz	mardone

	;Far enough away from posts?
	move	*a13(OBJ_XPOSINT),a0
	subi	RING_X_CENTER,a0
	abs	a0
	cmpi	10Dh,a0
	jrgt	mardone

	move	*a13(ANIMODE),a0
	btst	MODE_UNINT_BIT,a0
	jrnz	mardone

	;make sure we're up against the bottom of the ring
	move	*a13(OBJ_ZPOS),a0,L
	cmpi	[MAT_BOT+5,0],a0
	jrne	mardone

	move	*a13(MOVE_DIR),a0
	btst	MOVE_UP_BIT,a0
	jrz	mardone

	;dummy check
	callr	idiot_check
	jrc	marclimb

	;button press
	move	*a13(BUT_VAL_CUR),a0
	move	a0,a0
	jrz	mardone

marclimb  

	move	*a13(WRESTLERNUM),a0
	X32	a0
	addi	climbin_bot_anims,a0
	move	*a0,a0,L
	calla	change_anim1a
	movk	2,a0
	move	a0,*a13(CLIMBING_THRU)

mardone	rets

********
 SUBR	ck_climb_out_side

	move	*a13(PLYRMODE),a14
	cmpi	MODE_ATTACHED,a14
	jreq	elcdone
	cmpi	MODE_RUNNING,a14
	jreq	elcdone
	cmpi	MODE_OPPOVERHEAD,a14
	jreq	elcdone

;	calla	get_opp_process
;	move	*a0(INRING),a1
;	jrz	elcdone
	callr	any_opp_outside
	jrnc	elcdone
	move	*a0(CLIMBING_THRU),a0
	CMPI	1,A0
	JREQ	elcdone

	;Far enough away from posts?
	move	*a13(OBJ_ZPOSINT),a0
	subi	RING_Z_CENTER,a0
	abs	a0
	cmpi	48h,a0
	jrgt	elcdone

	move	*a13(ANIMODE),a0
	btst	MODE_UNINT_BIT,a0
	jrnz	elcdone

	;make sure we're up against one of the sides
	calla	get_rope_x
	move	a0,a4
	cmpi	RING_X_CENTER,a0
	jrgt	elcrt

elclf	move	*a13(STICK_VAL_CUR),a0
	btst	MOVE_LEFT_BIT,a0
	jrz	elcdone

	move	a4,a0
	move	*a13(OBJ_COLLX1),a1
	cmp	a0,a1
	jrle	elcout_lf
	jruc	elcdone

elcrt	move	*a13(STICK_VAL_CUR),a0
	btst	MOVE_RIGHT_BIT,a0
	jrz	elcdone

	move	a4,a0
	move	*a13(OBJ_COLLX2),a1
	cmp	a0,a1
	jrge	elcout_rt
	jruc	elcdone

elcout_lf	movk	MOVE_DOWN_LEFT,a2
	jruc	elcdummy

elcout_rt	movk	MOVE_DOWN_RIGHT,a2

elcdummy	;dummy check
	callr	idiot_check
	jrc	elcspecial_face

	;button press
	move	*a13(BUT_VAL_CUR),a0
	move	a0,a0
	jrz	elcdone

elcface	move	*a13(FACING_DIR),a1
	cmp	a2,a1
	jreq	elcclimb

	move	a2,*a13(NEW_FACING_DIR)
	calla	set_rotate_anim
	calla	change_anim1a

	movi	elcclimb,a0
	move	a0,*a13(CODE_ADDR),L
	SETMODE	WAITANIM
	movk	1,a0
	move	a0,*a13(CLIMBING_THRU)
	rets

elcclimb	move	*a13(WRESTLERNUM),a0
	X32	a0
	addi	climbthru_side_anims,a0
	move	*a0,a0,L
	calla	change_anim1a

	SETMODE	NORMAL

	movk	1,a0
	move	a0,*a13(CLIMBING_THRU)
elcdone	rets

elcspecial_face
	move	*a13(PLYRMODE),A1
	CMPI	MODE_WAITANIM,a1
	JREQ	elcdone
	jruc	elcface

********
 SUBR	ck_climb_in_side

	move	*a13(PLYRMODE),a14
	cmpi	MODE_ATTACHED,a14
	jreq	yhvdone
	cmpi	MODE_DEAD,a14
	jreq	yhvdone
	cmpi	MODE_OPPOVERHEAD,a14
	jreq	yhvdone

	move	*a13(CLIMBING_THRU),a0		;1=Climbing thru ropes flag
	jrnz	yhvdone

;Far enough away from posts?
	move	*a13(OBJ_ZPOSINT),a0
	subi	RING_Z_CENTER,a0
	abs	a0
	cmpi	0D8h,a0
	jrgt	yhvdone

	;is he close enough to the ring?
	move	*a13(OBJ_XPOSINT),a0
	cmpi	RING_X_CENTER,a0
	jrlt	yhvon_left

	;he's right of center
	movk	MOVE_LEFT_BIT,A2
	movi	vln_right_matedge2,a6
	movk	MOVE_DOWN_LEFT,a7
	move	*a13(OBJ_COLLX1),a14
	jruc	yhvd_set

yhvon_left
	;he's left of center
	movk	MOVE_RIGHT_BIT,A2
	movi	vln_left_matedge2,a6
	movk	MOVE_DOWN_RIGHT,a7
	move	*a13(OBJ_COLLX2),a14

yhvd_set

	move	*a13(PLYRMODE),a0
	cmpi	MODE_RUNNING,a0
	jrne	no_special_check

	move	*a13(GETUP_TIME),a0
	jrnz	yhvdone

	jruc	running_back_in_here

no_special_check
	move	*a13(ANIMODE),a0
	btst	MODE_UNINT_BIT,a0
	jrnz	yhvdone

	move	*a13(PLYRMODE),a0
	cmpi	MODE_HEADHELD,a0
	jreq	yhvdone
	cmpi	MODE_HEADHOLD,a0
	jreq	yhvdone
	cmpi	MODE_INAIR,a0
	jreq	yhvdone
	cmpi	MODE_INAIR2,a0
	jreq	yhvdone

running_back_in_here
	calla	calc_line_x
	sub	a14,a0
	abs	a0
	cmpi	10,a0
	jrgt	yhvdone

	move	*a13(MOVE_DIR),a0
	btst	A2,a0
	jrz	yhvdone

	;idiot check
	callr	idiot_check
	jrc	yhvclimb

	move	*a13(PLYRMODE),a0
	cmpi	MODE_RUNNING,a0
	jrz	yhvclimb

	;button press
	move	*a13(BUT_VAL_CUR),a0
	move	a0,a0
	jrz	yhvdone

yhvclimb	;he's within five pixels of his mat edge.  face the ring
	move	*a13(FACING_DIR),a1
	cmp	a7,a1
	jreq	yhvjump_in

	move	a7,*a13(NEW_FACING_DIR)
	calla	set_rotate_anim
	calla	change_anim1a

	movi	yhvjump_in,a0
	move	a0,*a13(CODE_ADDR),L
	SETMODE	WAITANIM
	movk	1,a0
	move	a0,*a13(CLIMBING_THRU)
	rets

yhvjump_in
	move	*a13(WRESTLERNUM),a0
	X32	a0
	addi	climbin_side_anims,a0
	move	*a0,a0,L
	calla	change_anim1a

	SETMODE	NORMAL
	movk	1,a0
	move	a0,*a13(CLIMBING_THRU)

yhvdone	rets

climbthru_bot_anims
	.long	hrt_climbthru_bot_anim	;0 Bret Hart
	.long	rzr_climbthru_bot_anim	;1 Razor Ramon
	.long	und_climbthru_bot_anim	;2 Undertaker
	.long	yok_climbthru_bot_anim	;3 Yokozuna
	.long	shn_climbthru_bot_anim	;4 Shawn Michaels
	.long	bam_climbthru_bot_anim	;5 Bam Bam
	.long	dnk_climbthru_bot_anim	;6 Doink
	.long	dnk_climbthru_bot_anim	;7 Adam Bomb
	.long	lex_climbthru_bot_anim	;8 Lex Luger
	.long	dnk_climbthru_bot_anim	;9 Referee

climbthru_top_anims
	.long	hrt_climbthru_top_anim	;0 Bret Hart
	.long	rzr_climbthru_top_anim	;1 Razor Ramon
	.long	und_climbthru_top_anim	;2 Undertaker
	.long	yok_climbthru_top_anim	;3 Yokozuna
	.long	shn_climbthru_top_anim	;4 Shawn Michaels
	.long	bam_climbthru_top_anim	;5 Bam Bam
	.long	dnk_climbthru_top_anim	;6 Doink
	.long	dnk_climbthru_top_anim	;7 Adam Bomb
	.long	lex_climbthru_top_anim	;8 Lex Luger
	.long	dnk_climbthru_top_anim	;9 Referee

climbin_bot_anims
	.long	hrt_climbin_bot_anim	;0 Bret Hart
	.long	rzr_climbin_bot_anim	;1 Razor Ramon
	.long	und_climbin_bot_anim	;2 Undertaker
	.long	yok_climbin_bot_anim	;3 Yokozuna
	.long	shn_climbin_bot_anim	;4 Shawn Michaels
	.long	bam_climbin_bot_anim	;5 Bam Bam
	.long	dnk_climbin_bot_anim	;6 Doink
	.long	dnk_climbin_bot_anim	;7 Adam Bomb
	.long	lex_climbin_bot_anim	;8 Lex Luger
	.long	dnk_climbin_bot_anim	;9 Referee

climbin_top_anims
	.long	hrt_climbin_top_anim	;0 Bret Hart
	.long	rzr_climbin_top_anim	;1 Razor Ramon
	.long	und_climbin_top_anim	;2 Undertaker
	.long	yok_climbin_top_anim	;3 Yokozuna
	.long	shn_climbin_top_anim	;4 Shawn Michaels
	.long	bam_climbin_top_anim	;5 Bam Bam
	.long	dnk_climbin_top_anim	;6 Doink
	.long	dnk_climbin_top_anim	;7 Adam Bomb
	.long	lex_climbin_top_anim	;8 Lex Luger
	.long	dnk_climbin_top_anim	;9 Referee

climbthru_side_anims
	.long	hrt_climbthru_side_anim	;0 Bret Hart
	.long	rzr_climbthru_side_anim	;1 Razor Ramon
	.long	und_climbthru_side_anim	;2 Undertaker
	.long	yok_climbthru_side_anim	;3 Yokozuna
	.long	shn_climbthru_side_anim	;4 Shawn Michaels
	.long	bam_climbthru_side_anim	;5 Bam Bam
	.long	dnk_climbthru_side_anim	;6 Doink
	.long	dnk_climbthru_side_anim	;7 Adam Bomb
	.long	lex_climbthru_side_anim	;8 Lex Luger
	.long	dnk_climbthru_side_anim	;9 Referee

climbin_side_anims
	.long	hrt_climbin_side_anim	;0 Bret Hart
	.long	rzr_climbin_side_anim	;1 Razor Ramon
	.long	und_climbin_side_anim	;2 Undertaker
	.long	yok_climbin_side_anim	;3 Yokozuna
	.long	shn_climbin_side_anim	;4 Shawn Michaels
	.long	bam_climbin_side_anim	;5 Bam Bam
	.long	dnk_climbin_side_anim	;6 Doink
	.long	dnk_climbin_side_anim	;7 Adam Bomb
	.long	lex_climbin_side_anim	;8 Lex Luger
	.long	dnk_climbin_side_anim	;9 Referee

rollthru_top_anims
	REFLONG	hrt_rollthru_top_anim	;0 Bret Hart
	REFLONG	rzr_rollthru_top_anim	;1 Razor Ramon
	REFLONG	und_rollthru_top_anim	;2 Undertaker
	REFLONG	yok_rollthru_top_anim	;3 Yokozuna
	REFLONG	shn_rollthru_top_anim	;4 Shawn Michaels
	REFLONG	bam_rollthru_top_anim	;5 Bam Bam
	REFLONG	dnk_rollthru_top_anim	;6 Doink
	.long	0			;7 unused
	REFLONG	lex_rollthru_top_anim	;8 Lex Luger


*****************************************************************************
*
* Updates CLIMB_START and CLIMB_LAST, and returns carry if it's time to
* climb.  Note that we can't count on idiot_check being called only once
* per tick.  As of this writing (28 Feb) it's at least two, and sometimes
* three.  If CLIMB_LAST == PCNT, quit.  If CLIMB_LAST == PCNT - 1, set
* CLIMB_LAST = PCNT, and compare CLIMB_LAST - CLIMB_START against
* IDIOT_COUNT. On GE, setc and return, else clrc and return.  If CLIMB_LAST
* isn't PCNT or PCNT-1, set it and CLIMB_START to PCNT, clrc, and rets.
*		

lngIDIOT_COUNT	.equ	21

 SUBRP	idiot_check

	move	*a13(CLIMB_LAST),a14
	move	@PCNT,a0
	cmp	a0,a14
	jreq	lngno

	inc	a14
	cmp	a0,a14
	jreq	lngcont

	;new stick.
	move	a0,*a13(CLIMB_START)
	move	a0,*a13(CLIMB_LAST)
lngno	clrc
	rets

lngcont	move	a0,*a13(CLIMB_LAST)
	move	*a13(CLIMB_START),a14
	sub	a14,a0
	cmpi	lngIDIOT_COUNT,a0
	jrlt	lngno

	;climb!
	setc
	rets

;*****************************************************************************
;*
;* a13 = wrestler process
;
; SUBR	clear_damage_log
;
;	move	a13,a2
;	addi	DAMAGE_HIST,a2		;start of damage stucture
;
;	clr	a0
;	movk	20,a1			;8 longs
;lngclr_loop
;	move	a0,*a2+,L
;	dsj	a1,lngclr_loop
;
;	rets
;
;
;*****************************************************************************
;*
;* a13 = wrestler process
;* a0  = damage amount (only if negative)
;
; SUBR	log_damage
;
;	move	a0,a0
;	jrnn	lngnot_damage
;
;	PUSH	a1,a2,a3
;
;	move	a13,a1
;	move	a13,a2
;
;	addi	DAMAGE_HIST+19*32,a1	;start at end of structure and
;	addi	DAMAGE_HIST+20*32,a2	;move everything down 1 long
;
;	movk	19,a3
;lnglp	move	-*a1,-*a2,L
;	dsjs	a3,lnglp
;
;	move	a0,a1			;damage amount
;	neg	a1
;	sll	16,a1
;	move	@round_tickcount,a2	;ticks since match started
;	andi	0ffffh,a2
;	or	a1,a2
;	move	a2,*a13(DAMAGE_HIST),L
;
;	PULL	a1,a2,a3
;
;lngnot_damage
;	rets
;
;
;*****************************************************************************
;*
;* ARGS:		a13 = wrestler process
;*		 a0 = timespan (in ticks)
;*
;* RETURNS:	 a0 = damage total
;*
;* TRASHES:	a1-a6,a14
;*
;
; SUBR	tally_damage
;
;	move	@round_tickcount,a4	;ticks since match started
;	clr	a5			;damage tally
;
;	move	a13,a1
;	addi	DAMAGE_HIST,a1		;start of damage stucture
;
;	movk	20,a6
;lngloop
;	move	*a1+,a2			;tick count
;	jrz	lngexit			;can't have a 0 tick count
;	move	*a1+,a3			;damage
;
;	move	a4,a14
;	sub	a2,a14
;	cmp	a0,a14			;> timespan?
;	jrgt	lngexit
;
;	add	a3,a5
;	dsj	a6,lngloop
;
;lngexit
;	move	a5,a0
;	rets
;
*****************************************************************************
*
* a10 = player number (0 to NUM_WRES-1)

GETUP_SIZE	equ	80 ;102	;174	;99
MAX_TIME	equ	6*TSEC
INV_MULT	equ	256*GETUP_SIZE/MAX_TIME
ONSCR_X		equ	173
OFFSCR_X	equ	221

	STRUCTPD
	LONG	IPTR_FRAME
	LONG	IPTR_GREEN
	WORD	DISPLAY_VAL

 SUBR	getup_meter

	;HACK ALERT: In royal rumble mode, player 1 is on PLAYER 0's TEAM,
	; so this code is gonna want to put his getup meter on the left.
	; To get it over on the right where it belongs, we temporarily put
	; him on the other team.  This shouldn't break anything.

	move	@royal_rumble,a14
	jrz	xnenorum
	cmpi	1,a10		;(plyrnum)
	jrne	xnenorum
	movk	1,a9		;act like plyr 1 is on team 1.
xnenorum

	move	a10,a11			;a11 is PLYRNUM
	move	a10,a1
	calla	get_process_ptr
	move	a0,a10			;a10 is our wrestler process

	SLEEPK	2

	;first off, figure out if this guy is even allowed to have a getup
	; meter.  Humans always get them.  A drone teammate of a human
	; doesn't get one.  Otherwise, drones only get them if the GETUP
	; powerup is set and they're the only drone on their team.

	move	*a10(PLYR_TYPE),a14
	cmpi	PTYPE_PLAYER,a14
	jreq	xneyes		;humans get getup meters

	movk	NUM_WRES,a0
	movi	process_ptrs,a1
	move	*a10(PLYR_SIDE),a2	;we'll need that later anyway.
xnelp0	move	*a1+,a3,L
	jrz	xnenxt0		;skip inactive
	cmp	a3,a10
	jreq	xnenxt0		;skip self
	move	*a3(PLYR_SIDE),a14
	cmp	a14,a2
	jrne	xnenxt0		;skip other team
	move	*a3(PLYR_TYPE),a14
	cmpi	PTYPE_PLAYER,a14
	jreq	xnedie		;we have a human teammate so we don't get one
	jruc	xnenxt0

xnedie	clr	a14
	move	a14,*a10(METER_PROC),L
	DIE			;multi-drone team--no meters

xnenxt0	dsjs	a0,xnelp0

	;we got through the loop and found no teammates, so we're a lone
	; drone and we get a meter only if GETUP_POWER is set.
;	move	@GETUP_POWER,a14
	move	@drone_meters_on,a14
	jrz	xnedie		;no GETUP_POWER--no meter

	move	@NUM_OPPS,a1
	cmpi	2,a1	   
	jrge	xnedie


xneyes	clr	a0
	move	a0,*a13(DISPLAY_VAL)

	;set our x-position based on PLYR_SIDE
	movi	[OFFSCR_X,0],a10
	move	a9,a9
	jrnz	xnep2

	dec	a10
	neg	a10
xnep2

	movi	RECVRBLK,a2			;* image (green bar)
	movi	[109,0],a1			;y pos
	movi	1801h,a3			;z pos
	callr	xnebegin_obj
	move	a8,*a13(IPTR_GREEN),L
	movi	RECVR_R,a2			;* image (frame)
	move	a9,a9
	jrnz	xnep2_meter
	movi	RECVR_L,a2			;* image (frame)
xnep2_meter
	movi	[189,0],a1			;y pos
	movi	1800h,a3			;z pos
	callr	xnebegin_obj
	move	a8,*a13(IPTR_FRAME),L

	move	a11,a1
	calla	get_process_ptr
	move	a0,a10

	move	a13,*a10(METER_PROC),L

 SUBR 	slide_offscr

;Don't allow a meter to come out for awhile (unless flung)
	movi	18*60,a0	;13
	move	a0,*a10(DELAY_METER)

	movk	10,a11
xneoffscr_loop
	move	a11,a11
	jrz	xneupdate
	dec	a11
	jruc	xnecont
xneupdate
	movi	[OFFSCR_X,0],a0
	callr	xneset_x

	move	*a10(WHOHITME),A0,L
	move	*a0(COMBO_COUNT),A14
	jrnz	xnecont
	move	*a10(DELAY_METER),a14
	jrnz	xnecont
	move	*a10(PLYRMODE),a14
	cmpi	MODE_DEAD,a14
	jrz	xnecont
;If health meter is down low, don't have getup meter come out.
;Unless it was a fling!
	move	*a10(PLYRNUM),a1
	.ref	get_health
	calla	get_health
	cmpi	20,a0
	jrgt	xnenorm
	move	*a10(GETUP_TIME),a14
	cmpi	FLUNG_TIME,a14
	jrz	xneonscr

xnenorm
	move	*a10(GETUP_TIME),a14
	jrnz	xneonscr

xnecont
	SLEEPK	1
	jruc	xneoffscr_loop


xneonscr
	move	a14,a11

	movi	GETUP_SIZE,a0
	move	a0,*a13(DISPLAY_VAL)

	MOVI	0BDH,A0			;Meter announce sound
	CALLA	triple_sound

	movi	120,a6
	move	*a10(GETUP_TIME),a5

xneonscr_loop

	movi	[ONSCR_X,0],a0
	callr	xneset_x

	move	*a10(GETUP_TIME),a7

	;if a7 (current getup) is greater than a11 (starting getup), our
	; scale will be messed up.  In this case, just move a7 into a11.
	cmp	a11,a7
	jrle	xnerescale
	move	a7,a11

xnerescale
	movi	GETUP_SIZE,a0
	mpyu	a0,a7			;* GETUP_SIZE
	divu	a11,a7			;/ INITIAL GETUP TIME

	move	*a13(DISPLAY_VAL),a0
	cmp	a0,a7			;has getup been incremented?
	jrle	xneok1

	move	a7,a11
	movi	GETUP_SIZE,a0
	mpyu	a0,a7			;* GETUP_SIZE
	divu	a11,a7			;/ INITIAL GETUP TIME
xneok1
	.ref	dufus_msg_on

	subk	1,a6
	jrnz	xnedont_bother
	move	*a10(GETUP_TIME),a0
	sub	a0,a5
	cmpi	175,a5
	jrgt	xnedont_bother
	PUSH	a2,a7,a9
	movk	2,a9
	CREATE	4000h|AWARD_PID,dufus_msg_on
	PULL	a2,a7,a9
xnedont_bother

	PUSH	a5,a6
	callr	xneupdate_meter
	PULL	a5,a6

	move	a7,a7
	jrz	slide_offscr

	move	*a10(PLYRMODE),a0
	cmpi	MODE_DEAD,a0
	jrz	slide_offscr

	PUSHP	a5,a6
	SLEEPK	1
	PULLP	a5,a6
	jruc	xneonscr_loop


**********
 SUBRP	xneset_x

	move	a9,a9
	jrnz	xnep22
	neg	a0
xnep22
	addi	[200-1,0],a0			;center of screen
	move	a13,a14
	addi	IPTR_FRAME,a14
	move	*a14,a8,L
	move	*a8(OXVAL),a1,L
	sub	a1,a0
	sra	2,a0
	movk	3-1,a1
xnelp	move	*a14+,a8,L
	move	*a8(OXVAL),a2,L
	add	a0,a2
	move	a2,*a8(OXVAL),L
	dsj	a1,xnelp
	rets


**********
 SUBRP	xnebegin_obj

	movi	[200-1,0],a0			;x pos
	add	a10,a0

	movi	DMAWNZ|M_SCRNREL,a4		;DMA flags
	clr	a5				;object ID
	clr	a6				;x vel
	clr	a7				;y vel
	calla	BEGINOBJ
	rets


**********
 SUBRP	xneupdate_meter

	move	*a13(DISPLAY_VAL),a0
	add	a0,a7
	srl	1,a7
	move	a7,*a13(DISPLAY_VAL)
	move	a7,a1

	neg	a1
	addi	GETUP_SIZE,a1
	jrp	xneok
	clr	a1
xneok	movi	GETUP_SIZE,a0
	cmp	a0,a1				;meter can't be taller
	jrle	xneok2				;than GETUP_SIZE pixels
	move	a0,a1
xneok2	move	*a13(IPTR_GREEN),a8,L

	MOVI	GETUP_SIZE,A2
	SUB	A1,A2
	MOVE	A2,*A8(OSIZEY)
	MOVI	RECVRBLK,A0
	MOVE	*A0(ICTRL),A5
	SRL	12,A5
	MOVE	A1,A3
	MPYU	A5,A3
	MOVE	*A0(ISIZEX),A5
	MPYU	A5,A3
	MOVE	*A0(ISAG),A0,L
	ADD	A3,A0
	MOVE	A0,*A8(OSAG),L

	rets

*****************************************************************************
*
* makes your getup meter go away if you've got one out.

 SUBR	ditch_getup_meter_a9
	PUSH	a13
	move	a9,a13
	callr	ditch_getup_meter
	PULL	a13
	rets

 SUBR	ditch_getup_meter

	move	*a13(GETUP_TIME),a0
	jrz	aywcont
	move	*a13(PLYR_DIZZY),a0
	jrnz	aywcont

;This guy has a getup meter on screen and is running out of control!
;Cause getup meter to slide off screen.

	move	*a13(METER_PROC),a0,L
	jrz	aywcont		;skip if we don't have a meter.
	PUSH	a8,a9,a10
	move	*a0(PA8),a8,L
	move	*a0(PA9),a9,L
	move	*a0(PA10),a10,L
	movi	GETUP_PID,a1
	movi	slide_offscr,a7
	calla	XFERPROC
	PULL	a8,a9,a10

aywcont	rets

*****************************************************************************
*
*	a0  = # ticks to add
*	a13 = * wrestler process

 SUBR	inc_getup_time

	PUSH	a14
	move	*a13(GETUP_TIME),a14
	cmpi	20,a14
	jrlt	vrbexit
	add	a0,a14
	move	a14,*a13(GETUP_TIME)
vrbexit
	PULL	a14
	rets

*****************************************************************************
*
* do rolls for any wrestler
*
* args : a13 = * wrestler process
*
* returns : Z=1 if didn't roll

 SUBR	do_roll

	move	*a13(OBJ_ZPOSINT),a0
	move	*a13(Z_BOUND),a14
	jrz	slgreg

	sub	a0,a14
	abs	a14		;<-new!
	cmpi	6,a14
	jrle	slgno_roll
slgreg
	move	*a13(STICK_VAL_CUR),a0
	andi	MOVE_UP|MOVE_DOWN,a0
	jrz	slgno_roll

	move	*a13(WRESTLERNUM),a14
	X32	a14
	addi	slgroll_table,a14
	move	*a14,a14,L

	move	*a14+,a1		;roll speed
	move	*a14+,a2,L		;z velocity

	btst	MOVE_DOWN_BIT,a0
	jrnz	slgdown
	neg	a1			;must be up
	neg	a2
slgdown
	move	a2,*a13(OBJ_ZVEL),L

	move	*a13(ROLL_POS),a0
	add	a0,a1
	andi	0ffh,a1
	move	a1,*a13(ROLL_POS)
	move	*a14+,a0,L		;inv multiplier
	mpyu	a0,a1
	srl	16,a1			;/65536
	X32	a1
	add	a1,a14
	move	*a14,a0,L
 .if DEBUG
	jrnz	slgok
 	LOCKUP
slgok
 .endif

	move	*a0,a0,L
 .if DEBUG
	jrnz	slgok2
 	LOCKUP
slgok2
 .endif

	move	a0,*a13(CUR_FRAME),L
	rets


slgno_roll
	clr	a0
	move	a0,*a13(OBJ_ZVEL),L
	rets


slgroll_table
	REFLONG	hrt_roll_frames	;0 Bret Hart
	REFLONG	rzr_roll_frames	;1 Razor Ramon
	REFLONG	und_roll_frames	;2 Undertaker
	REFLONG	yok_roll_frames	;3 Yokozuna
	REFLONG	shn_roll_frames	;4 Shawn Michaels
	REFLONG	bam_roll_frames	;5 Bam Bam
	REFLONG	dnk_roll_frames	;6 Doink
	.long	0		;7 unused
	REFLONG	lex_roll_frames	;8 Lex Luger


;
;*****************************************************************************
;
; SUBR	check_dizzy
;
;	movi	4*TSEC,a0
;	calla	tally_damage
;
;;Is this the right way to causes dizzies?
;;If one move is super powerful, we will tend to get dizzies when we don't want
;;them.  Maybe it should be based on hits over time, not damage.
;
;;A combination of the two is needed here! 10/5/94
;
;;We need less resolution on the damage that is recorded!
;;Perhaps 1-3?
;
;;We should allow this to happen only once per round!
;
;	cmpi	65,a0
;
;	jrlt	slgno_dizzy
;
;	jruc	slgno_dizzy
;
;
;	calla	clear_damage_log
;
;;Don't allow dizzies if your health meter is real low!
;;Killer Instinct sucks....
;	move	*a13(PLYRNUM),a1
;	.ref	get_health
;	calla	get_health
;	cmpi	30,a0
;	jrlt	slgno_dizzy
;
;;Too many dizzies this round?
;	move	*a13(PLYR_DIZZY_CNT),a0
;	cmpi	1,a0				;Max dizzies per round
;	jrge	slgno_dizzy
;
;	inc	a0
;	move	a0,*a13(PLYR_DIZZY_CNT)
;
;
;	movk	1,a0	;return TRUE
;	move	a0,*a13(PLYR_DIZZY)
;	rets
;
;slgno_dizzy
;	clr	a0	;return FALSE
;	rets

*****************************************************************************

 SUBR	form_button_value

	;Combine the val_cur of the block bit with the val_down of the rest.

	move	*a13(BUT_VAL_CUR),a0
	andi	PLAYER_BLOCK_VAL,a0
	move	a0,a1
	move	*a13(BUT_VAL_DOWN),a0
	or	a1,a0
	rets

;
;*****************************************************************************
;
; SUBR	start_whack
;
;;a10=plyr proc
;;Turn on whack button graphic, animate it for a bit
;
;frame_z		.equ	202
;
;	movk	1,a0
;	move	a0,*a10(WHACK_CNT)
;
;	movi	[0f6h,0],a1
;	movi	[44h,0],a0
;	move	*a10(PLYRNUM),a2
;	jrz	xgiok
;	movi	[401-44h,0],a0
;xgiok
;	movi	WHAK0001,a2
;	movi	frame_z+2,a3			;Z
;	movi	DMAWNZ|M_3D|M_SCRNREL,a4	;DMA flags
;	movi	OVRHED_PID,a5
;	clr	a6
;	clr	a7
;	calla	BEGINOBJ
;	move	a8,a11
;
;	movi	[0f6h,0],a1
;	movi	[44h,0],a0
;	move	*a10(PLYRNUM),a2
;	jrz	xgiok2
;	movi	[401-44h,0],a0
;xgiok2
;	movi	WKBUTT01,a2
;	movi	frame_z+3,a3			;Z
;	movi	DMAWNZ|M_3D|M_SCRNREL,a4	;DMA flags
;	movi	OVRHED_PID,a5
;	clr	a6
;	clr	a7
;	calla	BEGINOBJ
;
;xgistart
;	movi	butn_l,a9
;
;xgilp	move	*a10(GETUP_TIME),a0
;	jrz	xgidie
;
;	move	*a9+,a0,L
;	jrz	xgistart
;	move	*a8(OCTRL),a1
;	calla	obj_aniq
;xginoani
;	SLEEPK	3
;	jruc	xgilp			;Going up?
;
;xgidie
;	SLEEPK	10
;
;	move	a11,a0
;	calla	DELOBJ
;	jauc	DELOBJDIE
;
;
;butn_l
;	.long	WKBUTT01
;	.long	WKBUTT02
;	.long	WKBUTT03
;	.long	WKBUTT02
;     ;	.long	0
*****************************************************************************
*
* Gets the animation point of a multipart object.  Find the highest x and y
* offset values among all the pieces.
*
* 0a0H = object table pointer
* <a0 = [Yoff,Xoff]

 SUBR	get_mpart_offsets
	PUSH	a1,a2,a9

	;reg use
	; a1 = current hi xoff
	; a2 = current hi yoff
	; a9 = loop counter

	move	*a0(IPCOUNT),a9

	.if DEBUG
	jrle	faibad
	cmpi	5,a9
	jrgt	faibad
	jruc	faiok
faibad	LOCKUP
faiok
	.endif

	move	*a0(IANIOFFX),a1
	move	*a0(IANIOFFY),a2
	addi	ICBZ,a0
	dec	a9
	jrle	faidone

failoop
	move	*a0(IANIOFFX),a14
	cmp	a1,a14
	jrle	faixc
	move	a14,a1			;new hi x

faixc
	move	*a0(IANIOFFY),a14
	cmp	a2,a14
	jrle	faiyc
	move	a14,a2			;new hi y

faiyc
	addi	ICPBZ,a0
	dsj	a9,failoop

faidone
	sla	16,a2
	move	a2,a0
	zext	a1			;clear out sign
	or	a1,a0
	PULL	a1,a2,a9
	rets

*****************************************************************************
*
* Gets the combined X size of a multi-part object.  The correct answer is
* (hi anipt) + hi (size - anipt)
*
* 0a0H = object table pointer
* <a0 = Xsize

 SUBR	get_mpart_xsize
	PUSH	a1,a2,a3,a9

	;reg use
	; a1 = current hi anipt
	; a2 = current hi size - anipt
	; a9 = loop counter

	move	*a0(IPCOUNT),a9

	move	*a0(IANIOFFX),a1
	move	*a0(ISIZEX),a2
	sub	a1,a2
	addi	ICBZ,a0
	dec	a9
	jrz	lvddone

lvdloop
	move	*a0(IANIOFFX),a14
	cmp	a1,a14
	jrle	lvdac
	move	a14,a1			;new hi x

lvdac
	move	*a0(ISIZEX),a14
	move	*a0(IANIOFFX),a3
	sub	a3,a14
	cmp	a2,a14
	jrle	lvdsac
	move	a14,a2			;new hi y

lvdsac
	addi	ICPBZ,a0
	dsj	a9,lvdloop

lvddone
	move	a2,a0
	add	a1,a0
	PULL	a1,a2,a3,a9
	rets

*****************************************************************************
*
* Zero yer TGT_YOFF.  Do this anytime you target an opponent who's on the
* ground.

 SUBR	tgt_ground

	clr	a14
	move	a14,*a13(TGT_YOFF)
	rets

*****************************************************************************
*
* Halves wrestler's X-velocity if he's moving backwards.

 SUBR	halve_bk_xvel

	move	*a13(OBJ_XVEL),a0,L
	move	*a13(FACING_DIR),a14
	btst	MOVE_RIGHT_BIT,a14
	jrnz	sfwabs
	neg	a0
sfwabs
	move	a0,a0
	jrnn	sfwok

	move	*a13(OBJ_XVEL),a0,L
	sra	1,a0
	move	a0,*a13(OBJ_XVEL),L
sfwok
	rets


*****************************************************************************
*
* scroll_world moves the screen based on the midpoint of a segment connecting
* two wrestlers.  Rules:
*
* - If there are two and only two active wrestlers, track on them.
* - If there are more than two active wrestlers and two are human, track
*   on the humans.
* - If there are more than two active wrestlers, but only one is human,
*   count his live opponents:
*	0: track on only the human player
*	1: track on human and his one live opponent
*	2: track on the human and the mean position of the two live ones.
*	3: track on the human and the mean position of the three live ones,
*	   with the closest counted twice.
* - If there are more than two active wrestlers, and NONE of them are
*   human, look for a live one.  If none are alive, track on the first
*   dead one and his closest opponent.  If one or more is alive, track
*   on the first live one and his closest opponent.
* - Don't let any human players off the top of the screen.
* - In royal rumble mode, just track on the average position of all live
*   wrestlers.  If this results in everyone being offscreen, so be it.
* - And finally, on top of everything else, if there's only one human
*   player, under no circumstances will the scroller let him off-screen.
*   He'll remain entirely on the screen regardless of whatever else might
*   be going on. (as yet unimplemented.  coming soon...)
*


xstBUFFER	equ	[20,0]

xstXMINUSX	.equ	0
xstYMINUSX	.equ	xstXMINUSX+32*(NUM_WRES+1)
xstZMINUSX	.equ	xstYMINUSX+32*(NUM_WRES+1)

LIMITXL	.EQU	[12FH,0]
LIMITXR	.EQU	[5E8H,0]
LIMITYT	.EQU	[200H,0]
LIMITYB	.EQU	[97h,0]


 SUBR	scroll_world

	MMTM	SP,A8,A9,A10,A11

	.ref	in_finish_move

	move	@in_finish_move,a0
	jrnz	xstx

	move	@HALT,a0
	jrnz	xstx

	;first, check for a royal rumble
	move	@royal_rumble,a14
	jrnz	xstrumble

	;check for two human players
	move	@PSTATUS2,a0
	jrz	xstno_humans
	cmpi	3,a0
	jrne	xstone_human

	;two humans.  track on them.
	clr	a2
	movk	1,a3
	jruc	xstindices_set

xstone_human
	;okay, we have only one player.  If this is one-on-one, track on
	; him and the drone.  (also, get the human's process ptr in a8)
	move	a0,a8
	dec	a8
	X32	a8
	addi	process_ptrs,a8
	move	*a8,a8,L

	move	@NUM_OPPS,a14
	dec	a14
	jrnz	xstone_v_many

	;plyr v. one drone
	move	*a8(PLYRNUM),a2
	movk	2,a3
	jruc	xstindices_set

xstone_v_many
	;count live opponents.  If there is one, track the human and his
	; closest opponent, which should be the live drone. If there are
	; none or more than one, track only on the human.
	;NOTE: Don't count opponents who are live but have different INRING
	; values.
	movk	NUM_WRES-2,a0
	movi	process_ptrs+40h,a1
	move	*a8(PLYR_SIDE),a2
	move	*a8(INRING),a5
	clr	a4		;live enemy counter
xstlp0	move	*a1+,a3,L
	jrz	xstdone0		;quit at first inactive since we're only
				;looking at drones
	move	*a3(PLYRMODE),a14
	cmpi	MODE_DEAD,a14
	jreq	xstnxt0		;skip dead

	move	*a3(PLYR_SIDE),a14
	cmp	a2,a14
	jreq	xstnxt0		;skip teammates

	move	*a3(INRING),a14
	cmp	a5,a14
	jrne	xstnxt0		;skip bad INRINGS

	inc	a4
xstnxt0	dsj	a0,xstlp0

xstdone0	dec	a4
	jrn	xsttrack_human_only	;0 live opponents
	jrz	xst1opp			;1 live opponent
	dec	a4
	jrz	xst2ops			;2 live opponents
	jruc	xst3ops			;3 live opponents


	;for the three cases (xst2ops, xst3ops, xstrumble) where we're tracking on
	; a mean position rather than an actual wrestler, we store the mean
	; position in the long word immediately before wrestler_[xyz].
	; There's extra space allocated there.

	;reggies:
	;	a5 = x accumulator
	;	a6 = y accumulator
	;	a7 = z accumulator


xstrumble	;There are anywhere from 1 to 4 live wrestlers.  Track on the live
	; ones.  If there's three, double-weight the one with the dead
	; teammate.  Since we've only got space for one artificial set
	; of coordinates, if we get all four alive, compute the average
	; position of all four, put that in the artificial slot, and track
	; on it twice.

	;first, count live wrestlers (drone and human)
	movi	process_ptrs,a0
	movk	4,a1		;only interested in plyrnum's 0-3
	clr	a3		;live count
	clr	a4		;PLYRNUMS
	clr	a5		; of
	clr	a6		;  live
	clr	a7		;   wrestlers
xstlp3	move	*a0+,a2,L
	move	*a2(PLYRMODE),a14
	cmpi	MODE_DEAD,a14
	jreq	xstnxt3
	move	*a2(I_WILL_DIE),a14
	jrnz	xstnxt3
	inc	a3
	move	a6,a7
	move	a5,a6
	move	a4,a5
	move	*a2(PLYRNUM),a4
xstnxt3	dsj	a1,xstlp3

	;okay, branch based on the live count
	dec	a3
	jrn	xstrr0liv		;none alive?  shouldn't happen.
	jrz	xstrr1liv
	subk	2,a3
	jrn	xstrr2liv
	jrz	xstrr3liv
	jruc	xstrr4liv

xstrr0liv	;none alive(!?)  Track on the humans
	clr	a2
	movk	1,a3
	jruc	xstindices_set

xstrr1liv	;one alive.  Track on him.
	move	a4,a2
	move	a4,a3
	jruc	xstindices_set

xstrr2liv	;two alive.  Track on them.
	move	a4,a2
	move	a5,a3
	jruc	xstindices_set

xstrr3liv	;three alive.  Since one human CAN'T be dead, the dead one must
	; be a drone.  Track on the drone and the average position of the
	; wrestlers. (a5 and a6 must be the humans, a4 the drone)

	;xst0 (human)
	movi	wrestler_x,a0
	move	*a0(xstXMINUSX),a5,L
	move	*a0(xstYMINUSX),a6,L
	move	*a0(xstZMINUSX),a7,L

	;xst1 (human)
	movi	wrestler_x+20h,a0
	move	*a0(xstXMINUSX),a14,L
	add	a14,a5
	move	*a0(xstYMINUSX),a14,L
	add	a14,a6
	move	*a0(xstZMINUSX),a14,L
	add	a14,a7

	;divide
	sra	1,a5
	sra	1,a6
	sra	1,a7

	;store
	movi	wrestler_x-20h,a0
	move	a5,*a0(xstXMINUSX),L
	move	a6,*a0(xstYMINUSX),L
	move	a7,*a0(xstZMINUSX),L

	;go
	movi	-1,a2
	move	a4,a3
	jruc	xstindices_set


xstrr4liv	;four alive.  Track on all of 'em.

	;xst0
	movi	wrestler_x,a0
	move	*a0(xstXMINUSX),a5,L
	move	*a0(xstYMINUSX),a6,L
	move	*a0(xstZMINUSX),a7,L

	;xst1
	movi	wrestler_x+20h,a0
	move	*a0(xstXMINUSX),a14,L
	add	a14,a5
	move	*a0(xstYMINUSX),a14,L
	add	a14,a6
	move	*a0(xstZMINUSX),a14,L
	add	a14,a7

	;xst2
	movi	wrestler_x+40h,a0
	move	*a0(xstXMINUSX),a14,L
	add	a14,a5
	move	*a0(xstYMINUSX),a14,L
	add	a14,a6
	move	*a0(xstZMINUSX),a14,L
	add	a14,a7

	;xst3
	movi	wrestler_x+60h,a0
	move	*a0(xstXMINUSX),a14,L
	add	a14,a5
	move	*a0(xstYMINUSX),a14,L
	add	a14,a6
	move	*a0(xstZMINUSX),a14,L
	add	a14,a7

	;divide
	sra	2,a5
	sra	2,a6
	sra	2,a7

	;store
	movi	wrestler_x-20h,a0
	move	a5,*a0(xstXMINUSX),L
	move	a6,*a0(xstYMINUSX),L
	move	a7,*a0(xstZMINUSX),L

	;go
	movi	-1,a2
	movi	-1,a3
	jruc	xstindices_set


xst3ops	;opponents must be plyrnum's 2, 3, and 4.

	;closest
	move	*a8(CLOSEST_NUM),a0
	X32	a0
	addi	wrestler_x,a0
	move	*a0(xstXMINUSX),a5,L
	move	*a0(xstYMINUSX),a6,L
	move	*a0(xstZMINUSX),a7,L

	;xst2
	movi	wrestler_x+40h,a0
	move	*a0(xstXMINUSX),a14,L
	add	a14,a5
	move	*a0(xstYMINUSX),a14,L
	add	a14,a6
	move	*a0(xstZMINUSX),a14,L
	add	a14,a7

	;xst3
	movi	wrestler_x+60h,a0
	move	*a0(xstXMINUSX),a14,L
	add	a14,a5
	move	*a0(xstYMINUSX),a14,L
	add	a14,a6
	move	*a0(xstZMINUSX),a14,L
	add	a14,a7

	;xst4
	movi	wrestler_x+80h,a0
	move	*a0(xstXMINUSX),a14,L
	add	a14,a5
	move	*a0(xstYMINUSX),a14,L
	add	a14,a6
	move	*a0(xstZMINUSX),a14,L
	add	a14,a7

	;divide
	sra	2,a5
	sra	2,a6
	sra	2,a7

	;store
	movi	wrestler_x-20h,a0
	move	a5,*a0(xstXMINUSX),L
	move	a6,*a0(xstYMINUSX),L
	move	a7,*a0(xstZMINUSX),L

	;go
	move	*a8(PLYRNUM),a2
	movi	-1,a3
	jruc	xstindices_set

xst2ops	;opponents could have 2, 3, or 4.  loop.
	clr	a5
	clr	a6
	clr	a7
	movk	NUM_WRES-2,a9		;only check drones
	movi	process_ptrs+40h,a1
	move	*a8(PLYR_SIDE),a2
	move	*a8(INRING),a11
xstlp2	move	*a1+,a0,L
	jrz	xstdone2		;quit at first inactive--only checking drones

	move	*a0(PLYRMODE),a14
	cmpi	MODE_DEAD,a14
	jreq	xstnxt2		;skip dead

	move	*a0(PLYR_SIDE),a14
	cmp	a14,a2
	jreq	xstnxt2		;skip teammates

	move	*a0(INRING),a14
	cmp	a14,a11
	jrne	xstnxt2		;skip bad INRINGs

	move	*a0(OBJ_XPOS),a14,L
	add	a14,a5
	move	*a0(OBJ_YPOS),a14,L
	add	a14,a6
	move	*a0(OBJ_ZPOS),a14,L
	add	a14,a7

xstnxt2	dsj	a9,xstlp2

xstdone2	;divide
	sra	1,a5
	sra	1,a6
	sra	1,a7

	;store
	movi	wrestler_x-20h,a0
	move	a5,*a0(xstXMINUSX),L
	move	a6,*a0(xstYMINUSX),L
	move	a7,*a0(xstZMINUSX),L

	;go
	move	*a8(PLYRNUM),a2
	movi	-1,a3
	jruc	xstindices_set


xst1opp	move	*a8(PLYRNUM),a2
	move	*a8(CLOSEST_NUM),a3
	jruc	xstindices_set

xsttrack_human_only
	move	*a8(PLYRNUM),a2
	move	a2,a3
	jruc	xstindices_set

xstno_humans
	;attract mode play.  track on first live drone and his closest
	; opponent.
	movk	NUM_WRES,a0
	movi	process_ptrs,a1
xstlp1	move	*a1+,a2,L
	jrz	xstnxt1		;skip inactive
	move	*a2(PLYRMODE),a14
	cmpi	MODE_DEAD,a14
	jreq	xstnxt1		;skip dead (shouldn't happen)

	;found a live drone.  track on him and his closest opp
	move	*a2(CLOSEST_NUM),a3
	move	*a2(PLYRNUM),a2
	jruc	xstindices_set

xstnxt1	dsj	a0,xstlp1

	;bizarre.  everyone's dead in the attract mode.  Just track on
	; first two drones.
	movk	2,a2
	movk	3,a3
	;fall through to xstindices_set

xstindices_set
	;a2 and a3 are PLYRNUM's of wrestlers to track on.  They MAY be
	; the same.
	move	a2,a0
	move	a2,a10
	move	a2,a8
	X32	a0
	X32	a10
	X32	a8
	addi	wrestler_x,a0
	addi	wrestler_y,a10
	addi	wrestler_z,a8

	move	a3,a1
	move	a3,a11
	move	a3,a9
	X32	a1
	X32	a11
	X32	a9
	addi	wrestler_x,a1
	addi	wrestler_y,a11
	addi	wrestler_z,a9

	;wrestler1 (*x,*y,*z) = (a0,a10,a8)
	;wrestler2 (*x,*y,*z) = (a1,a11,a9)

xstvalues_set
	move	*a0,a0,L
	move	*a1,a1,L
	add	a0,a1
	sra	1,a1
	subi	[200,0],a1		;middle of screen

	move	@WORLDTLX,a2,L
	sub	a2,a1
	jrp	xstpos

	addi	xstBUFFER,a1
	jrp	xstwide
	jruc	xstcont

xstpos	subi	xstBUFFER,a1
	jrn	xstwide

xstcont	sra	3,a1
	add	a1,a2

	cmpi	[12fh,0],a2
	jrlt	xstwide
	cmpi	[648h,0],a2
	jrgt	xstwide

	move	a2,@WORLDTLX,L

xstwide	move	*a8,a0,L
	move	*a9,a1,L
	add	a0,a1
	sra	1+16,a1
	movi	Y_SCALE_MULTIPLIER,a0
	mpys	a0,a1
	move	a1,a2

	move	*a10,a0,L
	move	*a11,a1,L
	add	a0,a1
	sra	1,a1
	sub	a1,a2
	subi	[0d8h,0],a2		;middle of screen

	;Check for SCROLL_CTRL bits on active wrestlers.
	movi	process_ptrs,a0
	movk	NUM_WRES,a9
xstlp4	move	*a0+,a3,L
	jrz	xstnxt4		;skip inactive

	move	*a3(STATUS_FLAGS),a14
	btst	B_SCROLL_CTRL,a14
	jrz	xstnxt4

	;control found.  On screen in X?
	move	*a3(OBJ_XPOS),a1,L
	move	@WORLDTLX,a14,L
	subi	[60,0],a14
	cmp	a14,a1
	jrlt	xstnxt4
	addi	[400+120,0],a14
	cmp	a14,a1
	jrgt	xstnxt4

	;calc hi pt
	move	*a3(OBJ_ZPOSINT),a1
	movi	Y_SCALE_MULTIPLIER,a14
	mpys	a14,a1
	move	*a3(OBJ_YPOS),a14,L
	sub	a14,a1
	move	*a3(SCROLL_Y),a14
	sla	16,a14
	sub	a14,a1

	cmp	a2,a1
	jrge	xstnxt4
	
xsttop_ok	move	a1,a2

xstnxt4	dsj	a9,xstlp4



xstsc_done
	move	@WORLDTLY,a1,L
	sub	a1,a2
	sra	2,a2
	add	a2,a1

	;Don't allow scroller to go past front fence
	cmpi	[97h,0],a1
	jrgt	xstlow
	move	a1,@WORLDTLY,L
xstlow
xstx	MMFM	SP,A8,A9,A10,A11
	rets

*****************************************************************************
*
* this is called before the velocity add and
* it's goal is to keep either wrestler from moving
* offscreen if one or both are outside the ring

vjnBUFF1	equ	185
vjnBUFF2	equ	185	;140

 SUBR	keep_onscreen

	;confine only in two-player game.
	move	@PSTATUS2,a14
	cmpi	3,a14			;is it a 2-player game?
	jrne	vjnno_2_player

	move	@WORLDTLX+16,a0		;world x int
	addi	200,a0			;center of screen

	move	a0,a1

	cmpi	RING_X_CENTER,a0
	jrgt	vjnright_side

vjnleft_side
	subi	vjnBUFF2,a0	;left edge
	addi	vjnBUFF1,a1	;right edge
	jruc	vjncont

vjnright_side
	subi	vjnBUFF1,a0
	addi	vjnBUFF2,a1
vjncont
	move	@process_ptrs,a10,L	;player 1
	move	@process_ptrs+20h,a11,L	;player 2

;	move	*a10(DEC_DELAY),a14
;	jrnz	vjninring
;	move	*a11(DEC_DELAY),a14
;	jrnz	vjninring

	.ref	allow_offscrn

	move	@allow_offscrn,a14
	jrz	vjnok
	dec	a14
	move	a14,@allow_offscrn
	jrnz	vjninring
vjnok
	move	*a10(INRING),a14
	jrnz	vjnoutside

	move	*a11(INRING),a14
	jrz	vjninring


vjnoutside	;at least 1 player outside the ring

	move	a10,a9
	callr	vjndo_check
	move	a11,a9
	callr	vjndo_check

vjninring
vjnno_2_player
	rets

vjndo_check
	move	*a9(OBJ_XPOSINT),a14
	cmp	a0,a14
	jrgt	vjnok1

;past left edge
	move	*a9(OBJ_XVEL),a14,L
	jrz	vjndone
	jrn	vjnclrx
	rets
vjnok1
	cmp	a1,a14
	jrlt	vjnok2

;past right edge
	move	*a9(OBJ_XVEL),a14,L
	jrz	vjndone
	jrn	vjndone
vjnclrx
	move	*a9(CLIMBING_THRU),a14	;1=Climbing thru ropes flag
	jrnz	vjndone

	clr	a14
	move	a14,*a9(OBJ_XVEL),L

	move	*a9(PLYRMODE),a14
	cmpi	MODE_RUNNING,a14
	jrne	vjndone

	movi	MODE_NORMAL,a14
	move	a14,*a9(PLYRMODE)
	move	a14,*a9(ANIMODE)

	callr	ditch_getup_meter_a9

vjnok2
vjndone
	rets


*****************************************************************************

MAX_YVEL	equ	-1000000h	;-40000h

 SUBR	wrestler_veladd

	move	@HALT,a0
	jrnz	ebox

	move	*a13(OBJ_XPOS),a0,L
	move	*a13(OBJ_XVEL),a1,L
	add	a1,a0
	move	a0,*a13(OBJ_XPOS),L

	move	*a13(GROUND_Y),a2
	sll	16,a2
	move	*a13(OBJ_YPOS),a0,L
	sub	a2,a0			;- GROUND_Y
	move	*a13(OBJ_YVEL),a1,L
	add	a1,a0
	jrnn	eboyok

	;under ground.  clr Yvel unless we're attached and MODE_GHOST
	move	*a13(ATTACH_PROC),a14,L
	jrz	eboset_yvel
	move	*a14(ATTACH_PROC),a14,L
	cmp	a13,a14			;valid link?
	jrne	eboset_yvel
	move	*a13(ANIMODE),a14,L
	btst	MODE_GHOST_BIT,a14
	jrnz	eboyok
	move	a1,a1			;if yvel is positive then keep
	jrn	eboset_yvel		;velocity & put at ground level
	clr	a0
	jruc	eboyok

eboset_yvel
	;we've hit the ground -- if our WAITHITOPP bit is set, stuff
	; a 1 in ANICNT.
	move	*a13(ANIMODE),a14
	btst	MODE_WAITHITOPP_BIT,a14
	jrz	ebonwho
	movk	1,a14
	move	a14,*a13(ANICNT)

ebonwho	clr	a0
	move	a0,*a13(OBJ_YVEL),L
eboyok
	add	a2,a0			;+ GROUND_Y
	move	a0,*a13(OBJ_YPOS),L



	calla	calc_ground_y

	move	*a13(OBJ_YPOS),a0,L

	move	*a13(GROUND_Y),a2
	sll	16,a2
	cmp	a0,a2			;a2-a0
	jrlt	ebook
	;we're under ground...  Unless we're attached and set MODE_GHOST,
	; stay above.
	move	*a13(ATTACH_PROC),a14,L
	jrz	eboset_ground_y
	move	*a14(ATTACH_PROC),a14,L
	jrz	eboset_ground_y
	move	*a13(ANIMODE),a14,L
	btst	MODE_GHOST_BIT,a14
	jrnz	ebook

eboset_ground_y
	move	a2,a0
ebook
	move	a0,*a13(OBJ_YPOS),L

	move	*a13(OBJ_ZPOS),a0,L
	move	*a13(OBJ_ZVEL),a1,L
	add	a1,a0
	move	a0,*a13(OBJ_ZPOS),L

	move	*a13(ANIMODE),a0
	btst	MODE_NOGRAVITY_BIT,a0
	jrnz	ebono_gravity

	move	*a13(GROUND_Y),a0
	sll	16,a0
	move	*a13(OBJ_YPOS),a1,L
	cmp	a0,a1
	jreq	ebono_gravity

	move	*a13(OBJ_YVEL),a0,L
	move	*a13(OBJ_GRAVITY),a14,L
	sub	a14,a0
	cmpi	MAX_YVEL,a0
	jrge	ebograv_ok
	movi	MAX_YVEL,a0
ebograv_ok
	move	a0,*a13(OBJ_YVEL),L
ebono_gravity

ebox
	rets


*****************************************************************************

 SUBRP	calc_ground_y

	move	*a13(INRING),a0
	jrz	bswinring

	movi	117,a1
	move	*a13(OBJ_ZPOSINT),a0
	cmpi	05bdh,a0
	jrgt	bswsetit

	movi	103,a1
	jruc	bswsetit

bswinring
	movi	112,a1

bswsetit
	move	a1,*a13(OBJ_PRIORITY)

	movi	vln_right_matedge,a6
	calla	calc_line_x
	move	*a13(OBJ_XPOSINT),a1
	cmp	a0,a1			;a1-a0
	jrge	bswoutside

	movi	vln_left_matedge,a6
	calla	calc_line_x
	move	*a13(OBJ_XPOSINT),a1
	cmp	a0,a1			;a1-a0
	jrle	bswoutside


	;an unsuccessful attempt to fix throw-into-ring bug
	;-we fucked up climbins from behind
	;trying again - climbin top and bottom weren't setting this flag!
	move	*a13(CLIMBING_THRU),a14
	jrz	bswskip

	movi	MAT_Y,a0
	move	a0,*a13(GROUND_Y)

	clr	a0
	move	a0,*a13(INRING)
	rets

bswoutside
	clr	a0
	move	a0,*a13(GROUND_Y)
	MOVE	@GAMSTATE,A0
	CMPI	INPREGAME2,A0
	jreq	bswskip

	movk	1,a0
	move	a0,*a13(INRING)
bswskip
	rets


*****************************************************************************
 .if 0

PATCH FOR SCROLLER

qhbMAX_DIST	equ	380

	move	@PSTATUS2,a14
	cmpi	3,a14			;is it a 2-player game?
	jrne	qhbno_2_player

	move	@process_ptrs,a10,L	;player 1
	move	@process_ptrs+20h,a11,L	;player 2

	move	*a10(OBJ_XPOSINT),a0	;p1 x
	move	*a11(OBJ_XPOSINT),a1	;p2 x

	sub	a0,a1			;a1-a0
	abs	a1
	cmpi	qhbMAX_DIST,a1
	jrlt	qhbok

;the 2 human wrestlers are too far apart
;now bias towards the guy in the ring -
;(since the only way this should be able to happen is when
;both guys are outside the ring, and 1 jumps back in - ignoring
;the keep_onscreen code).


qhbok
qhbno_2_player


 .endif

*****************************************************************************
*
* a0 = * wrestler process
*

 SUBR	wres_get_but_val_down

	move	*a0(PLYR_TYPE),a14
	jrnz	ecqdrndt
	move	*a0(PLYRNUM),a0
	callr	get_but_val_down
	rets

ecqdrndt
	move	*a0(DRN_BUTDT),a0
	rets

*****************************************************************************

 SUBR	wres_get_but_val_cur

	move	*a0(PLYR_TYPE),a14
	jrnz	tkrdrndt
	move	*a0(PLYRNUM),a0
	callr	get_but_val_cur
	rets

tkrdrndt
	move	*a0(DRN_BUT),a0
	rets

*****************************************************************************

 SUBR	wres_get_but_val_up

	move	*a0(PLYR_TYPE),a14
	jrnz	yrxdrnut
	move	*a0(PLYRNUM),a0
	callr	get_but_val_up
	rets

yrxdrnut
	move	*a0(DRN_BUTUT),a0
	rets

*****************************************************************************

 SUBR	wres_get_stick_val_cur

	move	*a0(PLYR_TYPE),a14
	jrnz	drn_joy
	move	*a0(PLYRNUM),a0
	callr	get_stick_val_cur
	rets

drn_joy
	move	*a0(DRN_JOY),a0
	rets


*****************************************************************************

  SUBR	wres_get_stick_rel_cur


	move	*a0(PLYR_TYPE),a14
	jrnz	drn_joy
	move	*a0(OBJ_CONTROL),a14
	move	*a0(PLYRNUM),a0
	callr	get_stick_val_cur
	btst	B_FLIPH,a14
	jrz	vuxdone

	X16	a0
	addi	vuxxflip_table,a0
	move	*a0,a0
vuxdone
	rets



;returns a value only if stick val
;has changed (but not zero)

  SUBR	wres_get_stick_rel_new


	move	*a0(PLYR_TYPE),a14
	jrnz	vuxnot_human2

;shawn - this needs patching too...

	push	a1,a10

	move	a0,a10
	move	*a10(PLYRNUM),a0
	callr	get_stick_val_up
	push	a0

	move	*a10(PLYRNUM),a0
	callr	get_stick_val_down
	pull	a1
	or	a1,a0
	jrz	vuxdone2		;no stick

	move	*a10(OBJ_CONTROL),a14
	move	*a10(PLYRNUM),a0
	callr	get_stick_val_cur
	btst	B_FLIPH,a14
	jrz	vuxdone2

	X16	a0
	addi	vuxxflip_table,a0
	move	*a0,a0
vuxdone2
	pull	a1,a10
	rets


vuxnot_human2
	move	a0,a14
	move	*a14(DRN_JOYDT),a0
	move	*a14(DRN_JOYUT),a1
	or	a1,a0
	jrz	vuxdx
	move	*a14(DRN_JOY),a0
	move	*a14(OBJ_CONTROL),a14
	btst	B_FLIPH,a14
	jrz	vuxdx

	X16	a0
	addi	vuxxflip_table,a0
	move	*a0,a0
vuxdx
	rets


vuxxflip_table	;convert to forward / away  if facing left
	.word	0000b	;0
	.word	0001b	;1
	.word	0010b	;2
	.word	0011b	;3
	.word	1000b	;4
	.word	1001b	;5
	.word	1010b	;6
	.word	1011b	;7
	.word	0100b	;8
	.word	0101b	;9
	.word	0110b	;10
	.word	0111b	;11
	.word	1100b	;12
	.word	1101b	;13
	.word	1110b	;14
	.word	1111b	;15

*****************************************************************************

 SUBR	wres_get_stick_val_down

	move	*a0(PLYR_TYPE),a14
	jrnz	ctsdrnjoy
	move	*a0(PLYRNUM),a0
	callr	get_stick_val_down
	rets

ctsdrnjoy
	move	*a0(DRN_JOYDT),a0
	rets

*****************************************************************************

 SUBR	wres_get_stick_val_up

	move	*a0(PLYR_TYPE),a14
	jrnz	szdnot_human
	move	*a0(PLYRNUM),a0
	callr	get_stick_val_up
	rets

szdnot_human
	move	*a0(DRN_JOYUT),a0
	rets

*****************************************************************************
*
* INPUT:	a0 = player number (0-1)
*-----------------------------------------------------------------------------
*
* RETURN:	a0 = button bits
*-----------------------------------------------------------------------------

 SUBR	get_but_val_cur


	PUSH	a1
	move	a0,a1
	sll	4,a1			;x 16 bits
	addi	but_offs2,a1
	move	*a1,a1
	addi	switches_cur,a1
	move	*a1,a1
	andi	011000b,a1

	sll	4,a0			;x 16 bits
	addi	but_offs,a0
	move	*a0,a0
	addi	switches_cur,a0
	move	*a0,a0
	andi	0111b,a0
	or	a1,a0
	PULL	a1

	rets

*****************************************************************************
*
* INPUT:	a0 = player number (0-3)
*-----------------------------------------------------------------------------
*
* RETURN:	a0 = joy switch bits
*-----------------------------------------------------------------------------

  SUBR	get_stick_val_cur


	sll	4,a0			;x 16 bits
	addi	joy_offs,a0
	move	*a0,a0
	addi	switches_cur,a0
	move	*a0,a0
	andi	01111b,a0
	rets

******************************************************************************
*
* INPUT:	a0 = player number (0-3)
*-----------------------------------------------------------------------------
*
* RETURN:	a0 = joy switch bits
*-----------------------------------------------------------------------------

  SUBR	get_stick_val_down

	sll	4,a0			;x 16 bits
	addi	joy_offs,a0
	move	*a0,a0
	addi	switches_down,a0
	move	*a0,a0
	andi	01111b,a0
	rets

******************************************************************************
*
* INPUT:	a0 = player number (0-3)
*-----------------------------------------------------------------------------
*
* RETURN:	a0 = joy switch bits
*-----------------------------------------------------------------------------

  SUBR	get_stick_val_up

	sll	4,a0			;x 16 bits
	addi	joy_offs,a0
	move	*a0,a0
	addi	switches_up,a0
	move	*a0,a0
	andi	01111b,a0
	rets

joy_offs	.word	00h,08h,20h,28h

******************************************************************************
*
* INPUT:	a0 = player number (0-1)
*-----------------------------------------------------------------------------
*
* RETURN:	a0 = button bits
*-----------------------------------------------------------------------------

 SUBR	get_but_val_down

	PUSH	a1
	move	a0,a1
	sll	4,a1			;x 16 bits
	addi	but_offs2,a1
	move	*a1,a1
	addi	switches_down,a1
	move	*a1,a1
	andi	011000b,a1

	sll	4,a0			;x 16 bits
	addi	but_offs,a0
	move	*a0,a0
	addi	switches_down,a0
	move	*a0,a0
	andi	0111b,a0
	or	a1,a0
	PULL	a1

	rets


******************************************************************************
*
* INPUT:	a0 = player number (0-1)
*-----------------------------------------------------------------------------
*
* RETURN:	a0 = button bits
*-----------------------------------------------------------------------------

 SUBR	get_but_val_up

	PUSH	a1
	move	a0,a1
	sll	4,a1			;x 16 bits
	addi	but_offs2,a1
	move	*a1,a1
	addi	switches_up,a1
	move	*a1,a1
	andi	011000b,a1

	sll	4,a0			;x 16 bits
	addi	but_offs,a0
	move	*a0,a0
	addi	switches_up,a0
	move	*a0,a0
	andi	0111b,a0
	or	a1,a0
	PULL	a1

	rets

but_offs	.word	04h,0ch,24h,2ch
but_offs2	.word	20h-3,24h-3

*****************************************************************************
*
* sacrifice clarity for speed
* this reads all switch transitions once
* and stuffs them into the PDATA area


 SUBR	read_switches

;blzwait
;	move	@vcount,a0
;	andi	31,a0
;	jrnz	blzwait
;	TINTON

	movi	process_ptrs,a9
	movk	NUM_WRES,a11
blznext
	move	*a9+,a10,L
	jrz	blzskip

	;ignore all switches if wrestler is immobilized
	move	*a10(IMMOBILIZE_TIME),a14
	jrp	blzimmob

	move	*a10(PLYR_TYPE),a14
	jrz	blzno_drone

blzdrone
	move	*a10(DRN_BUT),*a10(BUT_VAL_CUR)
	move	*a10(DRN_BUTDT),*a10(BUT_VAL_DOWN)
	move	*a10(DRN_BUTUT),*a10(BUT_VAL_UP)

	move	*a10(DRN_JOY),*a10(STICK_VAL_CUR)
	move	*a10(DRN_JOYDT),*a10(STICK_VAL_DOWN)
	move	*a10(DRN_JOYUT),*a10(STICK_VAL_UP)
	jruc	blzcont

blzimmob	clr	a14
	move	a14,*a10(BUT_VAL_CUR)
	move	a14,*a10(BUT_VAL_DOWN)
	move	a14,*a10(BUT_VAL_UP)
	move	a14,*a10(STICK_VAL_CUR)
	move	a14,*a10(STICK_VAL_DOWN)
	move	a14,*a10(STICK_VAL_UP)
	move	a14,*a10(STICK_REL_CUR)
	move	a14,*a10(STICK_REL_NEW)
	jruc	blzskip

blzno_drone
	move	*a10(PLYRNUM),a8

	move	a8,a1
	X16	a1
	move	a1,a0
	addi	joy_offs,a0
	move	*a0,a5		;joy offset

	move	a1,a0
	addi	but_offs,a0
	move	*a0,a6		;switch offset1

	move	a1,a0
	addi	but_offs2,a0
	move	*a0,a7		;switch offset2

;wres_get_but_val_cur

	move	a7,a1		;switch offset2
	addi	switches_cur,a1
	move	*a1,a1
	andi	011000b,a1

	move	a6,a0		;switch offset1
	addi	switches_cur,a0
	move	*a0,a0
	andi	0111b,a0
	or	a1,a0
	move	a0,*a10(BUT_VAL_CUR)


;wres_get_but_val_down

	move	a7,a1		;switch offset2
	addi	switches_down,a1
	move	*a1,a1
	andi	011000b,a1

	move	a6,a0		;switch offset1
	addi	switches_down,a0
	move	*a0,a0
	andi	0111b,a0
	or	a1,a0
	move	a0,*a10(BUT_VAL_DOWN)


;wres_get_but_val_up

	move	a7,a1		;switch offset2
	addi	switches_up,a1
	move	*a1,a1
	andi	011000b,a1

	move	a6,a0		;switch offset1
	addi	switches_up,a0
	move	*a0,a0
	andi	0111b,a0
	or	a1,a0
	move	a0,*a10(BUT_VAL_UP)


;wres_get_stick_val_cur
	move	a5,a0		;joy offset
	addi	switches_cur,a0
	move	*a0,a0
	andi	01111b,a0
	move	a0,*a10(STICK_VAL_CUR)


;wres_get_stick_val_down
	move	a5,a0		;joy offset
	addi	switches_down,a0
	move	*a0,a0
	andi	01111b,a0
	move	a0,*a10(STICK_VAL_DOWN)


;wres_get_stick_val_up
	move	a5,a0		;joy offset
	addi	switches_up,a0
	move	*a0,a0
	andi	01111b,a0
	move	a0,*a10(STICK_VAL_UP)

blzcont
;wres_get_stick_rel_cur
;facing reletive joystick value

	move	*a10(STICK_VAL_CUR),a0
	move	*a10(FACING_DIR),a14
	btst	PLAYER_RIGHT_BIT,a14
	jrnz	blzno_flip
	X16	a0
	addi	blzxflip_table,a0
	move	*a0,a0
blzno_flip
	move	a0,*a10(STICK_REL_CUR)


;wres_get_stick_rel_new
;returns a value only if stick val
;has changed (but not zero)

	move	*a10(STICK_VAL_UP),a0
	move	*a10(STICK_VAL_DOWN),a1
	or	a1,a0
	jrz	blzno_stick
	move	*a10(STICK_VAL_CUR),a0
	move	*a10(FACING_DIR),a14
	btst	PLAYER_RIGHT_BIT,a14
	jrnz	blzno_flip2
	X16	a0
	addi	blzxflip_table,a0
	move	*a0,a0
blzno_flip2
blzno_stick
	move	a0,*a10(STICK_REL_NEW)


blzskip
	dsj	a11,blznext
; TINTOFF

	rets



blzxflip_table	;convert to forward / away  if facing left
	.word	0000b	;0
	.word	0001b	;1
	.word	0010b	;2
	.word	0011b	;3
	.word	1000b	;4
	.word	1001b	;5
	.word	1010b	;6
	.word	1011b	;7
	.word	0100b	;8
	.word	0101b	;9
	.word	0110b	;10
	.word	0111b	;11
	.word	1100b	;12
	.word	1101b	;13
	.word	1110b	;14
	.word	1111b	;15


;*****************************************************************************
;*
;* puts you in mode_blocking if your safe_time is set. (or if you're a drone)
;* called from anim scripts with an ANI_CODE.
;
; SUBR	block_if_safe
;
;	move	*a13(PLYR_TYPE),a14
;	cmpi	PTYPE_DRONE,a14
;	jreq	blzsafe
;
;	move	*a13(SAFE_TIME),a14
;	jrz	blznot_safe
;
;blzsafe	movk	MODE_BLOCK,a14
;	move	a14,*a13(PLYRMODE)
;
;blznot_safe
;	rets

*****************************************************************************
*
* Call at the beginning of any turnbuckle attack.  This sets the NOCONFINE
* bit if any live opponents are outside the ring, or clears it otherwise.
*
* HOWEVER, if everyone is dead, it checks simply for active wrestlers outside,
* not just live ones.
*
* ...except for yoko.  He can't jump out.
*

 SUBR	set_tbukl_confine

	move	*a13(WRESTLERNUM),a14
	cmpi	W_YOKO,a14
	jreq	wbeclear_noconfine

	;a3 is the 'everyone is dead' flag.
	clr	a3
	move	*a13(CLOSEST_NUM),a1
	calla	get_process_ptr
	move	*a0(PLYRMODE),a14
	cmpi	MODE_DEAD,a14
	jrne	wbedfset

	inc	a3		;entire other team is dead.

wbedfset	movi	process_ptrs,a0,L
	movk	NUM_WRES,a10
	move	*a13(PLYR_SIDE),a2
wbeloop
	move	*a0+,a1,L
	jrz	wbenxt		;skip inactive

	cmp	a1,a13
	jreq	wbenxt		;skip self

	move	*a1(PLYR_SIDE),a14
	cmp	a14,a2
	jreq	wbenxt		;skip teammates

	;skip the dead check if everyone on enemy side is dead
	TEST	a3
	jrnz	wbensd

	move	*a1(PLYRMODE),a14
	cmpi	MODE_DEAD,a14
	jreq	wbenxt		;skip dead

wbensd	move	*a1(INRING),a14
	jrnz	wbeset_noconfine

wbenxt	dsj	a10,wbeloop
	;fall through
wbeclear_noconfine

	;he might have drifted out already, so we gotta yank 'em back in.
	move	*a13(INRING),a14
	jrz	wbein

	;rats.  he's out.  fix it.
	clr	a14
	move	a14,*a13(INRING)
	movi	MAT_Y,a14
	move	a14,*a13(GROUND_Y)
	move	*a13(OBJ_ZPOSINT),a14
	cmpi	RING_TOP,a14
	jrge	wbezok
	movi	RING_TOP,a14
	move	a14,*a13(OBJ_ZPOSINT)
wbezok	move	*a13(OBJ_XPOSINT),a2
	cmpi	RING_X_CENTER,a2
	jrgt	wbert

	;on left
	movi	vln_left_rope,a6
	calla	calc_line_x
	jrz	wbexok		;bad news.  leave it alone.
	cmp	a0,a2
	jrge	wbexok
	move	a0,*a13(OBJ_XPOSINT)
	jruc	wbexok

wbert	;on right
	movi	vln_right_rope,a6
	calla	calc_line_x
	jrz	wbexok		;bad news.  leave it alone.
	cmp	a0,a2
	jrle	wbexok
	move	a0,*a13(OBJ_XPOSINT)

wbexok
wbein	move	*a13(ANIMODE),a14
	andni	MODE_NOCONFINE,a14
	jruc	wbecont

wbeset_noconfine
	move	*a13(ANIMODE),a14
	ori	MODE_NOCONFINE,a14
wbecont
	move	a14,*a13(ANIMODE)
	rets


;*****************************************************************************
;*
;* Call with ANI_CODE when a turnbuckle attack misses.  This does four pixels
;* of damage, or health-1, whichever is less.
;
; SUBR	tbukl_miss_damage
;
;	move	*a13(PLYRNUM),a1
;	calla	get_health
;	dec	a0
;	jrle	wbedone
;	movk	4,a14
;	cmp	a14,a0
;	jrle	wbeok
;	move	a14,a0
;wbeok	neg	a0
;	clr	a10
;	calla	adjust_health
;wbedone	rets


	.if DEBUG
*****************************************************************************
	.ref	CPUAVG

 SUBR	draw_dma_meter

	movi	DIAGP,a0
	calla	pal_getf
	move	a0,a1
	ori	00E0E0000H,a1
	movi	[1,400],a2
	move	@dma_bog,a3
	sll	16,a3
	clr	a4
	movi	DMACAL,a5
	calla	QDMAN
	rets

*****************************************************************************

 SUBR	draw_cpu_meter

	movi	DIAGP,a0
	calla	pal_getf
	move	a0,a1
	ori	00D0D0000H,a1
	movi	[1,400],a2
	move	@CPUAVG,a3
	sll	14,a3
	clr	a4
	movi	DMACAL,a5
	calla	QDMAN
	rets

	.endif

*****************************************************************************

 SUBR	COLRPRC
	movi	COLRPID,a0
	calla	KIL1C		;KILL ALL COLOR UPDATE PROCESSES
	clr	a0
	move	a0,@PALFRAM,L
;	movi	scorep,a0	;Score area palette
	jauc	pal_getf


*****************************************************************************
*
* call this at the top of any anim sequence that requires that you be
* attached before you get there, like any of the pile-drivers, vertical
* suplexes, and so forth.  This checks for a good link, and bitches up
* a storm if it doesn't find one.

 SUBR	link_check

	.if DEBUG
	move	*a13(ATTACH_PROC),a14,L
	jrnz	drpok1

	LOCKUP	;I'm not attached!
	nop

drpok1	move	*a14(ATTACH_PROC),a14,L
	jrnz	drpok2
	LOCKUP	;I'm attached, but he's not attached to me!
	nop

drpok2	cmp	a14,a13
	jreq	drpok3
	LOCKUP	;We're both attached, but not to each other!
	nop

	.endif
drpok3	rets

*****************************************************************************
*
* clears CLIMBING_THRU flag and sets SAFE_TIME to 1, which won't do you
* any good unless you're holding block.  Call this at the end of any
* rope climb-through anim.

 SUBR	clr_climb

	clr	a0
	move	a0,*a13(CLIMBING_THRU)		;1=Climbing thru ropes flag

	inc	a0
	move	a0,*a13(SAFE_TIME)

	rets


*****************************************************************************
*
* returns carry set if one of a13's teammates has done a pin this round.
*
* trashes scratch

 SUBR	ck_teammate_pin

	PUSH	a2,a3

	movk	NUM_WRES,a0
	movi	process_ptrs,a1
	move	*a13(PLYR_SIDE),a2

ioelp	move	*a1+,a3,L
	jrz	ioenxt		;skip inactive

	cmp	a3,a13
	jreq	ioenxt		;skip self

	move	*a3(PLYR_SIDE),a14
	cmp	a14,a2
	jrne	ioenxt		;skip enemies

	move	*a3(STATUS_FLAGS),a14
	btst	B_DID_PIN,a14
	jrz	ioenxt		;skip guys who didn't pin

	;got a pinning teammate
	PULL	a2,a3
	setc
	rets

ioenxt	dsj	a0,ioelp

	;no pinning teammates
	PULL	a2,a3
	clrc
	rets

*****************************************************************************
*
* rummage through process_ptrs and decide which pal this wrestler should
* get.  return pal ptr in b0
*
* trashes a0,a1,a2,a3, and a14.

 SUBR	choose_pal

	;assign pals in PLYRNUM order.  There's four in the table for
	; each wrestler.

	.if 1
	; First check to see if there are 2 human players and they are
	; playing the same wrestler
	move	@PSTATUS2,a14		; Get status
	cmpi	3,a14			; Do we have 2 humans playing ?
	jrnz	ejbpp_go			; br = no

	;if buddy mode, choose special pals
	move	@buddy_mode_on,a14
	jrnz	ejbbuddy_mode

	clr	a2
	clr	a14
	neg	a14
	movi	process_ptrs,a0
ejbf_loop
	move	*a0+,a3,L
	jrz	ejbf_done
	move	*a3(PLYRNUM),a4
	jrnz	ejbnot_p1
	move	*a3(WRESTLERNUM),a2
ejbnot_p1
	cmpi	1,a4
	jrnz	ejbnot_p2
	move	*a3(WRESTLERNUM),a14
ejbnot_p2
	jruc	ejbf_loop
ejbf_done
	move	a14,a14			; Does player 2 exist ?
	jrn	ejbpp_go			; br = no
	cmp	a2,a14			; Are player 1 and 2 same wrestler ?
	jrnz	ejbpp_go			; br = no (no need to adjust pals)
	move	@player_pal_pref,a0	; Get player 1 palette preference
	cmpi	7,a0			; Is it last palette ?
	jrnz	ejbset_pal		; br = no
	movk	2,a0			; force a palette above what'll be used by drones
ejbset_pal
	move	a0,@player_pal_pref+10h	; Set player 2 palette
ejbpp_go
	.endif

	;count identical wrestlers with lower PLYRNUMs.
	movi	process_ptrs,a0
	clr	a4			; match count
	move	*a13(PLYRNUM),a2	; Get player number
	cmpi	2,a2			; Are we human ?
	jrge	ejbnot_player		; br = no
	X16	a2			; Get playre palette preference
	addi	player_pal_pref,a2
	move	*a2,a4			; Init the counter to preference
ejbnot_player
	move	*a13(WRESTLERNUM),a1

	;loop from 0 to our PLYRNUM looking for matches, UNLESS we're a
	; drone doink, in which case we just check 0 and 1.
	move	*a13(PLYRNUM),a2
	jrz	ejbend0
	cmpi	2,a2		;first drone is okay too.
	jrle	ejblp0
	cmpi	W_DOINK,a1
	jrne	ejblp0
	movk	2,a2
ejblp0	move	*a0+,a3,L
	jrz	ejbnxt0		;skip inactive
	move	*a3(WRESTLERNUM),a14
	cmp	a1,a14
	jrne	ejbnxt0
	inc	a4		;got a match--inc count
ejbnxt0	dsj	a2,ejblp0
ejbend0	andi	7,a4
	X32	a4
	X256	a1
	add	a1,a4
	addi	ejbwrestler_pal_table,a4
	move	*a4,a14,L	
	move	a14,b0
	rets

ejbbuddy_mode
	move	*a13(WRESTLERNUM),a0
	X64	a0
	move	*a13(PLYR_SIDE),a14
	X32	a14
	add	a14,a0
	addi	ejbbuddy_mode_pals,a0
	move	*a0,a14,L
	move	a14,b0
	rets

ejbwrestler_pal_table
	;                                            pnch     ppnch    kick     pkick
	REFLONG	HRTPNK_P,HRTBLU_P,HRTORG_P,HRTYEL_P,HRTRED_P,HRTGRN_P,HRTPRP_P,HRTGRY_P	;(Bret)
	REFLONG	RZRGRN_P,RZRPRP_P,RZRYEL_P,RZRORG_P,RZRPNK_P,RZRBLU_P,RZRRED_P,RZRGRY_P	;(Razor)
	REFLONG	UNDPRP_P,UNDBLK_P,UNDGRN_P,UNDORG_P,UNDPNK_P,UNDBLU_P,UNDYEL_P,UNDRED_P	;(Taker)
	REFLONG	YOKRED_P,YOKPRP_P,YOKYEL_P,YOKORG_P,YOKPNK_P,YOKBLU_P,YOKGRN_P,YOKGRY_P	;(Yoko)
	REFLONG	SHNRED_P,SHNPRP_P,SHNORG_P,SHNGRN_P,SHNPNK_P,SHNBLU_P,SHNYEL_P,SHNGRY_P	;(Shawn)
	REFLONG	BAMBLU_P,BAMYLW_P,BAMPRP_P,BAMORG_P,BAMPNK_P,BAMRED_P,BAMGRN_P,BAMGRY_P	;(Bam Bam)
	REFLONG	DNKBLU_P,DNKPRP_P,DNKORG_P,DNKRED_P,DNKPNK_P,DNKGRN_P,DNKYEL_P,DNKGRY_P	;(Doink)
	.long	0,0,0,0,0,0,0,0
	REFLONG	LEXWHT_P,LEXPRP_P,LEXRED_P,LEXYEL_P,LEXGRN_P,LEXPNK_P,LEXORG_P,LEXGRY_P	;(Lex)

ejbbuddy_mode_pals
	.long	HRTBLU_P,HRTRED_P
	.long	RZRBLU_P,RZRRED_P
	.long	UNDBLU_P,UNDRED_P
	.long	YOKBLU_P,YOKRED_P
	.long	SHNBLU_P,SHNRED_P
	.long	BAMBLU_P,BAMRED_P
	.long	DNKBLU_P,DNKRED_P
	.long	0,0
	.long	LEXPRP_P,LEXRED_P

*****************************************************************************
* Sets PLYR_TYPE to PTYPE_PLAYER if PLYRNUM < 2.
*
* 0a13H = process *

 SUBR	drone_change_back

	move	*a13(PLYRNUM),a14
	cmpi	2,a14
	jrge	vfndone			;don't check real drones

	;don't bother checking if they're a drone or not.  In either case,
	; turning them human again won't hurt.
	movi	PTYPE_PLAYER,a14
	move	a14,*a13(PLYR_TYPE)
vfndone	rets


*****************************************************************************
* (called by animation system)
*

 SUBR	start_run_flung

	.word	ANI_SETMODE,MODE_UNINT|MODE_NOAUTOFLIP
	.word	ANI_SETFACING		;so the offset works properly
	WL	ANI_CODE,oucx_flip
	.word	ANI_OFFSET,20,0,0
	WL	ANI_CODE,oucok2
	.word	ANI_GETUP,FLUNG_TIME			;Flung time
	.word	ANI_END

 SUBR	start_run_anim

	.word	ANI_SETMODE,MODE_UNINT|MODE_NOAUTOFLIP
;Is this a good idea?
	.word	ANI_DETACH
	WL	ANI_CODE,oucsetup_run
	.word	ANI_END

oucsetup_run
;	move	a13,a0
;	calla	wres_get_stick_val_cur
	PUSH	a1
;	movk	4,a1
	movk	1,a1
	calla	dufus_msg_off
	PULL	a1
	move	*a13(STICK_VAL_CUR),a0
	andi	MOVE_LEFT+MOVE_RIGHT,a0
	jrnz	oucuse_joy1

	move	*a13(FACING_DIR),a0	;use facing
	andi	MOVE_LEFT+MOVE_RIGHT,a0
oucuse_joy1
	move	*a13(FACING_DIR),a1
	andi	MOVE_LEFT+MOVE_RIGHT,a1
	cmp	a0,a1
	jrz	oucok1

;He wants to run in the opposite direction than he is facing
;Rotate him around first.

	move	*a13(FACING_DIR),a1
	andi	MOVE_UP+MOVE_DOWN,a1
	or	a1,a0
	move	a0,*a13(NEW_FACING_DIR)
	move	a0,*a13(FACING_DIR)

;	callr	set_rotate_anim
;	move	a13,a2				;a2 = * process
;	calla	change_anim_anim

oucok1
;	movi	oucdorun,a0			;this routine gets executed
	jruc	oucdorun
	jruc	ouccontx
oucok2
;Whenever you fling someone, a meter can & will appear
	clr	a0
	move	a0,*a13(DELAY_METER)
	movi	oucdorun_flung,a0			;this routine gets executed
ouccontx
	move	a0,*a13(CODE_ADDR),L		;when the rotate anim
	SETMODE	WAITANIM			;finishes

	move	*a13(OBJ_XVEL),a0,L
	sra	1,a0
	move	a0,*a13(OBJ_XVEL),L
	clr	a0
	move	a0,*a13(OBJ_ZVEL),L

	rets

oucx_flip
	move	*a13(FACING_DIR),a14
	xori	00CH,a14
	move	a14,*a13(FACING_DIR)
	rets

oucdorun
	clr	a0
	move	a0,*a13(GETUP_TIME)	;in control

oucdorun_flung
	clr	a0
	move	a0,*a13(USR_VAR1)	;with x-xel
	move	a0,*a13(RUN_TIME)


;Bogosity..
	move	*a13(FACING_DIR),a0	;use facing
;;	move	*a13(NEW_FACING_DIR),a0	;use facing

;	move	*a13(WHOHITME),a14,L
;	move	*a14(FACING_DIR),a0
;	andi	MOVE_LEFT+MOVE_RIGHT,a0
;	xori	0ch,a0

oucok
	move	a0,*a13(MOVE_DIR)

	move	*a13(NEW_FACING_DIR),a1
	andi	MOVE_UP+MOVE_DOWN,a1
	or	a0,a1			;LEFT or RIGHT
	move	a1,*a13(FACING_DIR)	;face same dir as run

	move	*a13(WRESTLERNUM),a0
	X32	a0
	addi	oucrun_anims,a0
	move	*a0,a0,L		;run anim
	calla	change_anim1a

	SETMODE	RUNNING

	movk	1,a0
	move	a0,*a13(DELAY_BUTNS)

	rets

	.ref	bam_run_anim
	.ref	dnk_run_anim
	.ref	hrt_run_anim
	.ref	lex_run_anim
	.ref	rzr_run_anim
	.ref	shn_run_anim
	.ref	und_run_anim
	.ref	yok_run_anim

oucrun_anims
	.long	hrt_run_anim	;0 Bret Hart
	.long	rzr_run_anim	;1 Razor Ramon
	.long	und_run_anim	;2 Undertaker
	.long	yok_run_anim	;3 Yokozuna
	.long	shn_run_anim	;4 Shawn Michaels
	.long	bam_run_anim	;5 Bam Bam
	.long	dnk_run_anim	;6 Doink
	.long	dnk_run_anim	;7 spare
	.long	lex_run_anim	;8 Lex Luger
	.long	dnk_run_anim	;9 Referee


*****************************************************************************

 SUBR	flash_white

	movi	[1111h,0000h],a1	;[color,pal]
	movi	[256,400],a2		;[Ysz,Xsz]
	clr	a3			;[Ypos,Xpos]
	clr	a4			;SAG
	movi	DMACAL,a5		;[offset,ctrl]
	calla	QDMAN
	rets

 SUBR	flash_red

	movi	[1b1bh,0000h],a1	;[color,pal]
	movi	[256,400],a2		;[Ysz,Xsz]
	clr	a3			;[Ypos,Xpos]
	clr	a4			;SAG
	movi	DMACAL,a5		;[offset,ctrl]
	calla	QDMAN
	rets

*****************************************************************************
*
* return carry set if wrestler a0 has any living teammates. (excluding self)
*
* trashes scratch

 SUBR	ck_live_teammates

	PUSH	a2,a3,a4

	move	*a0(PLYR_SIDE),a1
	movi	process_ptrs,a2
	movk	NUM_WRES,a3
rjzlp	move	*a2+,a4,L
	jrz	rjznxt		;skip inactive
	cmp	a4,a0
	jreq	rjznxt		;skip self
	move	*a4(PLYR_SIDE),a14
	cmp	a14,a1
	jrne	rjznxt		;skip other team
	move	*a4(PLYRMODE),a14
	cmpi	MODE_DEAD,a14
	jreq	rjznxt		;skip dead

	;found live teammate.
	PULL	a2,a3,a4
	setc
	rets

rjznxt	dsj	a3,rjzlp
	PULL	a2,a3,a4
	clrc
	rets
	
	

*****************************************************************************
*
* return carry set if wrestler a0 has any teammates, living or dead.
*
* trashes scratch

 SUBR	ck_any_teammates

	PUSH	a2,a3,a4

	move	*a0(PLYR_SIDE),a1
	movi	process_ptrs,a2
	movk	NUM_WRES,a3
najlp	move	*a2+,a4,L
	jrz	najnxt		;skip inactive
	cmp	a4,a0
	jreq	najnxt		;skip self
	move	*a4(PLYR_SIDE),a14
	cmp	a14,a1
	jrne	najnxt		;skip other team

	;found a teammate.
	PULL	a2,a3,a4
	setc
	rets

najnxt	dsj	a3,najlp
	PULL	a2,a3,a4
	clrc
	rets
	
	

*****************************************************************************
*
* set smart_attack bit and set smart_target to *a13(WHOIHIT).
*

 SUBR	target_whoihit

	move	*a13(STATUS_FLAGS),a14
	ori	M_SMART_ATTACK,a14
	move	a14,*a13(STATUS_FLAGS)

	move	*a13(WHOIHIT),*a13(SMART_TARGET),L
	rets

*****************************************************************************
*
* If all of a13's opponents are dead and !zombie, and a13 is either outside
* or all his opponents are outside, setc and rets.  else clrc and rets.

 SUBR	raisearm_check

	;if a13 is human and this is a royal rumble, make sure @FINAL_PTR is
	;FFh.  If it isn't, don't raise arm.
	move	@royal_rumble,a14
	jrz	jfrhack_done
	move	*a13(PLYR_TYPE),a14
	jrnz	jfrhack_done		;PLAYER=0
	move	@FINAL_PTR,a14,L
	move	*a14,a14
	jrn	jfrhack_done
	jruc	jfrclrc			;no good
jfrhack_done

	move	*a13(PLYR_SIDE),a0

	movk	NUM_WRES,a1
	movi	process_ptrs,a2
	clr	a4		;'is any opponent inside' flag.

jfrlp	move	*a2+,a3,L
	jrz	jfrnxt		;skip inactive

	move	*a3(PLYR_SIDE),a14
	cmp	a14,a0
	jreq	jfrnxt		;skip a13 and teammates

	move	*a3(PLYRMODE),a14
	cmpi	MODE_DEAD,a14
	jrne	jfrclrc		;opp dead?

	move	*a3(STATUS_FLAGS),a14,L
	btst	B_ZOMBIE,a14
	jrnz	jfrclrc		;zombie?

	move	*a3(INRING),a3
	jrnz	jfrnxt

	;dead !zombie bad guy is inside.  set a4
	inc	a4
jfrnxt	dsj	a1,jfrlp

	;okay, all our opponents are dead and staying that way.  now check
	; the inside/outside stuff.
	move	*a13(INRING),a14
	jrnz	jfrsetc		;am I outside?

	TEST	a4
	jrnz	jfrclrc		;is any opponent inside?

jfrsetc	setc
	rets

jfrclrc	clrc
	rets

*****************************************************************************
*
* Set WHOIHIT to closest opponent.  Call this after you do a LEAPAT in your
* pin.  Since pins don't actually attack, we need to do this so that WHOIHIT
* is correct when we call grnd_hit.  We can't use CLOSEST in grnd_hit, since
* it's possible to land closer to someone else than the guy you meant to pin.
* ONLY USE THIS IN PINS!!!!!!!!!!!!!! Cuz it also sets the PINNED bit.
*

 SUBR	hit_nearest

	;set WHOIHIT and victim WHOPINNEDME
	move	*a13(CLOSEST_NUM),a0
	X32	a0
	addi	process_ptrs,a0
	move	*a0,a0,L
	move	a0,*a13(WHOIHIT),L
	move	a13,*a0(WHOPINNEDME),L

	;set victim's PINNED bit.
	move	*a0(STATUS_FLAGS),a14
	ori	M_PINNED,a14
	move	a14,*a0(STATUS_FLAGS)

	rets

*****************************************************************************
*
* Change into another wrestler and re-enter the battle.  This should probably
* only be used in the king of the ring match.
*
* 0a13H = pointer to process to change
*

 SUBR	change_wrestler

****	;change wrestlernum
	move	*a13(NEW_WRESTLERNUM),*a13(WRESTLERNUM)

****	;make the new special move processes
	callr	init_smoves

****	;change palette
	calla	choose_pal
	move	b0,a0
	calla	pal_getf

	move	a0,*a13(OBJ_PAL)
	move	a0,*a13(MY_PAL)
	movk	MAX_PIECES-1,a9
	move	*a13(OBJ_BASE),a1,L
	addk	20h,a1			;skip shadow
cdvNXT	move	*a1+,a8,L
	move	a0,*a8(OPAL)
	dsj	a9,cdvNXT

****	;re-initialize animation
	movi	MODE_NORMAL,a14
	move	a14,*a13(PLYRMODE)
	move	*a13(WRESTLERNUM),a9
	X64	a9
	addi	cdvinit_anims,a9
	move	*a9+,a0,L
	calla	change_anim1a
	move	*a9,a0,L
	calla	change_anim2a

****	;reset STATUS_FLAGS
	clr	a14
	move	a14,*a13(STATUS_FLAGS),L

****	;reset life and combo data
	calla	init_wres_life_data

****	;clear I_WILL_DIE
	clr	a14
	move	a14,*a13(I_WILL_DIE)

****	;set new position
	movi	cdvinit_positions,a0
cdvlp1	move	*a0(cdvNXT),a14,W
	jrn	cdvusea0		;if last entry, use by default.

	;use current entry if:
	; X <= WORLDTLX-30 or
	; X >= WORLDTLX+400+30

	move	*a0(cdvXPOS),a1
	move	@WORLDTLX,a14,L
	sra	16,a14
	subk	30,a14
	cmp	a14,a1
	jrle	cdvusea0
	addi	460,a14
	cmp	a14,a1
	jrge	cdvusea0


cdvnxt1	addi	cdvSIZE,a0
	jruc	cdvlp1

cdvusea0	move	*a0(cdvXPOS),*a13(OBJ_XPOSINT)
	move	*a0(cdvZPOS),*a13(OBJ_ZPOSINT)
	move	*a0(cdvYPOS),*a13(OBJ_YPOSINT)
	move	*a0(cdvYPOS),*a13(GROUND_Y)
	move	*a0(cdvINRING),*a13(INRING)

****	;clear old velocities
	clr	a14
	move	a14,*a13(OBJ_XVEL),L
	move	a14,*a13(OBJ_YVEL),L
	move	a14,*a13(OBJ_ZVEL),L

	rets


cdvinit_anims
	REFLONG	hrt_stand4_anim,hrt_torso4_anim
	REFLONG	rzr_stand4_anim,rzr_torso4_anim
	REFLONG	und_stand4_anim,und_torso4_anim
	REFLONG	yok_stand4_anim,yok_torso4_anim
	REFLONG	shn_stand4_anim,shn_torso4_anim
	REFLONG	bam_stand4_anim,bam_torso4_anim
	REFLONG	dnk_stand4_anim,dnk_torso4_anim
	.long	0,0
	REFLONG	lex_stand4_anim,lex_torso4_anim


	;possible starting positions.  hunt until you find one that's
	; offscreen, then use it.  If none of them are offscreen (should
	; never happen,) use the last entry in the table.

	STRUCT	0
	WORD	cdvXPOS
	WORD	cdvZPOS
	WORD	cdvYPOS
	WORD	cdvINRING
	LABEL	cdvSIZE
	WORD	cdvNXT	;first element of NEXT entry. check for -1.

	;XPOSINT, ZPOSINT, YPOSINT/GROUND_Y, INRING
cdvinit_positions
	.word	RING_X_CENTER,RING_Z_CENTER,MAT_Y,0	;center
	.word	RING_TOP_LEFT,RING_Z_CENTER,MAT_Y,0	;center left
	.word	RING_TOP_RIGHT,RING_Z_CENTER,MAT_Y,0	;center right
	.word	RING_BOT_LEFT,RING_BOT,MAT_Y,0		;bottom left
	.word	RING_BOT_RIGHT,RING_BOT,MAT_Y,0		;bottom right
	.word	024Fh,060Eh,0,1				;outside left
	.word	060Eh,04ABh,0,1				;outside right
	.word	-1

*****************************************************************************
*
* Kill all my special move processes.
*

 SUBR	kill_smove_procs

	PUSH	a2,a3

	;loop through the processes. Anything with a PID of SMOVE_PID, and
	; a PA8 that matches our a13 must go.
	move	@ACTIVE,a3,L
ilxlp0	move	a3,a2		;a2 = p->this
	jrz	ilxdone0
	move	*a2,a3,L	;a3 = p->next
	move	*a2(PROCID),a14
	cmpi	SMOVE_PID,a14
	jrne	ilxlp0
	move	*a2(PA8),a14,L
	cmp	a14,a13
	jrne	ilxlp0

	;match.  kill this one
	move	a2,a0
	calla	KILL
	jruc	ilxlp0

ilxdone0	PULL	a2,a3
	rets

*****************************************************************************
*
* Check to make sure your opponent is at rest and staying that way.  Check
* to see if he's in the xxx_dead_anim.  And make sure he's in range.
* Oh, and make sure there aren't any zombies either.
*

 SUBR	can_pin

	;no pin if there are any zombies or live wrestler on other team
	movi	process_ptrs,a0
	movk	NUM_WRES,a1
	move	*a13(PLYR_SIDE),a3
herlp0	move	*a0+,a2,L
	jrz	hernxt0			;skip inactive
	move	*a2(PLYR_SIDE),a14
	cmp	a14,a3
	jreq	hernxt0			;skip teammates
	move	*a2(PLYRMODE),a14
	cmpi	MODE_DEAD,a14
	jrne	herclrc
	move	*a2(STATUS_FLAGS),a14
	btst	B_ZOMBIE,a14
	jrnz	herclrc
hernxt0	dsjs	a1,herlp0

	;check range
	move	*a13(CLOSEST_DIST),a0
	cmpi	70h,a0
	jrgt	herclrc
	move	*a13(CLOSEST_ZDIST),a0
	cmpi	50h,a0
	jrgt	herclrc

	calla	get_opp_process

	move	*a0(STATUS_FLAGS),a14
	btst	B_PINABLE,a14
	jrz	herclrc

hersetc	;just to be safe, set the PINNED bit on the guy
	move	*a0(STATUS_FLAGS),a14
	ori	M_PINNED,a14
	move	a14,*a0(STATUS_FLAGS)

	;and set his WHOPINNEDME
	move	a13,*a0(WHOPINNEDME),L

	;and zero his velocities
	clr	a14
	move	a14,*a0(OBJ_XVEL),L
	move	a14,*a0(OBJ_YVEL),L
	move	a14,*a0(OBJ_ZVEL),L

	;and set his PTIME to one and clear his KOD bit, 'cuz he's probably
	; been KO'd if he's a drone.
	movk	1,a14
	move	a14,*a0(PTIME)
	move	*a0(STATUS_FLAGS),a14
	andni	M_KOD,a14
	move	a14,*a0(STATUS_FLAGS)

	setc
	rets

herclrc	clrc
	rets

*****************************************************************************
*
* Dead wrestlers sit here.

 SUBR	xxx_dead_anim

	.word	ANI_SETMODE,MODE_NOAUTOFLIP|MODE_UNINT
	.word	ANI_SETPLYRMODE,MODE_DEAD

	WL	ANI_CODE,zckset_pinable_bit

	WL	ANI_CODE,zckko_if_drone

	.word	ANI_ROT		;just sit and do nothing



*****
* KO my process if I'm a drone.

 SUBRP	zckko_if_drone

	;don't go to sleep if this is an 8-on-1 or 8-on-2 match, UNLESS
	; wrestler_count is 0, which means there's no hope of becoming
	; a zombie.
	move	@royal_rumble,a14
	jrnz	zckis8
	calla	is_8_on_1
	jrnc	zcknot8
zckis8	move	@wrestler_count,a14
	jrnz	zckrets
zcknot8

	move	*a13(PLYR_TYPE),a14
	cmpi	PTYPE_DRONE,a14
	jrne	zckrets

	;don't KO if I've been pinned
	move	*a13(STATUS_FLAGS),a14
	btst	B_PINNED,a14
	jrnz	zckrets

	;don't KO if our NO_KO bit is set.
	btst	B_NO_KO,a14
	jrnz	zckrets

	ori	M_KOD,a14
	move	a14,*a13(STATUS_FLAGS)

zckrets	rets

*****
* set the PINABLE bit in STATUS_FLAGS

 SUBRP	zckset_pinable_bit

	move	*a13(STATUS_FLAGS),a14
	ori	M_PINABLE,a14
	move	a14,*a13(STATUS_FLAGS)
	rets

*****************************************************************************
*
* This gets called once each MATCH for every wrestler, not each round.
* It creates the set of 'watchdog' processes that look out for special
* moves that the usual method can't handle; specifically, stuff that
* involves charging up with a stick, detailed control over timing, or
* proximity to the bad guy.
*

 SUBR	init_smoves

	move	*a13(WRESTLERNUM),a2,W
	X32	a2
	addi	gmyspecial_moves,a2
	move	*a2,a2,L
	jrz	gmydone

gmyloop
	move	*a2+,a7,L
	jrz	gmydone
	movi	SMOVE_PID,a1
	move	a13,a8
	calla	GETPRC_INSERT

	;store reset address
	move	*a0(PWAKE),*a0(SM_RESET_ADDRESS),L
	jruc	gmyloop

gmydone
	rets


gmyspecial_moves
	REFLONG	hrt_smove_table		;Bret
	REFLONG	rzr_smove_table		;Razor
	REFLONG	und_smove_table		;Taker
	REFLONG	yok_smove_table		;Yoko
	REFLONG	shn_smove_table		;Shawn
	REFLONG	bam_smove_table		;Bam Bam
	REFLONG	dnk_smove_table		;Doink
	.long	0			;spare
	REFLONG	lex_smove_table		;Lex

*****************************************************************************

	.bss	kulpin_timeout,16		;pin idiot check cntdown
	.bss	kullast_dead,16		;PCNT last time we had a one-team
					; dead condition.	

 SUBR	match_timer

	movk	9,a0
	move	a0,@match_time		;10's
	move	a0,@match_time+10h	;1's
	clr	a0
	move	a0,@match_time+20h	;fractional

	callr	kulcreate_timer

	SLEEP	TSEC*2

	movk	ADJSPEED,a0		;game timer speed (1-5)
	calla	GET_ADJ
	BADCHK	a0,1,5,3		;reg,lo,hi,val
	X16	a0			;x 16 bits
	addi	timer_table-10h,a0
	move	*a0,a1

	;slow the clock to 1/3 speed if this is the royal rumble
	move	@royal_rumble,a14
	jrnz	kulisrum

	;slow the clock (2/3 speed) if it's 1v3.
	move	@PSTATUS2,a14
	jrz	kulnfin
	cmpi	3,a14
	jreq	kulnfin

	move	@NUM_OPPS,a14
	cmpi	3,a14
	jrne	kulnfin

kulisrum	movi	0AAAAH,a14
	mpyu	a14,a1
	srl	16,a1

	;slow it yet again (down to 1/3 speed) if this is the final battle,
	calla	is_final_match
	jrc	kulisfin
	move	@royal_rumble,a14
	jrz	kulnfin
kulisfin	sra	1,a1

kulnfin	move	a1,a10

	;initialize kullast_dead
	clr	a14
	move	a14,@kullast_dead

	;initialize kulpin_timeout - we need to do this because one time in
	; 2^16, when we hit our first all-dead condition, PCNT will be 1,
	; and the code will think that this isn't a new condition and it
	; won't reset this value.  Hey, it could happen.
	movi	4*TSEC,a14
	move	a14,@kulpin_timeout

kulloop
	SLEEPK	1

	move	@HALT,a0
	jrnz	kulloop

	move	@match_time,a0,L
	jrz	kulloop

	;call kuldec_timer and update_timer only if there's a live member
	; of every team. (for this purpose, zombies count as live members)

	callr	get_live_bits
	move	a0,a3

	cmpi	3,a3
	jrne	kul1tmded		;a team is completely dead

	callr	kuldec_timer
	callr	update_timer

	jruc	kulloop

kul1tmded	;one team is completely dead - wait five seconds, and if there's
	; no pin by then, award the round to the team that's sitting on
	; it's silly drone ass instead of pinning.

	;check kullast_dead to see if this is a new all-dead condition or
	; an old one.  if it's a new one, we need to reset kulpin_timeout.
	move	@PCNT,a14
	move	@kullast_dead,a0
	sub	a0,a14
	dec	a14
	jrz	kulold

	;new dead condition.  reset kulpin_timeout.
	;temp! - 314
	.if DEBUG
	DBEVENT	BDE_ALL_DEAD,a13,L,a13,L,a13,L
	.endif

	movi	5*TSEC,a14
	move	a14,@kulpin_timeout

	;clear reduce_bog.  if we're in 8-on-1 or 8-on-2 mode, clear this
	; only if the human team is dead, or the drones are dead and no
	; more are coming.
	move	@royal_rumble,a14
	jrnz	kulck8_2
	calla	is_8_on_1
	jrnc	kulcrb

kulck8_1	;check the 8-on-1 case
	move	@PSTATUS2,a14
	and	a3,a14		;a3 is bit of live team
	jrz	kulcrb		;on z, human team is dead
	jruc	kuldtd		;else dead team is drones

kulck8_2	;check the 8-on-2 case
	btst	0,a3		;team 0 is always humans in 8 on 2
	jrz	kulcrb		;on z, human team is dead

kuldtd	;dead team is drones
	move	@wrestler_count,a14
	cmpi	1,a14
	jrge	kulncrb

kulcrb	clr	a14
	move	a14,@reduce_bog

	;wake the crowd
	move	@crowd_process,a0,L
	movk	1,a14
	move	a14,*a0(PTIME)


kulncrb	;create the PIN HIM message process.
	move	a3,a9
	xori	3,a9
	srl	1,a9		;a8 is dead team (0 or 1)
	CREATE	PINHIM_ANIM_PID,pin_prompt

kulold	;update kullast_dead
	move	@PCNT,a14
	move	a14,@kullast_dead

	;dec pin_timeout and call the round if time's up.
	move	@kulpin_timeout,a14
	jrz	kulloop			;we've already called this round
	dec	a14
	jrz	kulend			;time's up - do it.
	move	a14,@kulpin_timeout
	jruc	kulloop

kulend
	CREATE	ANNC_PID,announce_rnd_winner
	.if DEBUG
	move	a13,*a0(PDATA),L	;kulCREATOR (pdata)
	movi	$,a14
	move	a14,*a0(PDATA+20h),L	;kulORIGIN
	.endif

	;stuff a 0 in kulpin_timeout so we'll know that there's no further
	; action to be taken on this all-dead condition.
	clr	a14
	move	a14,@kulpin_timeout
	jruc	kulloop


********************

kulcreate_timer

	;set pal
	movi	WGFS_W_P,b0
	calla	is_8_on_1
	jrnc	kulnfin2
	movi	WGSF_Y_P,b0

kulnfin2	movi	[186,0],a0			;x pos
	movi	[21,0],a1			;y pos
	movi	WGSF20_9,a2
	movi	200,a3			;z pos
	movi	DMAWNZ|M_3D|M_SCRNREL,a4	;DMA flags
	movi	TYPTIMERDIGIT,a5
	clr	a6				;x vel
	clr	a7				;y vel
	PUSH	b0
	calla	BEGINOBJP
	PULL	b0
	move	a8,*a13(PDATA+20h),L		;10's image pointer

	movi	[200+2,0],a0			;x pos
	movi	[21,0],a1			;y pos
	movi	WGSF20_9,a2
	calla	BEGINOBJP
	move	a8,*a13(PDATA),L		;1's image pointer

	rets

********************

kuldec_timer
	move	@match_time,a0,L
	cmpi	090009h,a0
	jrne	kulno_reset_pal
	movi	WGFS_W_P,a0
	calla	is_8_on_1
	jrnc	kulnfin3
	movi	WGSF_Y_P,a0

kulnfin3	calla	pal_getf
	move	*a13(PDATA+20h),a8,L	;10's image pointer
	move	a0,*a8(OPAL)
	move	*a13(PDATA),a8,L	;10's image pointer
	move	a0,*a8(OPAL)

kulno_reset_pal

	move	@match_time+20h,a0	;fractional
	sub	a10,a0

	move	a0,@match_time+20h
	jrnc	kulno_change

	move	@match_time+10h,a0	;1's
	dec	a0
	move	a0,@match_time+10h
	jrnc	kulno_borrow

	movk	9,a0
	move	a0,@match_time+10h

	move	@match_time,a0		;10's
	dec	a0
	move	a0,@match_time

	cmpi	0,a0

	jrne	kulno_borrow
	movi	WGSF_R_P,a0
	calla	pal_getf
	move	*a13(PDATA+20h),a8,L	;10's image pointer
	move	a0,*a8(OPAL)
	move	*a13(PDATA),a8,L	;10's image pointer
	move	a0,*a8(OPAL)

kulno_borrow
	;if time is less than 15, make noise
	move	@match_time,a0,L
	move	a0,a1
	sra	16,a0
	andi	0Fh,a1
	sla	4,a1
	or	a1,a0
	cmpi	10h,a0
	jrgt	kulno_change
	movk	10,a0			;Time warning sound
	calla	triple_sound

kulno_change
	rets

timer_table
	.asg	1500,BASETM	;2100	;16

	.word	BASETM-BASETM*30/100	;1 (slowest)	;76.6 seconds/round
	.word	BASETM-BASETM*15/100	;2 (slower)
	.word	BASETM			;3 (default)	;53.6 seconds/round
	.word	BASETM+BASETM*15/100	;4 (faster)
	.word	BASETM+BASETM*30/100	;5 (fastest)	;41.2 seconds/round


********************

 SUBR	update_timer

	move	@match_time,a0		;10's
	.if DEBUG
	cmpi	10,a0
	jrlt	kulok1

	;clock digit out of range!
	LOCKUP
kulok1
	.endif

	X32	a0
	addi	digit_tbl,a0
	move	*a0,a0,L		;* image
	move	*a13(PDATA+20h),a8,L	;10's image pointer
	move	*a8(OCTRL),a1		;DMA flags
	calla	change_image

	move	@match_time+10h,a0	;1's
	.if DEBUG
	cmpi	10,a0
	jrlt	kulok2

	;clock digit out of range!
	LOCKUP
	.endif
kulok2

	X32	a0
	addi	digit_tbl,a0
	move	*a0,a0,L		;* image
	move	*a13(PDATA),a8,L	;1's image pointer
	move	*a8(OCTRL),a1		;DMA flags
	calla	change_image

	rets

**********************************************
*
*

 SUBR	wrestler_counter

	movk	8,a9			; Initial wrestler count
	move	a9,@wrestler_count	; Initialize the count

;Turn on remaining word
	movi	[126h,0],a0
	clr	a11
	move	@PSTATUS2,a14
	cmpi	3,a14
	jrz	wbvno_adj
	btst	1,a14
	jrz	wbvno_adj
	movi	[11ah,0],a11
wbvno_adj
	sub	a11,a0
	movi	[32h,0],a1
	movi	remaining,a2
name_z		equ	9
	movi	name_z,a3		;Z
	movi	DMAWNZ|M_SCRNREL,a4	;DMA flags
	movi	TYPWCCOUNT,a5		;Delete the last string
	clr	a6
	clr	a7
	movi	WSF_Y_P,b0
	calla	BEGINOBJP
	move	a8,a10

	movi	[17eh,0],a0
	sub	a11,a0
	movi	[32h,0],a1
	movi	WSF10_8,a2
	movi	name_z,a3		;Z
	movi	DMAWNZ|M_SCRNREL,a4	;DMA flags
	movi	TYPWCCOUNT,a5		;Delete the last string
	clr	a6
	clr	a7
	movi	WSF_Y_P,b0
	calla	BEGINOBJP

wbvwc_loop
	SLEEP	07fffh			; Sleep until woken up

	move	@wrestler_count,a14	; Get current count
	jrz	wbvwc_exit		; Is it 0 ? - br = yes
	cmp	a9,a14			; Has it changed from last time ?
	jrz	wbvwc_loop
	move	a14,a9			; Save for reprint

	move	@wrestler_count,a0	; Get current count
	X32	a0
	addi	wbvdigit10_tbl,a0
	move	*a0,a0,L		;* image
	move	*a8(OCTRL),a1		;DMA flags
	calla	change_image
	
	jruc	wbvwc_loop		; Go redo it

wbvwc_exit
	clr	a0
	move	a0,@wrestler_count_proc,L

	calla	DELOBJA8
	move	a10,a8
	jauc	DELOBJDIE


wbvdigit10_tbl
	.long	WSF10_0
	.long	WSF10_1
	.long	WSF10_2
	.long	WSF10_3
	.long	WSF10_4
	.long	WSF10_5
	.long	WSF10_6
	.long	WSF10_7
	.long	WSF10_8
	.long	WSF10_9


digit_tbl
	.long	WGSF20_0,WGSF20_1,WGSF20_2,WGSF20_3,WGSF20_4
	.long	WGSF20_5,WGSF20_6,WGSF20_7,WGSF20_8,WGSF20_9

*****************************************************************************

 SUBR	maybe_do_flashes
nnptop	SLEEPK	5
	move	@reduce_bog,a1
	jrnz	nnpdie
	MOVE	@WORLDTLY,A0,L
	CMPI	[0ff97H,0],A0
	JRGT	nnptop
	CALLA	START_HI_FLASHES
	SLEEPK	30
	JRUC	nnptop
nnpdie	DIE

*****************************************************************************
*
* sets our DID_RAISEARM bit.

 SUBR	set_raisearm_bit

	move	*a13(STATUS_FLAGS),a14,L
	ori	M_DID_RAISEARM,a14
	move	a14,*a13(STATUS_FLAGS),L

	rets


*****************************************************************************
*
* check our DID_RAISEARM bit--set MODE_STATUS bit if it's clear (ANI_CODE)

 SUBR	check_raisearm_bit

	move	*a13(STATUS_FLAGS),a14,L
	btst	B_DID_RAISEARM,a14
	jrz	uqdset

uqdclr	move	*a13(ANIMODE),a14
	andni	MODE_STATUS2,a14
	move	a14,*a13(ANIMODE)
	rets

uqdset	move	*a13(ANIMODE),a14
	ori	MODE_STATUS2,a14
	move	a14,*a13(ANIMODE)
	rets


*****************************************************************************
*
* choose buddies for buddy mode.  return the wrestlernums in a0 and a1.

 SUBR	choose_buddies

	;prepare an exclusion mask
	clr	a7
	movk	1,a0
	move	@index1,a14
	sll	a14,a0
	or	a0,a7

	movk	1,a0
	move	@index2,a14
	sll	a14,a0
	or	a0,a7

	;count excluded wrestlers
	move	a7,a14
	clr	a8
	movk	8,a0
ugzlp1	srl	1,a14
	jrnc	ugznxt1
	inc	a8
ugznxt1	dsj	a0,ugzlp1

	;get the first one
	calla	get_rnd_wrestler
	PUSH	a0		;store first WRESTLERNUM

	;now exclude him and get another one.
	inc	a8		;inc exclusion count
	movk	1,a14
	sll	a0,a14
	or	a14,a7
	calla	get_rnd_wrestler
	PULL	a1		;retrieve first WRESTLERNUM

	rets

*****************************************************************************
*
* Return carry set if wrestler *a14 is behind wrestler *a13, clear otherwise.
*
* trashes a14 (isn't allowed to trash a0 or a1!)

 SUBR	is_a14_behind

	PUSH	a1

	move	*a14(OBJ_XPOSINT),a1
	move	*a13(OBJ_XPOSINT),a14
	sub	a1,a14
	jrn	egzonrt

egzonlt	;opponent on my left
	move	*a13(FACING_DIR),a14
	btst	MOVE_LEFT_BIT,a14
	jrz	egzbehind
;	jruc	egzahead

egzahead	PULL	a1
	clrc
	rets

egzonrt	;opponent on my right
	move	*a13(FACING_DIR),a14
	btst	MOVE_RIGHT_BIT,a14
	jrnz	egzahead
;	jruc	egzbehind

egzbehind	PULL	a1
	setc
	rets

*****************************************************************************
*
* Call this when a match has just ended.  Does an appropriate sound if
* someone's winning streak has just ended.

 SUBR	loser_snd

	move	@PSTATUS2,a14
	cmpi	3,a14
	jrne	onfrets

	move	@match_winner,a1
	NOT	A1
	ANDI	3,A1
	DEC	A1
	X16	A1

	ADDI	p1oldwinstreak,A1
	MOVE	*A1,A1
	jrz	onfrets
	MOVK	2,A0
	CALLA	RNDRNG0
	SLL	4,A0
	ADDI	onfspeech,A0
	MOVE	*A0,A0
	CALLA	ADD_VOICE
onfrets	rets

onfspeech	;.word	CONGRATULATIONS
	.word	SOMEHOW_I_DONT_THINK
;	.word	L_CONGRATS
	.word	L_BACK_TO_SANDBOX
	.word	ARE_YOU_TOUGH_ENOUGH

;	.WORD	L_SIGN_YOUR_NAME
;	.WORD	THIS_IS_FOR_ALL
;	.WORD	SIGN_HERE_PLEASE


*****************************************************************************
*

 SUBR	postgame_audits

	;battle over accounting.

	;compute match_realtime
	move	@match_start_time,a14,L
	move	@PCNT,a1,L
	sub	a14,a1
	movi	55,a14
	divu	a14,a1
	move	a1,@match_realtime

	;skip all this crap after a royal_rumble
	move	@royal_rumble,a14
	jrnz	gearets

	;increment AUD_VSHUMF or AUD_VSCPUF (and AUD_CPUWIN)
	movi	AUD_VSHUMF,a0
	move	@PSTATUS2,a14
	cmpi	03h,a14
	jreq	geavshum
	movi	AUD_VSCPUF,a0
geavshum	calla	AUD1

	;add to AUD_2PBTIME, AUD_CPUWINTIME, or AUD_CPULOSETIME
	move	@PSTATUS2,a14
	cmpi	03h,a14
	jreq	gea2pbtime

	move	@match_winner,a0
	and	a0,a14
	jrnz	geacpulosetime
	jruc	geacpuwintime

gea2pbtime
	movi	AUD_2PBTIME,a0
	jruc	geaaddtime

geacpuwintime
	MOVE	@PSTARTS,A0
	JRZ	NO_UPDATE_ANYTHING

	MOVI	AUD_CREDLEN,A0
	MOVE	@THIS_GAME_TIME,A1
	CALLA	AUD
	MOVI	AUD_CREDLENNUM,A0
	CALLA	AUD1
	CLR	A0
	MOVE	A0,@THIS_GAME_TIME
	MOVE	A0,@PSTARTS

NO_UPDATE_ANYTHING
	movi	AUD_CPUWIN,a0
	calla	AUD1
	movi	AUD_CPUWINTIME,a0
	jruc	geaaddtime
geacpulosetime
	movi	AUD_CPULOSETIME,a0
	jruc	geaaddtime

geaaddtime
	move	@match_realtime,a1
	calla	AUD

	;update record speeds
	move	@PSTATUS2,a14
	cmpi	03h,a14
	jreq	geafast_2p

	move	@match_winner,a0
	and	a0,a14
	jrnz	geafast_cpulose
	jruc	geafast_cpuwin

geafast_2p
	movi	AUD_FASTHDH,a0
	calla	GET_AUD
	jrz	geano_prior_hdh
	move	@match_realtime,a2
	cmp	a1,a2
	jrge	gearecordspeed_done
geano_prior_hdh
	movi	AUD_FASTHDH,a0
	move	@match_realtime,a1
	calla	STORE_AUDIT
	jruc	gearecordspeed_done

geafast_cpulose
	movi	AUD_FASTHDC,a0
	calla	GET_AUD
	jrz	geano_prior_hdc
	move	@match_realtime,a2
	cmp	a1,a2
	jrge	gearecordspeed_done
geano_prior_hdc
	movi	AUD_FASTHDC,a0
	move	@match_realtime,a1
	calla	STORE_AUDIT
	jruc	gearecordspeed_done

geafast_cpuwin
	movi	AUD_FASTCDH,a0
	calla	GET_AUD
	jrz	geano_prior_cdh
	move	@match_realtime,a2
	cmp	a1,a2
	jrge	gearecordspeed_done
geano_prior_cdh
	movi	AUD_FASTCDH,a0
	move	@match_realtime,a1
	calla	STORE_AUDIT

gearecordspeed_done
;No speedy victories in 3 rnd matches!
	move	@current_round,a0
	cmpi	3,a0
	jrz	gearets


	;increment the proper wrestler use thingies

	MOVE	@PSTATUS2,A0
	CMPI	3,A0
	JREQ	gea2pmatch

	;it's a one-player match.
	move	@index1,a2
	CLR	A1
	SRL	1,A0
	JRC	AUDIT_THE_HUMAN
	move	@index2,a2
	MOVK	1,A1

AUDIT_THE_HUMAN
	CALLR	geaaudit_wrestler

	move	@NUM_OPPS,a14
	cmpi	1,a14
	jrne	gearets		;don't audit 1-vs-many matches

	;audit the computer
	move	@CURRENT_LADDER,a0,L
	move	*a0,a2,L
	sll	24,a2
	srl	24,a2		;CPU wrestlernum in a2

	;convert 7 to 8.
	cmpi	7,a2
	jrne	geavok0
	inc	a2
geavok0

	move	@PSTATUS2,a1
	xori	3,a1
	srl	1,a1		;CPU side in a3 (!PSTATUS >> 1)

	callr	geaaudit_wrestler

	rets
	

;human vs. human match
gea2pmatch
	;player 1
	move	@index1,a2
	CLR	A1
	CALLR	geaaudit_wrestler

	;player 2
	move	@index2,a2
	MOVK	1,A1
	CALLR	geaaudit_wrestler

gearets	RETS

******************
* a2 = WRESTLERNUM
* a1 = PLYR_SIDE

 SUBRP	geaaudit_wrestler

	TEST	a2
	jrnn	geaok
	.if DEBUG
	LOCKUP
	.endif
	rets
geaok
	X64	a2			;x 4 words
	addi	wrestler_audits,a2

	move	@PSTATUS2,a0
	btst	A1,a0
	jrnz	geap1hum
	addi	20h,a2			;skip 2 words
geap1hum
	move	*a2+,a0,W		;increment uses
	calla	AUD1

	move	@match_winner,a0
	btst	A1,a0
	jrz	geap1_audited
	move	*a2+,a0,W		;increment wins
	calla	AUD1

geap1_audited
	RETS


****************************************************************************
*
* Returns bits of teams with live members in a0.
*

 SUBR	get_live_bits

	PUSH	a1,a2,a3

	movk	NUM_WRES,a0
	movi	process_ptrs,a1
	clr	a3

xfclp1	move	*a1+,a2,L
	jrz	xfcnxt1		;skip inactive

	move	*a2(PLYRMODE),a14
	cmpi	MODE_DEAD,a14
	jrne	xfclive

	move	*a2(STATUS_FLAGS),a14
	btst	B_ZOMBIE,a14
	jrz	xfcnxt1		;skip dead &! zombie

xfclive	;live wrestler.  flag his team
	move	*a2(PLYR_SIDE),a14
	jrnz	xfct2

	;member of team 1
	ori	01h,a3	
	jruc	xfcnxt1

xfct2	;member of team 2
	ori	02h,a3

xfcnxt1	dsj	a0,xfclp1
	move	a3,a0
	PULL	a1,a2,a3

	rets

*****************************************************************************
*
* Returns carry set if any of a13's live opponents are outside the ring.
* Trashes a0, a1, a14
*

 SUBRP	any_opp_outside

	PUSH	a3

	movi	process_ptrs,a0
	movi	NUM_WRES,a1
	move	*a13(PLYR_SIDE),a2
lgylp0	move	*a0+,a3,L
	jrz	lgynxt0			;skip inactive
	move	*a3(PLYR_SIDE),a14
	cmp	a14,a2
	jreq	lgynxt0			;skip teammates
	move	*a3(PLYRMODE),a14
	cmpi	MODE_DEAD,a14
	jreq	lgynxt0			;skip dead guys
	move	*a3(INRING),a14
	jrnz	lgysetc			;is outside?
lgynxt0	dsj	a1,lgylp0

	PULL	a3
	clrc
	rets

lgysetc	PULL	a3
	setc
	rets

*****************************************************************************
*
* Sets a13's PLYRMODE to INAIR2 if his nearest opponent is dead, INAIR
* otherwise.
*

 SUBR	set_tbukl_airmode

	calla	get_opp_plyrmode
	cmpi	MODE_DEAD,a0
	jreq	sqgdead
	movi	MODE_INAIR2,a0
	jruc	sqggo

sqgdead	movi	MODE_INAIR,a0
sqggo	move	a0,*a13(PLYRMODE)
	rets
	
*****************************************************************************
*
* set MODE_STATUS bit if switches are AWAY & PUNCH.

 SUBR	free_toss_check

	move	*a13(ANIMODE),a0
	ori	MODE_STATUS2,a0

	move	*a13(CLOSEST_NUM),a14
	X32	a14
	addi	process_ptrs,a14
	move	*a14,a14,L

	move	*a14(OBJ_ZPOS),a14,L
	move	*a13(OBJ_ZPOS),a1,L
	sub	a1,a14
	abs	a14
	srl	16,a14
	cmpi	15,a14
	jrlt	mqsset


;	move	*a13(STICK_REL_CUR),a14
;	btst	MOVE_AWAY_BIT,a14
;	jrz	mqsclr

	move	*a13(BUT_VAL_CUR),a14
	cmpi	PLAYER_BLOCK_VAL,a14
	jreq	mqsset
;mqsclr
	andni	MODE_STATUS2,a0
mqsset
	move	a0,*a13(ANIMODE)
	rets

*****************************************************************************
*
* We're gonna do a free hiptoss.  Do all the neccesary setup here.  Set our
* PLYRMODE to normal, IMMOBILIZE the bad guy, clear velocities, etc.

 SUBR	setup_freetoss

	;mode normal
	SETMODE	NORMAL

	;immobilize bad guy
	move	*a13(WHOIHIT),a0,L
	movk	20,a14
	move	a14,*a0(IMMOBILIZE_TIME)

	;smart-target bad guy
	SMRTTGT	a13,WHOIHIT

	rets

******************************************************************************

	.end

