	.file	"mproc.asm"
	.title	"GSP multi-processing system"
	.width	132
	.option	b,d,l,t
	.mnolist


	.include	"gsp.equ"
	.include	"sys.equ"
	.include	"mproc.equ"
	.include	"display.equ"
	.include	"macros.h"



	.ref	dirqtimer
	.ref	L_TIMER



	.bss	PRCSTR	,NPROC*PRCSIZ	;Process data blocks


	.bss	SPRCSTR	,SNPROC*SPRCSIZ	;Super-process data blocks

	.sect	"FIXED"
ACTIVE	.long	0
FREE	.long	0
SFREE	.long	0


	.text



 SUBR	process_init

	movi	ACTIVE,a13	;Init A13
	clr	a0
	move	a0,*a13,L	;Empty list

	movi	PRCSTR,a1
	move	a1,@FREE,L	;Full free list

	movi	NPROC,b0	;# of processes
cfiulp	move	a1,a14
	addi	PRCSIZ,a1
	move	a1,*a14,L	;Set link
	dsj	b0,cfiulp

	move	a0,*a14,L	;Null last link

	;initialize the super-proc list
	movi	SPRCSTR,a1
	move	a1,@SFREE,L

	movi	SNPROC,b0	;# of processes
cfiuslp	move	a1,a14
	addi	SPRCSIZ,a1
	move	a1,*a14,L	;Set link
	dsj	b0,cfiuslp

	move	a0,*a14,L	;Null last link

	rets



 SUBR	process_dispatch

 .if	0

	movi	31*32,a0		;Proc usage
	move	a0,@ERASELOC

uhiydmawt	move	b13,b13
	jrge	uhiydmawt
	movk	6,a0			;DMA usage
	move	a0,@ERASELOC
uhiynoline
 .endif

 .if DEBUG
	.ref	slowmotion
	move	@slowmotion,a0
uhiysmlp	move	@dirqtimer,a1
	cmp	a1,a0
	jrge	uhiysmlp
 .endif

	movi	ACTIVE,a13		;*Proc list
	clr	a0
	move	a0,@dirqtimer		;Tell DIRQ to flip and draw

uhiylp


	movi	OBJLST,a0
	movk	1,a1			;Lowest Z
	sll	31,a1			;Make 080000000H
	clr	a8
	jruc	yzlp

	.align
yz0
	move	*a2(OZPOS),a6		;Get Z
	move	*a2(OYPOS),a7		;Get Y

	cmp	a1,a6
	jrgt	priok			;Next Z > Current Z?
	jrlt	priswap

	cmp	a5,a7
	jrge	priok			;Next Y > Current Y?

priswap	dint				;>Make current after next
	movk	1,a8
	move	a2,*a4,L		;Point last to next
	move	*a2,*a0,L		;Point current to block after next
	move	a0,*a2,L		;Point next to current
	movk	1,a8
	eint
	move	a2,a4
	jruc	yzlp			;Continue sort of current obj

priok	move	a0,a4			;A4=*Last obj
	move	a2,a0			;A0=*Current obj
	move	a6,a1			;A1=Current Z
	move	a7,a5			;A5=Current Y

yzlp	move	*a0,a2,L		;A2=*Next obj
	jrnz	yz0

	move	a8,a8
	jrnz	uhiylp

uhiylp2
	move	@dirqtimer,a0
	jrz	uhiylp2			;Wait?

	calla	L_TIMER			;Linky timer (FIX so BOG time is OK!)

	jruc	prcd1


PRCSLP
	PULL	a7			;Get *Wakeup

	.if DEBUG
	cmpi	0FF800000H,a7
	jrhs	uhiypsok
	LOCKUP	;bad wake address!
uhiypsok
	.endif

PRCLSP	move	a13,a1
	addi	PDATA,a1
	mmtm	a1,a7,a8,a9,a10,a11,a12 ;*Wakeup, regs, *stack
	move	a0,-*a1			;sleep

	.if	DEBUG
	move	a13,a0
	cmpi	SPRCSTR,a13		;is it a superproc?
	jrge	uhiysuper_stkchk

	addi	PSDATA,a0
	cmp	a0,a12
	jrlt	$			;stick on stack overflow
	addi	PRCSIZ-PSDATA,a0
	cmp	a0,a12
	jrgt	$			;stick on stack underflow
	jruc	prcd1

uhiysuper_stkchk
	addi	SPSDATA,a0
	cmp	a0,a12
	jrlt	$			;stick on stack overflow
	addi	SPRCSIZ-SPSDATA,a0
	cmp	a0,a12
	jrgt	$			;stick on stack underflow
	jruc	prcd1
	.endif

prcd1

	move	*a13,a13,L
	jrz	prcdx			;End?
	move	*a13(PTIME),a0		;Get count
	subk	1,a0
	move	a0,*a13(PTIME)		;Put it back
	jrgt	prcd1			;Not ready?


	move	a13,a1			;0DHispatch
	addi	040H,a1
	mmfm	a1,a7,a8,a9,a10,a11,a12	;*Wake, regs, *stack

uhiygo
	.if DEBUG
	cmpi	0FF800000H,a7
	jrhs	uhiywake_ok
	LOCKUP	;bad wake address!
uhiywake_ok
	.endif
	jump	a7			;Do process

prcdx
	rets


SUCIDE
	movi	ACTIVE,a1
suclp	move	a1,a2		;save previous
	move	*a1,a1,L
	jrz	sucerr

	cmp	a1,a13
	jrne	suclp		;!Us

	move	*a1,*a2,L	;Unlink

	cmpi	SPRCSTR,a1
	jrge	uhiysuclink_sproc

	move	@FREE,*a1+,L	;Link into free list at start
	subk	32,a1
	move	a1,@FREE,L

	move	a2,a13		;Set current process to previous
	jruc	prcd1		;Continue with dispatch

uhiysuclink_sproc
	move	@SFREE,*a1+,L	;Link into super-proc free list at start
	subk	32,a1
	move	a1,@SFREE,L
	move	a2,a13		;Continue with dispatch
	jruc	prcd1

sucerr
	.if	DEBUG
	LOCKUP
	eint
	.else
	CALLERR	5,0
	.endif
	movi	ACTIVE,a13	;*Proc list
	jruc	prcd1



KILL
	cmp	a0,a13
	jreq	hgnbx		;Killing self?

	movi	ACTIVE,a1

hgnblp	move	a1,a14		;Save previous
	move	*a1,a1,L
	jrz	killerr		;Can't find?
	cmp	a1,a0
	jrne	hgnblp		;Not the one?

	move	*a0,*a14,L	;Unlink from active

	cmpi	SPRCSTR,a0
	jrge	hgnbkill_super
	move	@FREE,*a0+,L	;Link into free list at start
	subk	32,a0
	move	a0,@FREE,L
	jruc	hgnbx

hgnbkill_super
	move	@SFREE,*a0+,L	;Link into free list at start
	subk	32,a0
	move	a0,@SFREE,L
	jruc	hgnbx

hgnbx	rets

killerr
	.if	DEBUG
	LOCKUP
	eint
	.else
	CALLERR	6,0
	.endif
	jruc	hgnbx



GETPRC
	move	a12,b0

	move	@FREE,a0,L
	jrz	nonelft		;No more?
	move	*a0,a14,L
	move	a14,@FREE,L	;Unlink from free list
	move	*a13,*a0,L	;Link into active list after current process
	move	a0,*a13,L
	jruc	xferprc0

nonelft
	.if	DEBUG
	LOCKUP
	eint
	.else
	CALLERR	4,2
	.endif
	jruc	getpx


GETPRC_INSERT
	move	a12,b0

	move	@FREE,a0,L
	jrz	nonelft		;No more?
	move	*a0,a14,L
	move	a14,@FREE,L	;Unlink from free list


	;find the process that's immediately before the parent.
	PUSH	a1,a2
	movi	ACTIVE,a1
	move	*a1,a2,L
hgnbsearch
	cmp	a13,a2
	jreq	hgnbfound
	move	a2,a1
	move	*a1,a2,L
	jrnz	hgnbsearch

	;We've been called by a nonexistent process.  How odd.
	.if DEBUG
	LOCKUP
	.endif
	PULL	a1,a2
	jruc	getpx

hgnbfound
	;a2 is parent proc, a1 is before that.  slip in between.
	move	a0,*a1,L
	move	a2,*a0,L
	PULL	a1,a2
	jruc	xferprc0
	
	
	


 SUBR	GETSPRC
	move	a12,b0

	move	@SFREE,a0,L
	jrz	nonelft		;No more?
	move	*a0,a14,L
	move	a14,@SFREE,L	;Unlink from free list
	move	*a13,*a0,L	;Link into active list after current process
	move	a0,*a13,L
	jruc	xferprc0



XFERPROC
	move	a12,b0
xferprc0
	cmpi	ROM,a7
	jrlo	procwakeerr		;Error?

	move	a0,a14
	addi	PDATA,a14
	move	a0,a12			;Reset process stack pointer
	addi	SPRCSIZ,a12
	cmpi	SPRCSTR,a0
	jrge	hgnbsuperproc

	addi	PRCSIZ-SPRCSIZ,a12
hgnbsuperproc
	mmtm	a14,a7,a8,a9,a10,a11,a12 ;Stuff wake, regs, p stack ptr
	movk	1,a12
	move	a12,-*a14		;Wakeup next time
	move	a1,-*a14		;ID

getpx	move	b0,a12
	rets				;Flags are trashed!!!

procwakeerr
	.if	DEBUG
	LOCKUP
	eint
	.else
	CALLERR	7,0
	.endif
	jruc	getpx



KILALL
	not	a1
	jruc	KILALLN



KIL1C
	clr	a1


KILALLN
	move	a2,b0
	move	a3,b1

	zext	a1		;Won't kill PIDS 08000H+
	andn	a1,a0		;Form match
	movi	ACTIVE,a2

fyjmlp	move	a2,a3		;Save previous
	move	*a2,a2,L
	jrz	fyjmx		;Done?
	move	*a2(PROCID),a14
	JRN	fyjmlp		;ALLOW INDESTRUCTABLES (ANYTHING 8000h+)

	andn	a1,a14		;Apply mask
	cmp	a0,a14
	jrne	fyjmlp		;No match?

	cmp	a2,a13
	jreq	fyjmlp		;Current proecess?

	move	*a2,*a3,L	;Unlink
	cmpi	SPRCSTR,a2
	jrge	fyjmspr
	move	@FREE,a14,L	;Link into free list at start
	move	a14,*a2,L
	move	a2,@FREE,L
	move	a3,a2
	jruc	fyjmlp

fyjmspr
	move	@SFREE,a14,L	;Link into super-proc free list at start
	move	a14,*a2,L
	move	a2,@SFREE,L
	move	a3,a2
	jruc	fyjmlp

fyjmx	move	b0,a2
	move	b1,a3
	rets



 SUBR	IKIL1C
	clr	a1



 SUBR	IKILALLN
	move	a2,b0
	move	a3,b1

	sext	a0
	andn	a1,a0		;Form match
	movi	ACTIVE,a2

nulllp	move	a2,a3		;Save previous
	move	*a2,a2,L
	jrz	nullx		;Done?
	move	*a2(PROCID),a14

	andn	a1,a14		;Apply mask
	cmp	a0,a14
	jrne	nulllp		;No match?

	cmp	a2,a13
	jreq	nulllp		;Current proecess?

	move	*a2,*a3,L	;Unlink
	cmpi	SPRCSTR,a2
	jrge	nullspr
	move	@FREE,a14,L	;Link into free list at start
	move	a14,*a2,L
	move	a2,@FREE,L
	move	a3,a2
	jruc	nulllp

nullspr
	move	@SFREE,a14,L	;Link into super-proc free list at start
	move	a14,*a2,L
	move	a2,@SFREE,L
	move	a3,a2
	jruc	nulllp

nullx	move	b0,a2
	move	b1,a3
	rets





process_exist
	movi	ACTIVE,a1

uvislp	move	*a1,a1,L
	jrz	uvisx		;End?
	cmp	a0,a1
	jrne	uvislp		;!Match?
	move	a0,a0		;Clr Z

uvisx	rets



EXISTP
	PUSH	a1,a2,a4

	sext	a0
	and	a1,a0		;form match
	movi	ACTIVE,a2

sibmlp	move	*a2,a2,L
	jrz	sibmx		;End?
	move	*a2(PROCID),a4
	and	a1,a4
	cmp	a0,a4
	jrne	sibmlp		;!Match?

	cmp	a2,a13
	jreq	sibmlp		;Self?

sibmx	move	a2,a0

	PULL	a1,a2,a4
	rets


	.end

