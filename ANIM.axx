**************************************************************
*
* Software:		Jamie Rivett
* Initiated:		6/93
*
* COPYRIGHT (C) 1992 WILLIAMS ELECTRONICS GAMES, INC.
*
**************************************************************

	.file	"anim.asm"
	.title	"animation routines"
	.width	132
	.option	b,d,l,t
	.mnolist


	.include	"macros.h"
	.include	"mproc.equ"		;Mproc equates
	.include	"display.equ"		;Display proc equates
	.include	"gsp.equ"		;Gsp asm equates
	.include	"sys.equ"
	.include	"game.equ"
	.include	"plyr.equ"
	.include	"anim.equ"
	.include	"audit.equ"
	.include	"ring.equ"
	.include	"sound.h"
	.include	"jjxm.h"
	.INCLUDE	"SOUND.EQU"

	.include	"fontsimg.glo"
	.include	"bgndtbl.glo"
	.include	"miscimg.glo"

******************************************************************************
*
* external references

	.ref	p2rounds,p1rounds,xxx_dead_anim,is_final_match,FINAL_PTR
	.ref	get_opp_process
	.ref	PSTATUS2,round_award
	.ref	PCNT,slowmo,do_roll,match_over,triple_sound,is_8_on_1
	.ref	match_winner,process_ptrs,square_root,set_target_offsets
	.ref	calc_line_x,RNDPER,wrtable_sound,rope_command,no_debris
	.ref	set_rope_z,SHAKER2,get_all_buttons_down,right_rproc
	.ref	left_rproc,adjust_health,create_dizzy_proc,get_mpart_offsets
	.ref	get_mpart_xsize,pal_find,round_tickcount,tgt_ground
	.ref	get_rope_x,allow_offscrn,ADD_TO_COMBO_COUNT,MOVE_NAME_ANNC
	.ref	reduce_bog,RNDRNG0,hyper_speed_on,royal_rumble
	.ref	kill_smove_procs,clear_lifebar
	.ref	wrestler_count,wrestler_count_proc

	.REF	IF_SILENT_ADD_VOICE

******************************************************************************
*
* external definitions

*****************************************************************************

OANIMODE	equ	0			;word
OANIBASE	equ	OANIMODE+10h		;long
OANIPC		equ	OANIBASE+20h		;long
OANICNT		equ	OANIPC+20h		;word
OCUR_FRAME	equ	OANICNT+10h		;long


 SUBR	animate_wrestler

	PUSH	a4,a10

	.ref	match_time
	move	@match_time,a0,L
	jrz	flcx

;	callr	animate_wrestler1
;	callr	animate_wrestler2

	move	a13,a10
	addi	ANIMODE,a10		;primary animation
	callr	animate

	move	a13,a10
	addi	ANIMODE2,a10		;secondary animation
	callr	animate

flcx
	PULL	a4,a10
	rets


 SUBR	animate_wrestler1

	PUSH	a4,a10

	move	a13,a10
	addi	ANIMODE,a10		;primary animation
	callr	animate

	PULL	a4,a10
	rets

 SUBR	animate_wrestler2

	PUSH	a4,a10

	move	a13,a10
	addi	ANIMODE2,a10		;secondary animation
	callr	animate

	PULL	a4,a10
	rets

********
animate	;a10 = * anim variables base

	move	*a10(OANIMODE),a0	;current animation ended???
	btst	MODE_END_BIT,a0
	jrnz	_exit

 .if 0
*** temp patch to step through images on player 1 !!!!

	move	*a13(PLYRNUM),a0
	jrnz	flcskippit

	move	*a10(OANIBASE),a0,L
	move	*a10(OANIPC),a1,L
	cmp	a0,a1
	jreq	_next_command

	move	*a13(BUT_VAL_DOWN),a0
	move	a0,a0
	jrnz	_next_command
	rets
flcskippit
 .endif

***


	move	*a10(OANICNT),a0	;cur tick count
	dec	a0
	move	a0,*a10(OANICNT)
	jrgt	_exit

_next_command
	move	*a10(OANIPC),a4,L
_next_command1
	move	*a4+,a0			;tick count or command
	jrn	flccommand
	jrz	_ani_zip		;no-op

	move	*a13(ANI_SPEED),a1
	mpyu	a0,a1
	srl	8,a1
	move	@hyper_speed_on,a14
	srl	a14,a1
	.if DEBUG
	move	a1,a1
	jrge	flcnot_z
	LOCKUP
flcnot_z
	.endif
	move	a1,*a10(OANICNT)	;# ticks to hold cur frame

;	move	a0,a1
;	sll	8,a1			;* 256
;	move	*a13(ANI_SPEED),a0	;divisor * 256
;	divu	a0,a1			;a1/a0
;	move	a1,*a10(OANICNT)	;# ticks to hold cur frame

	move	*a4+,a0,L		;* * multi image object

	.if DEBUG
	cmpi	0ff800000H,a0
	jrhs	flcimg_ok
	LOCKUP	;bogus image pointer
flcimg_ok
	.endif

	move	*a0,a0,L		;* image
 .if DEBUG
 	jrnz	flcok
	LOCKUP
	jruc	flcskp
flcok
 .endif
	move	a0,*a10(OCUR_FRAME),L
flcskp
	move	a4,*a10(OANIPC),L

_exit
	rets


flccommand
;	andi	0ffh,a0
;	sll	5,a0			;x 32
	sll	24,a0
	srl	19,a0
	addi	flcani_commands,a0

	.if DEBUG
	cmpi	flcani_commands_end,a0
	jrlt	flccmd_ok
	LOCKUP	;bogus ani command
flccmd_ok
	.endif

	move	*a0,a0,L
	jump	a0

flcani_commands
	.long	_ani_zip		;0
	.long	_ani_repeat		;1
	.long	_ani_setmode		;2
	.long	_ani_zerovels		;3
	.long	_ani_setplyrmode	;4
	.long	_ani_set_yvel		;5
	.long	_ani_attack_on		;6
	.long	_ani_attack_off		;7
	.long	_ani_leapatopp		;8
	.long	_ani_attach		;9
	.long	_ani_detach		;10
	.long	_ani_waithitgnd		;11
	.long	_ani_xflip		;12
	.long	_ani_bounce		;13
	.long	_ani_attack_on_Z	;14
	.long	_ani_gravity_on		;15
	.long	_ani_gravity_off	;16
	.long	_ani_goto		;17
	.long	_ani_attachz		;18
	.long	_ani_slowmo		;19
	.long	_ani_waitrelease	;20
	.long	_ani_offset		;21
	.long	_ani_friction		;22
	.long	_ani_min_yvel		;23
	.long	_ani_attachvel		;24
	.long	_ani_throw1		;25
	.long	_ani_sound		;26
	.long	_ani_setfacing		;27
	.long	_ani_pause		;28
	.long	_ani_ifstatus		;29
	.long	_ani_code		;30
	.long	_ani_shaker		;31
	.long	_ani_changeanim		;32
	.long	_ani_faceup		;33
	.long	_ani_facedown		;34
	.long	_ani_bouncerope		;35
	.long	_ani_shakeropes		;36
	.long	_ani_bendrope		;37
	.long	_ani_setspeed		;38
	.long	_ani_leapatpos		;39
	.long	_ani_zero_xzvels	;40
	.long	_ani_rope_z		;41
	.long	_ani_loop		;42
	.long	_ani_zip		;43
	.long	_ani_set_xvel		;44
	.long	_ani_ifnotstatus	;45
	.long	_ani_slide_back		;46
	.long	_ani_clr_damage		;47
	.long	_ani_set_zvel		;48
	.long	_ani_checkword		;49
	.long	_ani_face		;50
	.long	_ani_setword		;51
	.long	_ani_getup		;52
	.long	_ani_getup_wait		;53
	.long	_ani_clr_stars		;54
	.long	_ani_shakeall		;55
	.long	_ani_damage		;56
	.long	_ani_start_dizzy	;57
	.long	_ani_clr_status		;58
	.long	_ani_set_target		;59
	.long	_ani_max_x		;60
	.long	_ani_max_z		;61
	.long	_ani_max_y_vel		;62
	.long	_ani_superslave		;63
	.long	_ani_slaveanim		;64
	.long	_ani_rawsound		;65
	.long	_ani_damageopp		;66
	.long	_ani_rndper		;67
	.long	_ani_waithitopp		;68
	.long	_ani_attchimage		;69
	.long	_ani_ifoppmode		;99
	.long	_ani_ifbuttons		;71
	.long	_ani_ifnohitblock	;72
	.long	_ani_end		;73
	.long	_ani_ifrope		;74
	.long	_ani_ifnotrope		;75
	.long	_ani_opp_getup		;76
	.long	_ani_shakecorner	;77
	.long	_ani_singlestep		;78
	.long	_ani_superslave2	;79
	.long	_ani_setoppmode		;80
	.long	_ani_clroppmode		;81
	.long	_ani_oppoffset		;82
	.long	_ani_ifblocked		;83
	.long	_ani_waitroll		;84
	.long	_ani_setoppfacing	;85
	.long	_ani_ifopp		;86
	.long	_ani_snot		;87

	.long	_ani_if_butcount_ge	;88
	.long	_ani_if_butcount_lt	;89
	.long	_ani_if_rptcount	;90
	.long	_ani_ifnot_rptcount	;91

	.long	_ani_ringcheck		;92
	.long	_ani_debrisat		;93
	.long	_ani_debris		;94
	.long	_ani_set_wrestler_xflip ;95
	.long	_ani_slideatopp		;96

	.long	_ani_clr_butcount	;97
	.long	_ani_set_rptcount	;98
	.long	_ani_dec_rptcount	;99

	.long	_ani_shadowtrail	;100
	.long	_ani_createproc		;101
	.long	_ani_target		;102
	.long	_ani_hmbwait		;103
	.long	_ani_safe_time		;104
	.long	_ani_setopp_plyrmode	;105
	.long	_ani_xflip_opp		;106
	.long	_ani_setlong		;107
	.long	_ani_immobilize		;108
	.long	_ani_xflip_tbl		;109
	.long	_ani_setoppvels		;110
	.long	_ani_waithitgnd2	;111
	.long	_ani_set_opp_xvel	;112
	.long	_ani_set_attach		;113
	.long	_ani_inc_combo_count	;114
	.long	_ani_clear_combo_count	;115
	.long	_ani_add_move		;116
	.long	_ani_startattack	;117
	.long	_ani_changeanim_tbl	;118
	.long	_ani_if_rptcount_ge	;119
	.long	_ani_if_rptcount_lt	;120
	.long	_ani_waithitany		;121
	.long 	_ani_draw_name		;122
	.long	_ani_set_idiot		;123
	.long	_ani_attchimage2 	;124
	.long	_ani_ground		;125
	.long	_ani_rot		;126
	.long	_ani_scroll_ctrl	;127
	.long	_ani_clear_climb	;128
	.long	_ani_opp_face		;129
	.long	_ani_setflag		;130
flcani_commands_end

********
_ani_zip	;0

	.if DEBUG
	LOCKUP
	.endif

	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1

********
_ani_repeat	;1
	move	*a10(OANIBASE),a4,L
	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1

********
_ani_setmode	;2
	move	*a4+,a0			;mode bits
	move	a0,*a10(OANIMODE)
	move	a4,*a10(OANIPC),L

	;clear some STATUS_FLAGS bits too.
	move	*a13(STATUS_FLAGS),a14,L
	andni	SF_CLEAR_BITS,a14
	move	a14,*a13(STATUS_FLAGS),L

	;if *a13(PTIME) is nonzero, this anim was called by someone other
	; than our actual wrestler process.  So clearing the KOD bit isn't
	; enough, since we're still sleeping.  Set PTIME to 1.
	move	*a13(PTIME),a14
	jrz	_next_command
	movk	1,a14
	move	a14,*a13(PTIME)
	jruc	_next_command

********
_ani_zerovels	;3
	clr	a0
	move	a0,*a13(OBJ_XVEL),L
	move	a0,*a13(OBJ_YVEL),L
	move	a0,*a13(OBJ_ZVEL),L
	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1

********
_ani_setplyrmode ;4

	;clear the climbin bit, just in case...
	clr	a14
	move	a14,*a13(CLIMBING_THRU)

	move	*a4+,a0
	move	*a13(PLYRMODE),a1		;this is a temp fudge!!!
	cmpi	MODE_DEAD,a1
	jreq	bibnoset

;If going into head hold mode, don't allow getup meter
;to come out for awhile.
	cmpi	MODE_HEADHOLD,a0
	jrnz	bibskp
	move	*a13(DELAY_METER),a14
	cmpi	6*60,a14
	jrge	bibskp
	movi	9*60,a14
	move	a14,*a13(DELAY_METER)
bibskp

	move	a0,*a13(PLYRMODE)
bibnoset
	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1

********
_ani_set_yvel	;5
	move	*a4+,a0,L
	move	a0,*a13(OBJ_YVEL),L
	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1

********
_ani_attack_on	;6

;I'm not sure we want to zero attach_proc just for starting an attack!
;Watch this....
	clr	a0				;start out not attached
;	move	a0,*a13(ATTACH_PROC),L		;to anything

	move	a0,*a13(HITBLOCKER)

;The start of each attack on will clear MODE_STATUS!

	move	*a13(ANIMODE),a0
	andni	MODE_STATUS2,a0
	move	a0,*a13(ANIMODE)

	move	*a13(ANIMODE),a0
	ori	MODE_CHECKHIT,a0
	move	a0,*a13(ANIMODE)

	move	*a4+,a0
	move	a0,*a13(ATTACK_MODE)
;	move	*a4+,a0
;	move	a0,*a13(OBJ_ATTXOFF)
;	move	*a4+,a0
;	move	a0,*a13(OBJ_ATTYOFF)
;	move	*a4+,a0
;	move	a0,*a13(OBJ_ATTWIDTH)
;	move	*a4+,a0
;	move	a0,*a13(OBJ_ATTHEIGHT)

	move	*a4+,a0,L
	move	a0,*a13(OBJ_ATTXOFF),L
	move	*a4+,a0,L
	move	a0,*a13(OBJ_ATTWIDTH),L

;;;	clr	a0
;;;	move	a0,*a13(OBJ_ATTZOFF)
;;;	move	a0,*a13(OBJ_ATTDEPTH)

	movi	-40,a0				;default z width (10)
	move	a0,*a13(OBJ_ATTZOFF)
	movi	40*2,a0				;10*2
	move	a0,*a13(OBJ_ATTDEPTH)

	move	a4,*a10(OANIPC),L

;	jruc	_next_command
	jruc	_next_command1

********
_ani_attack_off	;7

	;clear CHECKHIT and WAITHITOPP bits
	move	*a13(ANIMODE),a0
	andni	MODE_CHECKHIT|MODE_WAITHITOPP,a0
	move	a0,*a13(ANIMODE)

	;clear SMART_ATTACK bit and SMART_TARGET value
	move	*a13(STATUS_FLAGS),a14
	andni	M_SMART_ATTACK,a14
	move	a14,*a13(STATUS_FLAGS)

	clr	a14
	move	a14,*a13(SMART_TARGET),L

	;update ATTACK_TIME
	move	@round_tickcount,a0
	move	a0,*a13(ATTACK_TIME)

	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1

********
_ani_leapatopp	;8

;	# ticks to reach dest
;	max total distance (X and Z)
;	max X distance
;	max Z distance
;	max Y vel
;	target area of opponent
;	x,y,z offset of attack box

	STRUCT	0
	WORD	qwzTICKS
	WORD	qwzMAX_TOTAL_DIST
	WORD	qwzMAX_X_DIST
	WORD	qwzMAX_Z_DIST
	LONG	qwzMAX_Y_VEL
	WORD	qwzTRGT
	WORD	qwzATT_X_OFF
	WORD	qwzATT_Y_OFF
	WORD	qwzATT_Z_OFF
	LABEL	qwzSIZE


	.bss	oppx,32
	.bss	oppz,32
	.bss	oppy,32


	move	a4,a14
	addi	qwzSIZE,a14
	move	a14,*a10(OANIPC),L

	move	*a13(CLOSEST_NUM),a11
	X32	a11
	addi	process_ptrs,a11
	move	*a11,a11,L

	move	*a11(OBJ_XVEL),a5,L

	move	*a11(PLYRMODE),a14
	cmpi	MODE_RUNNING,a14
	jrne	qwzoutring

	move	a0,a0
	jrnz	qwzoutring

;if opponent is inside the ring, running and near the ropes
;then target where he is now (don't add in xvel)

	move	*a11(OBJ_XPOSINT),a1

	move	a5,a5		;xvel
	jrp	qwzrun_right
;run_left
	cmpi	RING_X_CENTER,a1
	jrgt	qwzoutring
	jruc	qwzcnt

qwzrun_right
	cmpi	RING_X_CENTER,a1
	jrlt	qwzoutring
qwzcnt

	PUSH	a13
	move	a11,a13
	calla	get_rope_x
	PULL	a13
	move	*a11(OBJ_XPOSINT),a1
	sub	a1,a0
	abs	a0
	cmpi	70,a0
	jrgt	qwzoutring

	clr	a5		;clr xvel
qwzoutring

	move	*a11(OBJ_ZVEL),a6,L
	move	*a11(OBJ_YVEL),a7,L
	move	*a11(GROUND_Y),a8
	sll	16,a8
	addi	[256,0],a8

	move	*a11(OBJ_XPOS),a1,L
	move	*a11(OBJ_ZPOS),a2,L
	move	*a11(OBJ_YPOS),a3,L
	addi	[256,0],a3


	move	*a4(qwzTICKS),a0

	move	*a13(OBJ_GRAVITY),a14,L
qwzlp0
	add	a5,a1			;x + xvel
	add	a6,a2			;z + zvel

	move	a7,a7
	jrz	qwzok

	add	a7,a3			;y + yvel
	sub	a14,a7		;yvel - gravity
	cmp	a3,a8		;hit ground?
	jrgt	qwzok
	move	a8,a3
	jruc	qwzdn
qwzok
	dsj	a0,qwzlp0
qwzdn
	subi	[256,0],a3

	move	a1,@oppx,L
	move	a2,@oppz,L
	move	a3,@oppy,L


	move	*a4(qwzTRGT),a0
	jrn	qwzuser
	btst	B_TGT_GROUND,a0
	jrz	qwzngrnd
	andni	TGT_GROUND,a0
	calla	set_target_offsets
	calla	tgt_ground
	jruc	qwzuser
qwzngrnd
	calla	set_target_offsets
qwzuser

	move	*a13(TGT_XOFF),a0	;target x offset
	sll	16,a0
	move	*a11(OBJ_CONTROL),a14
	btst	B_FLIPH,a14
	jrz	qwzright1
	neg	a0
qwzright1
;;;	move	*a11(OBJ_XPOS),a1,L
	move	@oppx,a1,L
	add	a0,a1			;def target x

	move	*a4(qwzATT_X_OFF),a0
	sll	16,a0
	move	*a13(OBJ_CONTROL),a14
	btst	B_FLIPH,a14
	jrz	qwzright0
	neg	a0
qwzright0
	move	*a13(OBJ_XPOS),a2,L
	add	a0,a2			;att x

	sub	a2,a1			;def x - att x
	move	a1,a14
	abs	a14

	move	*a4(qwzMAX_X_DIST),a0
	jrn	qwzxok
	sll	16,a0
	cmp	a14,a0
	jrge	qwzxok

	move	a1,a1
	jrp	qwzno_negx
	neg	a0
qwzno_negx
	move	a0,a1
qwzxok
	move	a1,a5			;delta x
	move	*a4(qwzTICKS),a0
	divs	a0,a1			;a1 / a0
	move	a1,*a13(OBJ_XVEL),L



	move	*a13(TGT_ZOFF),a0	;target z offset
	sll	16,a0
;;;	move	*a11(OBJ_ZPOS),a1,L
	move	@oppz,a1,L
	add	a0,a1			;def target z

	move	*a13(OBJ_ZPOS),a2,L
	move	*a4(qwzATT_Z_OFF),a0
	sll	16,a0
	add	a0,a2			;att z

	sub	a2,a1			;def z - att z
	move	a1,a14
	abs	a14

	move	*a4(qwzMAX_Z_DIST),a0
	jrn	qwzzok
	sll	16,a0
	cmp	a14,a0
	jrge	qwzzok

	move	a1,a1
	jrp	qwzno_negz
	neg	a0
qwzno_negz
	move	a0,a1
qwzzok
	move	a1,a6			;delta z
	move	*a4(qwzTICKS),a0
	divs	a0,a1			;a1 / a0
	move	a1,*a13(OBJ_ZVEL),L


	move	*a4(qwzMAX_TOTAL_DIST),a9
	jrn	qwzmaxok

	abs	a5
	srl	16,a5
	move	a5,a1
	mpyu	a5,a1			;deltax^2
	move	a1,a5

	abs	a6
	srl	16,a6
	move	a6,a1
	mpyu	a6,a1			;deltaz^2
	move	a1,a0

	add	a5,a0
	calla	square_root

	cmp	a0,a9			;a9-a0 (will we exceed max dist?)
	jrgt	qwzmaxok

	sll	8,a9			;x 256 (8 bits fractional)
	divu	a0,a9			;a9/a0

	move	a9,a1
	move	*a13(OBJ_XVEL),a0,L
	mpys	a0,a1			;scale down xvel
	sra	8,a1			;shift off fractional
	move	a1,*a13(OBJ_XVEL),L

	move	a9,a1
	move	*a13(OBJ_ZVEL),a0,L
	mpys	a0,a1			;scale down yvel
	sra	8,a1			;shift off fractional
	move	a1,*a13(OBJ_ZVEL),L
qwzmaxok




;to calculate YVEL taking into account gravity:
;use y-y0 = v0*t + 0.5*a*t^2


	move	*a4(qwzTICKS),a8
	move	a8,a1
	mpyu	a8,a1			;t^2
	move	*a13(OBJ_GRAVITY),a0,L
	mpyu	a0,a1			;a*t^2
	srl	1,a1			;1/2*a*t^2

;;;	move	*a11(OBJ_YPOS),a0,L	;opp y
	move	@oppy,a0,L

	move	*a13(TGT_YOFF),a14	;target y offset
	sll	16,a14
	add	a14,a0

	move	*a13(OBJ_YPOS),a2,L	;y0
	move	*a4(qwzATT_Y_OFF),a14
	sll	16,a14

	add	a14,a2

	sub	a2,a0			;a0 = a0-a2 (y - y0)
	add	a0,a1
	jrnn	qwzyvel_okay

;	LOCKUP

	clr	a1
	jruc	qwzyok
qwzyvel_okay
	divu	a8,a1			;a1 = a1/a8 ( ((y-y0)+(1/2*a*t^2)) / t )

	move	*a4(qwzMAX_Y_VEL),a0,L
	cmp	a1,a0
	jrge	qwzyok
	move	a0,a1
qwzyok
	move	a1,*a13(OBJ_YVEL),L


	;make sure both have the same INRING value
	move	*a11(INRING),a0
	move	*a13(INRING),a1
	cmp	a0,a1
	jreq	qwzdone

	;uh-oh.  our INRING's don't match.  Unless we're on the
	; turnbuckle (or flying from it), zero the X and Z
	; velocities and set the Y velocity to 50000h or something

	;...unfortunately, there's no really clean way to tell if
	; we're on the turnbuckle at this point since the LEAPAT doesn't
	; happen until well into the anim sequence and our PLYRMODE could
	; be just about anything by then.  So instead we'll fudge and look
	; at some other clues, like gravity and y pos.  If a player has a
	; Y pos that's way high (80+) pixels above GROUND_Y and no gravity,
	; that sure looks like a turnbuckle, so go with it.
	move	*a13(ANIMODE),a14
	btst	MODE_NOGRAVITY_BIT,a14
	jrz	qwznt

	move	*a13(OBJ_YPOSINT),a0
	move	*a13(GROUND_Y),a14
	sub	a14,a0
	subi	80,a0
	jrnn	qwzdone

qwznt	;no good.  leap in place
	clr	a14
	move	a14,*a13(OBJ_XVEL),L
	move	a14,*a13(OBJ_ZVEL),L
	movi	[5,0],a14
	move	a14,*a13(OBJ_YVEL),L

qwzdone
	jruc	_next_command


********
_ani_attach	;9
;	move	*a4+,a0			;xoff
;	move	a0,*a13(ATTACH_XOFF)
;	move	*a4+,a0
;	move	a0,*a13(ATTACH_YOFF)

	move	*a4+,a0,L			;xoff
	move	a0,*a13(ATTACH_XOFF),L

	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1

********
_ani_detach	;10

	move	*a13(ATTACH_PROC),a1,L
	jrz	hwpdone_really
	clr	a0
	move	a0,*a13(ATTACH_PROC),L		;not attached to anything

	move	*a1(ATTACH_PROC),a2,L
	cmp	a2,a13
	jrne	hwpdone_really			;attach_procs don't match!

	move	a0,*a1(ATTACH_PROC),L		;not attached to anything
hwpdone

	;if our victim is still in mode puppet, puppet2, headheld, or
	; attached, instead put him in ONGROUND.
	move	*a1(PLYRMODE),a14
	cmpi	MODE_PUPPET,a14
	jreq	hwpfix_opp
	cmpi	MODE_PUPPET2,a14
	jreq	hwpfix_opp
;This was fucking up the shawn franknsteiner move from headhold!
;Forcing him to dive down too low!
;	cmpi	MODE_HEADHELD,a14
;	jreq	hwpfix_opp
	cmpi	MODE_ATTACHED,a14
	jreq	hwpfix_opp
	jruc	hwpdone_really

hwpfix_opp
	movi	MODE_ONGROUND,a14
	move	a14,*a1(PLYRMODE)

hwpdone_really
	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1

********
_ani_waithitgnd	;11

	move	*a13(OBJ_YVEL),a0,L	;must have down velocity
	jrp	awuno_gnd

	;if we're the master and the attach is valid, check and see if
	; our puppet has hit the ground.
	move	*a13(ANIMODE),a14
	btst	MODE_KEEPATTACHED_BIT,a14
	jrz	awuskip_pcheck

	move	*a13(ATTACH_PROC),a0,L
	jrz	awuskip_pcheck		;we're attached?
	move	*a0(ATTACH_PROC),a14,L
	jrz	awuskip_pcheck		;they're attached?
	cmp	a13,a14
	jrne	awuskip_pcheck		;to each other?

	;ah, but if the opponent's MODE_GHOST bit is set, ignore him
	move	*a0(ANIMODE),a14
	btst	MODE_GHOST_BIT,a14
	jrnz	awuskip_pcheck

	move	*a0(OBJ_YPOSINT),a1,W
	move	*a0(GROUND_Y),a2,W
	sub	a1,a2

	jrnn	awuhit_gnd

awuskip_pcheck

	move	*a13(OBJ_YPOSINT),a0
	move	*a13(GROUND_Y),a1
	cmp	a1,a0			;a0-a1
	jrgt	awuno_gnd

awuhit_gnd
	CALLA	SMALL_BOUNCE
	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1

awuno_gnd
	movk	1,a0
	move	a0,*a10(OANICNT)	;# ticks to hold cur frame
	rets


********
_ani_xflip	;12

	move	*a13(OBJ_CONTROL),a0
	xori	M_FLIPH,a0
	move	a0,*a13(OBJ_CONTROL)

	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1

********
_ani_bounce	;13

	move	*a4+,a0			;Bounce value
	sll	16,a0
	move	a0,*a13(OBJ_YVEL),L

	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1

********
_ani_attack_on_Z ;14

;I'm not sure we want to zero attach_proc just for starting an attack!
;Watch this....
	clr	a0				;start out not attached
;	move	a0,*a13(ATTACH_PROC),L		;to anything

	move	a0,*a13(HITBLOCKER)
	move	a0,*a13(ATTACH_ZOFF)

;The start of each attack on will clear MODE_STATUS!

	move	*a13(ANIMODE),a0
	andni	MODE_STATUS2,a0
	move	a0,*a13(ANIMODE)

	move	*a13(ANIMODE),a0
	ori	MODE_CHECKHIT,a0
	move	a0,*a13(ANIMODE)

	move	*a4+,a0
	move	a0,*a13(ATTACK_MODE)
;	move	*a4+,a0
;	move	a0,*a13(OBJ_ATTXOFF)
;	move	*a4+,a0
;	move	a0,*a13(OBJ_ATTYOFF)
;	move	*a4+,a0
;	move	a0,*a13(OBJ_ATTZOFF)
;	move	*a4+,a0
;	move	a0,*a13(OBJ_ATTWIDTH)
;	move	*a4+,a0
;	move	a0,*a13(OBJ_ATTHEIGHT)
;	move	*a4+,a0
;	move	a0,*a13(OBJ_ATTDEPTH)

	move	*a4+,a0,L
	move	a0,*a13(OBJ_ATTXOFF),L
	move	*a4+,a0,L
	move	a0,*a13(OBJ_ATTZOFF),L
	move	*a4+,a0,L
	move	a0,*a13(OBJ_ATTHEIGHT),L
	move	a4,*a10(OANIPC),L

;	jruc	_next_command
	jruc	_next_command1

********
_ani_gravity_on	;15

	move	*a13(ANIMODE),a0
	andni	MODE_NOGRAVITY,a0
	move	a0,*a13(ANIMODE)

	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1

********
_ani_gravity_off ;16

	move	*a13(ANIMODE),a0
	ori	MODE_NOGRAVITY,a0
	move	a0,*a13(ANIMODE)

	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1

********
_ani_goto	;17

	move	*a4+,a4,L
	move	a4,*a10(OANIPC),L

;	jruc	_next_command
	jruc	_next_command1

********
_ani_attachz	;18

;	move	*a4+,a0			;xoff
;	move	a0,*a13(ATTACH_XOFF)
;	move	*a4+,a0
;	move	a0,*a13(ATTACH_YOFF)

	move	*a4+,a0,L
	move	a0,*a13(ATTACH_XOFF),L
	move	*a4+,a0
	move	a0,*a13(ATTACH_ZOFF)

	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1

********
_ani_slowmo	;19

	move	*a4+,a0			;frame delay
	move	a0,@slowmo

	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1

********
_ani_waitrelease ;20

	move	*a13(BUT_VAL_CUR),a0

	move	*a4+,a1			;button bit
	btst	a1,a0			;still down?
	jrz	xyabutton_up

	;since we do the flip here, we have to update FACING_DIR too.
	move	*a13(NEW_FACING_DIR),*a13(FACING_DIR)

	move	*a13(NEW_FACING_DIR),a14
	btst	PLAYER_RIGHT_BIT,a14
	jrnz	xyaright

	move	*a13(OBJ_CONTROL),a14
	ori	M_FLIPH,a14
	move	a14,*a13(OBJ_CONTROL)

	movk	1,a0
	move	a0,*a10(OANICNT)	;# ticks to hold cur frame
	rets
xyaright
	move	*a13(OBJ_CONTROL),a14
	andni	M_FLIPH,a14
	move	a14,*a13(OBJ_CONTROL)

	movk	1,a0
	move	a0,*a10(OANICNT)	;# ticks to hold cur frame
	rets

xyabutton_up
	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1

********
_ani_offset	;21

	move	*a4+,a1			;x offset
	move	*a13(FACING_DIR),a0
	btst	MOVE_RIGHT_BIT,a0
	jrnz	qafright
	neg	a1
qafright
	move	*a13(OBJ_XPOSINT),a0
	add	a1,a0
	move	a0,*a13(OBJ_XPOSINT)

	move	*a4+,a1			;y offset
	move	*a13(OBJ_YPOSINT),a0
	add	a1,a0
	move	a0,*a13(OBJ_YPOSINT)

	;SCROLL_CTRL stuff
	move	*a13(SCROLL_Y),a0
	sub	a1,a0
	move	a0,*a13(SCROLL_Y)

	move	*a4+,a1			;z offset
	move	*a13(OBJ_ZPOSINT),a0
	add	a1,a0
	move	a0,*a13(OBJ_ZPOSINT)

	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1

********
_ani_friction	;22

	move	*a4+,a0			;friction value
	move	a0,*a13(OBJ_FRICTION)

	move	*a13(ANIMODE),a0
	ori	MODE_FRICTION,a0
	move	a0,*a13(ANIMODE)

	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1


********
_ani_min_yvel	;23

;sets YVEL to given value, UNLESS it's already higher.

	move	*a4+,a0,L
	move	*a13(OBJ_YVEL),a14,L
	cmp	a0,a14
	jrge	ckdset
	move	a0,*a13(OBJ_YVEL),L
ckdset	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1

********
_ani_attachvel	;24

	STRUCT	0
	LONG	tlaXVEL
	LONG	tlaYVEL
	LONG	tlaZVEL
	LABEL	tlaSIZE

	;x velocity is always relative to attacker FACING_DIR

	move	a4,a14
	addi	tlaSIZE,a14
	move	a14,*a10(OANIPC),L

	move	*a13(ATTACH_PROC),a2,L		;proc attached to
	jrz	tlanot_attached
	move	*a2(ATTACH_PROC),a0,L
	jrz	tlanot_attached

	move	*a4(tlaYVEL),a0,L
	move	a0,*a2(OBJ_YVEL),L
	move	*a4(tlaZVEL),a0,L
	move	a0,*a2(OBJ_ZVEL),L

	move	*a4(tlaXVEL),a0,L
	move	*a13(FACING_DIR),a14
	btst	MOVE_RIGHT_BIT,a14
	jrnz	tlaxok
	neg	a0
tlaxok
	move	a0,*a2(OBJ_XVEL),L

tlanot_attached
	jruc	_next_command

********
_ani_throw1	;25

	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1

********
_ani_sound	;26

	move	*a4+,a0
	cmpi	run_snd,a0
	jrne	mofnot_run

	;if there's been another foot noise from this guy within the last
	; 12 ticks, give it a miss.
	move	@PCNT,a14
	zext	a14,W
	move	*a13(FOOT_PCNT),a1
	sub	a1,a14
	abs	a14
	cmpi	12,a14
	jrlt	mofdone
	move	@PCNT,a1
	move	a1,*a13(FOOT_PCNT)
	calla	triple_sound
	jruc	mofdone

mofnot_run
	move	a0,a0
	jrn	moftable_lookup
	calla	triple_sound
	jruc	mofdone

moftable_lookup
	calla	wrtable_sound

mofdone
	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1

********
_ani_setfacing	;27

	move	*a13(NEW_FACING_DIR),a0
	move	a0,*a13(FACING_DIR)

	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1

********
_ani_pause	;28

	;hold current frame for a few ticks
	move	*a4+,a14
	move	a4,*a10(OANIPC),L
	move	a14,*a10(OANICNT)
	rets


********
_ani_ifstatus	;29

	move	*a4+,a0,L		;this is a conditional goto
	move	*a13(ANIMODE),a1	;if MODE_STATUS set then
	btst	MODE_STATUS_BIT,a1	;branch is taken
	jrz	ljrskip

	move	a0,a4			;new ani pc
ljrskip
	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1


********
_ani_code	;30

	move	*a4+,a0,L		;code to execute
	move	a4,*a10(OANIPC),L
	PUSH	a10
	call	a0
	PULL	a10
	jruc	_next_command

********
_ani_shaker	;31

	push	a10

	move	*a4+,a10,W		;shaker mode value
	calla	SHAKER2

	pull	a10

	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1

********
_ani_changeanim ;32

	move	*a4+,a4,L
	move	a4,*a10(OANIPC),L
	move	a4,*a10(OANIBASE),L

;	jruc	_next_command
	jruc	_next_command1
	

********
_ani_faceup	;33

	movk	MOVE_UP_RIGHT,a1
	move	*a13(OBJ_CONTROL),a0
	btst	B_FLIPH,a0
	jrz	rforight
	movk	MOVE_UP_LEFT,a1
rforight	move	a1,*a13(FACING_DIR)

	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1

********
_ani_facedown	;34

	movk	MOVE_DOWN_RIGHT,a1
	move	*a13(OBJ_CONTROL),a0
	btst	B_FLIPH,a0
	jrz	xsqright
	movk	MOVE_DOWN_LEFT,a1
xsqright	move	a1,*a13(FACING_DIR)

	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1

********
_ani_bouncerope	;35

	movi	ROPE_LEFT,a0
	move	*a13(OBJ_XPOSINT),a14
	cmpi	RING_X_CENTER,a14
	jrle	vwldir_set
	movi	ROPE_RIGHT,a0
vwldir_set
	movi	ROPE_SIDES,a1
	move	*a13(OBJ_ZPOS),a3,L
	move	*a4+,a2,W
	move	a4,*a10(OANIPC),L
	jrnn	vwlno_release
	movi	ROPE_SIDESR,a1
vwlno_release
	calla	rope_command
	movi	3ch,a0
	calla	triple_sound
	jruc	_next_command

********
_ani_shakeropes	;36

	movi	ROPE_BOUNCEUD,a1
	move	*a4+,a2,W
	move	a4,*a10(OANIPC),L

	;blow it off if we're outside
	move	*a13(INRING),a14
	jrnz	_next_command

	;force a2 into range, just to be safe...
	andi	03h,a2

	movi	ROPE_BACK,a0
	calla	rope_command

	movi	ROPE_LEFT,a0
	move	*a13(OBJ_CONTROL),a14
	btst	B_FLIPH,a14
	jrnz	zhwcont

	movi	ROPE_RIGHT,a0
zhwcont
	calla	rope_command

	movi	3ch,a0
	calla	triple_sound

	jruc	_next_command

********
_ani_bendrope	;37

	movi	ROPE_LEFT,a0
	move	*a13(OBJ_XPOSINT),a14
	cmpi	RING_X_CENTER,a14
	jrle	oogdir_set
	movi	ROPE_RIGHT,a0
oogdir_set
	movi	ROPE_DOWNS,a1
	move	*a13(OBJ_ZPOS),a3,L
	move	*a4+,a2,W
	move	a4,*a10(OANIPC),L
	jrnn	oogno_release
	movi	ROPE_DOWNSR,a1
oogno_release
	calla	rope_command
	jruc	_next_command

********
_ani_setspeed	;38

	move	*a4+,a0
	move	a0,*a13(ANI_SPEED)

	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1


********
_ani_leapatpos	;39

;WORD	- oftticks to reach destination
;WORD	- max distance to travel
;WORD	- x,y,z offset of attack box (eg. attacker's fist)

;NB	- user must set TGT_XOFF,YOFF & ZOFF <-- these are the actual target


	move	*a4+,a8			;# ticks
	move	*a4+,a9			;max distance to travel

oftuser
	move	*a13(TGT_XOFF),a1	;target x
	sll	16,a1

	move	*a4+,a0			;attack x offset
	sll	16,a0
	move	*a13(OBJ_CONTROL),a14
	btst	B_FLIPH,a14
	jrz	oftright0
	neg	a0
oftright0
	move	*a13(OBJ_XPOS),a2,L
	add	a0,a2			;att x

	sub	a2,a1			;def x - att x
	move	a1,a5			;delta x
	move	a8,a0			;ticks
	divs	a0,a1			;a1 / a0
	move	a1,*a13(OBJ_XVEL),L


;to calculate YVEL taking into account gravity:
;use y-y0 = v0*t + 0.5*a*t^2

	move	a8,a1
	mpyu	a8,a1			;t^2
	move	*a13(OBJ_GRAVITY),a0,L
	mpyu	a0,a1			;a*t^2
	srl	1,a1			;1/2*a*t^2

	move	*a13(TGT_YOFF),a0	;target y
	sll	16,a0

	move	*a4+,a14		;attack y offset
	sll	16,a14
	move	*a13(OBJ_YPOS),a2,L	;y0
	sub	a14,a2

	sub	a2,a0			;a0 = a0-a2 (y - y0)
	add	a0,a1
	divu	a8,a1			;a1 = a1/a8 ( ((y-y0)+(1/2*a*t^2)) / t )

	cmpi	00f0000H,a1
	jrlt	oftyok
	movi	00f0000H,a1
oftyok	move	a1,*a13(OBJ_YVEL),L


	move	*a13(TGT_ZOFF),a1	;target z
	sll	16,a1

	move	*a4+,a0			;attack z offset
	sll	16,a0
	move	*a13(OBJ_ZPOS),a2,L
	add	a0,a2			;att z

	sub	a2,a1			;def z - att z
	move	a1,a6			;delta z
	move	a8,a0			;ticks
	divs	a0,a1			;a1 / a0
	move	a1,*a13(OBJ_ZVEL),L


	abs	a5
	srl	16,a5
	move	a5,a1
	mpyu	a5,a1			;deltax^2
	move	a1,a5

	abs	a6
	srl	16,a6
	move	a6,a1
	mpyu	a6,a1			;deltaz^2
	move	a1,a0

	add	a5,a0
	calla	square_root

	cmp	a0,a9			;a9-a0 (will we exceed max dist?)
	jrgt	oftok

	sll	8,a9			;x 256 (8 bits fractional)
	divu	a0,a9			;a9/a0

	move	a9,a1
	move	*a13(OBJ_XVEL),a0,L
	mpys	a0,a1			;scale down xvel
	sra	8,a1			;shift off fractional
	move	a1,*a13(OBJ_XVEL),L

	move	a9,a1
	move	*a13(OBJ_ZVEL),a0,L
	mpys	a0,a1			;scale down yvel
	sra	8,a1			;shift off fractional
	move	a1,*a13(OBJ_ZVEL),L

oftok
	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1


********
_ani_zero_xzvels	;40

	clr	a0
	move	a0,*a13(OBJ_XVEL),L
	move	a0,*a13(OBJ_ZVEL),L
	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1


********
_ani_rope_z		;41
	;.word	ANI_ROPE_Z,R_TOP,RZ_HIGH

	;which rope has he hit?
	move	@right_rproc,a0,L
	move	*a13(OBJ_XPOS),a14,L
	cmpi	RING_X_CENTER<<16,a14
	jrgt	fdcright

	move	@left_rproc,a0,L
fdcright
	move	*a4+,a1,W		;rope index
	move	*a4+,a2,W		;action
	calla	set_rope_z
	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1


********
_ani_loop		;42

	.ref	arw_bwait

	move	@p1rounds,a0
	cmpi	2,a0
	jrz	rzhat_end
	move	@p2rounds,a0
	cmpi	2,a0
	jreq	rzhat_end

	;oooh, wait.  If we've pinned someone, and announce_rnd_winner
	; is waiting on the result (they'll be waiting to wake up at
	; arw_bwait if they are) then we should wake it up.
	move	*a13(STATUS_FLAGS),a14
	btst	B_PINNED,a14
	jrz	rzhno_pin

	movi	ANNC_PID,a0
	clr	a1
	not	a1
	calla	EXISTP
	jrnz	rzhno_pin		;annc exists?

	move	*a0(PWAKE),a14,L
	cmpi	arw_bwait,a14
	jrne	rzhno_pin		;waiting for a pin?

	movk	1,a14
	move	a14,*a0(PTIME)	;wake it up.

rzhno_pin	movk	1,a0
	move	a0,*a10(OANICNT)
	rets

rzhat_end
	jruc	_ani_detach	;10
;
;	move	a4,*a10(OANIPC),L
;	jruc	_next_command


********
;_ani_set_opp_getup	;43
;
;;args:	.word (GETUP_TIME)
;
;	move	*a4+,a0
;
;	move	*a13(WHOIHIT),a14,L
;	move	a0,*a14(GETUP_TIME)
;
;	move	a4,*a10(OANIPC),L
;	jruc	_next_command
;


********
_ani_set_xvel		;44

;args:	.long (XVEL) .word (MODE)	;if MODE=0  vel is absolute
					;if MODE=3  vel is new_face relative
	move	*a4+,a0,L
	move	*a4+,a1
	jrz	yyxabs
	dec	a1
	jrz	yyxface
	dec	a1
	jrz	yyxhit

;new_facing relative
	move	*a13(NEW_FACING_DIR),a14
	btst	MOVE_RIGHT_BIT,a14
	jrnz	yyxabs			;right
	neg	a0			;left
	jruc	yyxabs

yyxhit
;hit relative
	move	*a13(PLYR_HIT_SIDE),a14
	btst	MOVE_RIGHT_BIT,a14
	jrnz	yyxabs			;hit from right

	neg	a0			;hit from left
	jruc	yyxabs
yyxface
	move	*a13(FACING_DIR),a14
	btst	MOVE_RIGHT_BIT,a14
	jrnz	yyxabs			;right
	neg	a0			;left
yyxabs
	move	a0,*a13(OBJ_XVEL),L

	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1


********
_ani_ifnotstatus	;45

	move	*a4+,a0,L		;this is a conditional goto
	move	*a13(ANIMODE),a1	;if MODE_STATUS clear then
	btst	MODE_STATUS_BIT,a1	;branch is taken
	jrnz	hwaskip

	move	a0,a4			;new ani pc
hwaskip
	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1

********
_ani_slide_back

	move	*a4+,a8			;range
	move	*a4+,a9,L		;x-vel
	move	*a4+,a7,L		;new ani PC if no slide
	move	a4,*a10(OANIPC),L

	move	*a13(ANIMODE),a14	;was there a collision?
	btst	MODE_STATUS_BIT,a14
	jrz	xnsno_slide


	move	*a13(WHOIHIT),a6,L

;	move	*a6(PLYRMODE),a5
;	cmpi	MODE_BLOCK,a5
;	jrz	xnsno_slide

	move	*a6(OBJ_XPOSINT),a5
	move	*a13(OBJ_XPOSINT),a0

	cmp	a5,a0			;a0-a5
	jrgt	xnshit_from_right

;hit_from_left
	move	*a13(INRING),a0
	jrnz	xnsoutside1

	PUSH	a6,a13
	move	a6,a13
	movi	vln_right_rope,a6
	calla	calc_line_x
	PULL	a6,a13
	move	*a6(OBJ_XPOSINT),a1
	sub	a1,a0
	abs	a0
	cmp	a8,a0
	jrgt	xnsno_slide
	jruc	xnsslide

xnsoutside1
	;hit from left outside ring.
	; get left matedge first.  if it's zero, or greater than our
	; x pos, check against right fence instead.
	PUSH	a6
	movi	vln_left_matedge,a6
	calla	calc_line_x
	PULL	a6
	TEST	a0
	jrz	xnscheck_right_fence
	move	*a6(OBJ_XPOSINT),a1
	sub	a1,a0
	jrlt	xnscheck_right_fence

	;less than a nonzero left matedge val.  check against it.
	cmp	a1,a8
	jrgt	xnsno_slide
	jruc	xnsslide

xnscheck_right_fence
	PUSH	a6,a13
	move	a6,a13
	movi	vln_right_fence,a6
	calla	calc_line_x
	PULL	a6,a13
	move	*a6(OBJ_XPOSINT),a1
	sub	a1,a0
	abs	a0
	cmp	a8,a0
	jrgt	xnsno_slide
	jruc	xnsslide

xnshit_from_right
	move	*a13(INRING),a0
	jrnz	xnsoutside2

	PUSH	a6,a13
	move	a6,a13
	movi	vln_left_rope,a6
	calla	calc_line_x
	PULL	a6,a13
	move	*a6(OBJ_XPOSINT),a1
	sub	a1,a0
	abs	a0
	cmp	a8,a0
	jrgt	xnsno_slide

	neg	a9
	jruc	xnsslide
xnsoutside2
	;hit from right outside ring.
	; get right matedge first.  if it's zero, or greater than our
	; x pos, check against left fence instead.
	PUSH	a6
	movi	vln_right_matedge,a6
	calla	calc_line_x
	PULL	a6
	TEST	a0
	jrz	xnscheck_left_fence
	move	*a6(OBJ_XPOSINT),a1
	sub	a0,a1
	jrlt	xnscheck_left_fence

	;greater than a nonzero right matedge val.  check against it.
	cmp	a1,a8
	jrle	xnsno_slide
	neg	a9
	jruc	xnsslide

xnscheck_left_fence
	PUSH	a6,a13
	move	a6,a13
	movi	vln_left_fence,a6
	calla	calc_line_x
	PULL	a6,a13
	move	*a6(OBJ_XPOSINT),a1
	sub	a1,a0
	abs	a0
	cmp	a8,a0
	jrgt	xnsno_slide
	neg	a9

xnsslide
	move	a9,*a13(OBJ_XVEL),L


	movi	3000h,a0
	move	a0,*a13(OBJ_FRICTION)

	move	*a13(ANIMODE),a0
	ori	MODE_FRICTION,a0
	move	a0,*a13(ANIMODE)
	jruc	_next_command

xnsno_slide
	move	a7,*a10(OANIPC),L
	jruc	_next_command


********
_ani_clr_damage	;47

	move	a4,*a10(OANIPC),L
;	calla	clear_damage_log
;	jruc	_next_command
	jruc	_next_command1

********
_ani_set_zvel		;48

;args:	.long (ZVEL) .word (MODE)	;if MODE=0  vel is absolute
					;if MODE=1  vel is facing relative
					;if MODE=2  vel is hit relative
	move	*a4+,a0,L
	move	*a4+,a1
	jrz	calabs
	dec	a1
	jrz	calface
;hit relative
	move	*a13(PLYR_HIT_SIDE),a14
	btst	MOVE_UP_BIT,a14
	jrnz	calabs			;hit from above

	neg	a0			;hit from below
	jruc	calabs
calface
	move	*a13(FACING_DIR),a14
	btst	MOVE_DOWN_BIT,a14
	jrnz	calabs			;down
	neg	a0			;up
calabs
	move	a0,*a13(OBJ_ZVEL),L

	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1


********
_ani_checkword	;49
;sets a word in the procs pdata area
;	.word	ANI_SETWORD,OFFSET,VAL

	move	*a4+,a0		;OFFSET
	move	a4,*a10(OANIPC),L
	add	a13,a0
	move	*a0,a0
	jrz	ruvclr

;hit.  set mode_status
	move	*a13(ANIMODE),a0
	ori	MODE_STATUS2,a0
	move	a0,*a13(ANIMODE)

	jruc	_next_command


ruvclr
;clear mode_status
	move	*a13(ANIMODE),a0
	andni	MODE_STATUS2,a0
	move	a0,*a13(ANIMODE)

	jruc	_next_command




********
_ani_face	;50

	move	*a4+,a0
	move	a4,*a10(OANIPC),L

	move	*a13(OBJ_CONTROL),a14
	btst	B_FLIPH,a14
	jrz	ehxno_flip
	xori	MOVE_LEFT|MOVE_RIGHT,a0
ehxno_flip
	move	a0,*a13(FACING_DIR)

	jruc	_next_command


********
_ani_setword	;51

;sets a word in the procs pdata area
;	.word	ANI_SETWORD,OFFSET,VAL

	move	*a4+,a0		;OFFSET
	add	a13,a0
	move	*a4+,a1		;VAL
	move	a1,*a0
	move	a4,*a10(OANIPC),L

;	jruc	_next_command
	jruc	_next_command1

********
_ani_getup	;52

;args:	.word (GETUP_TIME)

	move	*a4+,a0

	move	*a13(PLYR_DIZZY),a14
	jrnz	nfmskip

	move	a0,*a13(GETUP_TIME)

nfmskip
	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1

********
_ani_getup_wait	;53

	move	*a13(GETUP_TIME),a0
	jrnz	gzjno_done

	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1

gzjno_done
	movk	1,a0
	move	a0,*a10(OANICNT)	;# ticks to hold cur frame
	rets

********
_ani_clr_stars	;54

	clr	a0
	move	a0,*a13(STARS_FLAG)
	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1

********
_ani_shakeall	;55

	movi	ROPE_BOUNCEUD,a1
	move	*a4+,a2,W
	move	a4,*a10(OANIPC),L

	;blow it off if we're outside
	move	*a13(INRING),a14
	jrnz	_next_command

	move	@reduce_bog,a14
	jrnz	_next_command

	;force a2 into range, just to be safe...
	andi	03h,a2

	movi	ROPE_BACK,a0
	calla	rope_command
	movi	ROPE_LEFT,a0
	calla	rope_command
	movi	ROPE_RIGHT,a0
	calla	rope_command
	movi	ROPE_FRONT,a0
	calla	rope_command

	movi	3ch,a0
	calla	triple_sound

	jruc	_next_command

********
_ani_damage	;56

	move	*a4+,a0
	neg	a0			;positive a0 = health increase...
	move	*a13(PLYRNUM),a1
	calla	adjust_health

	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1

********
_ani_start_dizzy ;57

;	clr	a0
;	move	a0,*a13(PLYR_DIZZY)
	PUSH	a10
	move	*a4+,a10			;Where do stars go?
	calla	create_dizzy_proc
	PULL	a10

	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1

********
_ani_clr_status ;58

	move	*a13(ANIMODE),a1
	andni	MODE_STATUS2,a1
	move	a1,*a13(ANIMODE)

	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1

********
_ani_set_target	;59

	move	*a4+,a0
	move	a4,*a10(OANIPC),L
	calla	set_target_offsets
	jruc	_next_command

********
_ani_max_x	;60

	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1

********
_ani_max_z	;61

	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1

********
_ani_max_y_vel	;62

	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1

********
_ani_superslave	;63

;	long	pointer to slave table
;	word	index into table

	move	*a4+,a5,L		;* table
	move	*a4+,a6			;index to frame & offsets
	move	a4,*a10(OANIPC),L

	move	*a13(ATTACH_PROC),a11,L
	move	*a11(ATTACH_PROC),a0,L
	cmp	a13,a0
	jrne	pqidone

	move	*a11(WRESTLERNUM),a0
	X32	a0
	add	a5,a0
	move	*a0,a5,L
 .if DEBUG
 	move	*a5,a0,L		;table defined?
	jrnz	pqiok1
	LOCKUP
;	no slave table defined!
pqiok1
 .endif

	movi	80,a1	;LWWW
	mpyu	a6,a1

	add	a1,a5
	move	*a5+,a0,L		;* * image
	move	*a0,a0,L		;* image
 .if DEBUG
 	jrnz	pqiok
	LOCKUP
;	image not loaded! (null pointer)
pqiok
 .endif
	move	a0,*a11(CUR_FRAME),L	;primary frame

	move	*a5+,a0			;xoff
	move	a0,*a13(ATTACH_XOFF)
	move	*a5+,a0
	move	a0,*a13(ATTACH_YOFF)

	move	*a11(OBJ_CONTROL),a3

	move	*a13(FACING_DIR),a14
	btst	PLAYER_RIGHT_BIT,a14
	jrnz	pqiright
;left
	andni	M_FLIPH,a3		;clear flip bit
	jruc	pqicnt
pqiright
	ori	M_FLIPH,a3		;set flip
pqicnt
	move	*a5+,a0			;flip flag
	jrz	pqiskip

	xori	M_FLIPH,a3		;invert
pqiskip
	move	a3,*a11(OBJ_CONTROL)

pqidone
	jruc	_next_command

********
*
;same as old slaveanim except this executes
;the animation up to the 1st sleep

_ani_slaveanim	;64

	move	*a4+,a5,L		;* table
	move	a4,*a10(OANIPC),L

	move	*a13(ATTACH_PROC),a2,L
	move	*a2(ATTACH_PROC),a0,L
	cmp	a13,a0
	jrne	viydone

	move	*a2(WRESTLERNUM),a0
	X32	a0
	add	a0,a5
	move	*a5,a0,L
	jrnz	viyok1
 .if DEBUG
	LOCKUP
;	no slave anim table defined!
 .endif
	jruc	_next_command
viyok1
;a0 = * animation script
;a2 = * wrestler process

	PUSH	a10,a13

	move	a2,a13
	callr	change_anim1a	;execute animation

	PULL	a10,a13

viydone
	jruc	_next_command

********
_ani_rawsound	;65

	move	*a4+,a3,W
	calla	SNDSND
	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1

********
_ani_damageopp	;66
	;works on attached proc, or WHOIHIT if there isn't one

	.ref	any_hits,DAM_MULT,FIRSTATT_MESS

	STRUCT	0
	WORD	qlaFULL_DAMAGE
	WORD	qlaREDUCED_DAMAGE
	LABEL	qlaSIZE

	move	a4,a14
	addi	qlaSIZE,a14
	move	a14,*a10(OANIPC),L

	;get victim process ptr
	move	*a13(ATTACH_PROC),a2,L
	jrnz	qlaattach_found
	move	*a13(WHOIHIT),a2,L
qlaattach_found

	;get damage
	move	*a4(qlaFULL_DAMAGE),a0
	move	*a2(LAST_DAMAGE),a14
	jrz	qladmset
	move	@PCNT,a1
	sub	a14,a1
	cmpi	30,a1
	jrgt	qladmset
	move	*a4(qlaREDUCED_DAMAGE),a0
qladmset

	;ooh, wait.  if the attacker has a NEXT_DAMAGE set, use that instead.
	move	*a13(NEXT_DAMAGE),a14
	jrz	qlannd		;aw, skip it.
	move	*a13(SPECIAL_DAMAGE_TIME),a14,L
	move	@PCNT,a1,L
	cmp	a14,a1
	jrgt	qlannd		;too late.  blow it off.
	move	*a13(NEXT_DAMAGE),a0

qlannd	neg	a0

	;If this is the first unblocked hit this round and it did at least
	; 2 pixels of damage, give an award

	PUSH	a0

	cmpi	-2,a0
	jrgt	qlan1uh

;Taunt style high risk move - give 3x dmg
	move	*a13(RISK),a1
	jrz	qlano_mult

	PUSH	a0,a8,a10
	move	a13,a8
	btst	15,a1
	jrz	qlareg
;Taunt style high risk move - give 3x dmg
	movi	-1,a10
	movk	4,a14
	move	a14,@DAM_MULT
	.ref	BONUS_MESS
	CREATE0	BONUS_MESS
qlareg
	clr	a1
	move	a1,*a13(RISK)
	PULL	a0,a8,a10
	jruc	qlaclear
qlano_mult


	move	@any_hits,a14
	jrnz	qlan1uh			;skip if there's already been one

	move	*a2(PLYRMODE),a14
	cmpi	MODE_BLOCK,a14
	jreq	qlan1uh			;skip if it was blocked

	RND_AWARD a13,FIRST_HIT_AWD

	PUSH	a10
	move	a13,a10
	CREATE	MESSAGE_PID,FIRSTATT_MESS
	PULL	a10

	movk	2,a14
	move	a14,@DAM_MULT
qlaclear
	movk	1,a14
	move	a14,@any_hits
qlan1uh	PULL	a0


;MODS REQUIRED TO MAKE ADJUST_HEALTH WORK IN COMBO MODE
	move	*a2(PLYRNUM),a1
	PUSH	A10,A13

	MOVE	A13,A10
	calla	adjust_health

	PULL	A10,A13

qladone	jruc	_next_command

********
_ani_rndper	;67

	;word	probability
	;long	jump here if hit

	move	*a4+,a0,W
	move	*a4+,a2,L
	calla	RNDPER
	jrls	owjdone

	;ANI_GOTO a2
	move	a2,*a10(OANIPC),L
	jruc	_next_command

owjdone
	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1

********
_ani_waithitopp	;68

	;NOTE:	This is just like an ordinary "WL ticks,frame" type command
	;	except that the ANICNT is zeroed if we hit the opponent.

	;word	max ticks to wait
	;long	frame to hold

	move	*a13(ANIMODE),a14
	ori	MODE_WAITHITOPP,a14
	move	a14,*a13(ANIMODE)

	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1


********
_ani_attchimage	;69

;long *image,word zoff

	;update OANIPC
	move	a4,a14
	addi	30h,a14
	move	a14,*a10(OANIPC),L

	clr	a14
;	move	a14,*a13(ATTACHIMG_XOFF)
;	move	a14,*a13(ATTACHIMG_YOFF)

	move	a14,*a13(ATTACHIMG_XOFF),L

	move	*a4+,a0,L
	jrz	adroffimg

	move	*a4+,a1
	move	a1,*a13(ATTACHIMG_ZOFF)
adroff
attach_cont69	;entry from attachimage2 adr124
	move	*a13(ATTIMG_CUR_FRAME),*a13(ATTIMG_LAST_FRAME),L

	move	*a0,a0,L
 .if DEBUG
	jrnz	adrok
	LOCKUP
;NULL IMAGE POINTER!!!
adrok
 .endif
;adroffimg
	move	a0,*a13(ATTIMG_CUR_FRAME),L
	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1

adroffimg
	move	a0,*a13(ATTIMG_CUR_FRAME),L
	addk	16,a4
	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1

 .if 0

	move	*a4+,a0,L
	jrz	adroff
	move	*a4+,a1
	move	a1,*a13(ATTIMG_ZOFF)

	move	*a0,a0,L
 .if DEBUG
	jrnz	adrok
	LOCKUP
;NULL IMAGE POINTER!!!
adrok
 .endif

	move	a0,*a13(ATTIMG_CUR_FRAME),L
	move	*a13(ATTIMG_IMG),a8,L

	move	a0,*a8(OIMG),L
	move	*a0(0),*a8(OSIZE),L
	move	*a0(ISAG),*a8(OSAG),L

	move	*a0(ICMAP),a0,L
	calla	pal_find
	jrnz	adrAOK

	LOCKUP	;can't find palette

adrAOK
	move	a0,*a8(OPAL)
	move	*a8(OIMG),a0,L
	movb	*a0(ICTRL+7),*a8(OCTRL+7)	;Write 5 z comp bits + bits pp

	move	*a13(OBJ_CONTROL),a7	;flip bits & pixel ops
	andi	0111111b,a7
;	setf	6,0,0
;	move	a7,*a8(OCTRL)			;Write 6 low bits
;	setf	16,1,0
	move	*a8(OCTRL),a14
	srl	6,a14
	sll	6,a14
	or	a7,a14
	move	a14,*a8(OCTRL)

	move	*a13(OBJ_CONST),*a8(OCONST)

	jruc	_next_command

adroff
	move	a0,*a13(ATTIMG_CUR_FRAME),L
	jruc	_next_command

 .endif

********
_ani_ifoppmode		;70

	;If opponent PLYRMODE is vmlMODE, jump to vmlBRANCH
	;If the high bit of vmlMODE is set, jump on PLYRMODE != ~vmlMODE

	STRUCT	0
	WORD	vmlMODE
	LONG	vmlBRANCH
	LABEL	vmlSIZE

	move	a4,a14
	addi	vmlSIZE,a14
	move	a14,*a10(OANIPC),L

	move	*a13(CLOSEST_NUM),a11
	X32	a11
	addi	process_ptrs,a11
	move	*a11,a11,L
	move	*a11(PLYRMODE),a14

	move	*a4(vmlMODE),a0
	jrn	vmlnot
	cmp	a0,a14
	jrne	vmldone
	jruc	vmlBRANCH

vmlnot
	not	a0
	cmp	a0,a14
	jreq	vmldone

vmlBRANCH
	move	*a4(vmlBRANCH),a0,L
	move	a0,*a10(OANIPC),L

vmldone
	jruc	_next_command

********
_ani_ifbuttons	;71

;buttons (WORD), ani address (LONG)

	move	*a13(BUT_VAL_CUR),a0


	move	*a4+,a1			;button vals
	move	*a4+,a2,L		;ani address

;;Drones shouldn't run accidentally
;	move	*a13(PLYR_TYPE),a14
;	cmpi	PTYPE_DRONE,a14
;	jrz	bjgfail

	and	a1,a0
	cmp	a1,a0
	jrne	bjgfail

	move	a2,a4	;jump to new ani address
bjgfail
	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1


********
_ani_ifnohitblock	;72

;ani address (LONG)

	move	*a4+,a0,L		;this is a conditional goto
	move	*a13(HITBLOCKER),a14
	jrnz	skip?
	move	a0,a4
skip?
	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1

********
_ani_end	;73
	move	*a10(OANIMODE),a0
	ori	MODE_END,a0
	move	a0,*a10(OANIMODE)
	jruc	_exit

********
_ani_ifrope	;74
	clr	a11
	jruc	_ani_ifrope_common

********
_ani_ifnotrope	;75

bnxMODE	equ	0	;UHW
bnxDIST	equ	10h	;UHW
bnxADDR	equ	20h	;UHL
bnxSIZE	equ	40h

	;word	distance
	;long	jump here if close enough
	;word	mode	RC_FRONT    - check rope in front of caller
	;		RC_BACK     - check rope behind caller
	;		RC_EITHER   - check nearest rope
	;	or'ed with:
	;		RC_PLAYER   - check for caller
	;		RC_OPPONENT - check for caller's closest opponent

	movk	1,a11

_ani_ifrope_common
	;prepare OANIPC before doing anything else
	move	a4,a14
	addi	bnxSIZE,a14
	move	a14,*a10(OANIPC),L

	move	*a13(INRING),a0
	jrnz	bnxdefinitly_too_far

	;;;a9 is process ptr of person for whom we're checking
	move	a13,a9
	move	*a4(bnxMODE),a0
	sra	8,a0			;mask off the low byte
	jrz	bnxplayer_set		;RC_PLAYER == 0

	move	*a13(CLOSEST_NUM),a9
	X32	a9
	addi	process_ptrs,a9
	move	*a9,a9,L
bnxplayer_set

	move	*a4(bnxMODE),a14,W	;mode
	andi	00FFh,a14		;mask off the high byte
	jrz	bnxcheck_front		;RC_FRONT == 0
	dec	a14
	jrz	bnxcheck_back

	;;;RC_(FRONT|BACK|EITHER) cases
bnxcheck_closest
	move	*a9(OBJ_XPOSINT),a1
	cmpi	RING_X_CENTER,a1
	jrgt	bnxcheck_right_rope
	jruc	bnxcheck_left_rope

bnxcheck_front
	move	*a9(FACING_DIR),a0
	btst	MOVE_RIGHT_BIT,a0
	jrnz	bnxcheck_right_rope
	jruc	bnxcheck_left_rope

bnxcheck_back
	move	*a9(FACING_DIR),a0
	btst	MOVE_LEFT_BIT,a0
	jrnz	bnxcheck_right_rope
	jruc	bnxcheck_left_rope


	;now do the actual check
bnxcheck_left_rope
	movi	vln_left_rope,a6
	jruc	bnxcheck_xxx_rope
bnxcheck_right_rope
	movi	vln_right_rope,a6
bnxcheck_xxx_rope
	calla	calc_line_x
	move	*a9(OBJ_XPOSINT),a1
	sub	a0,a1
	abs	a1
	move	*a4(bnxDIST),a0
	cmp	a0,a1
	jrle	bnxclose_enough


	;a11 is one if we are an IFNOTROPE command, so swap outcomes.
bnxtoo_far
	dec	a11
	jrz	bnxclose_enough
bnxdefinitly_too_far
	jruc	_next_command

bnxclose_enough
	dec	a11
	jrz	bnxtoo_far

	move	*a4(bnxADDR),a0,L
	move	a0,*a10(OANIPC),L
	jruc	_next_command


********
_ani_opp_getup	;76

;if TIME is negative, then clear DELAY_METER

ieeTIME	equ	0	;UHW
ieeSIZE	equ	10h

	move	a4,a14
	addi	ieeSIZE,a14
	move	a14,*a10(OANIPC),L

	move	*a13(ATTACH_PROC),a1,L
	jrnz	ieevictim_set

	;not attached.  check WHOIHIT
	move	*a13(WHOIHIT),a1,L
	jrz	ieedone

ieevictim_set

	move	*a4(ieeTIME),a0
	jrnn	ieenorm

	clr 	a14
	move	a14,*a1(DELAY_METER)	;always do delay

	abs	a0			;make GETUP_TIME positive

ieenorm
	move	*a1(PLYR_DIZZY),a14
	jrnz	ieedone

	move	a0,*a1(GETUP_TIME)
ieedone
	jruc	_next_command

********
_ani_shakecorner	;77

	movk	1,a2
	movi	ROPE_BOUNCEUD,a1
	movi	ROPE_BACK,a0
	calla	rope_command

	movi	ROPE_LEFT,a0
	move	*a13(OBJ_XPOSINT),a14
	cmpi	RING_X_CENTER,a14
	jrle	hgydir_set
	movi	ROPE_RIGHT,a0
hgydir_set

	movi	ROPE_BOUNCEUD,a1
	calla	rope_command

	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1

********
_ani_singlestep		;78

	
	calla	get_all_buttons_down
	move	a0,a0
	jrnz	paqdone
	move	a1,*a10(OANICNT)
	jruc	_exit

paqdone
	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1

********
_ani_superslave2	;79

;	# ticks
;	attacker frame
;	table address
;	table index

	STRUCT	0		;ANI_SUPERSLAVE data
	WORD	wflTICKS
	LONG	wflATTACKER
	LONG	wflTABLE
	WORD	wflINDEX
	LABEL	wflSIZE

	STRUCT	0		;table data
	LONG	wflFRAME
	WORD	wflXOFF
	WORD	wflYOFF
	WORD	wflFLIP
	LABEL	wflTABLE_SIZE

	;set OANIPC
	move	a4,a14
	addi	wflSIZE,a14
	move	a14,*a10(OANIPC),L

	;verify the links
	move	*a13(ATTACH_PROC),a11,L
	move	*a11(ATTACH_PROC),a0,L
	cmp	a13,a0
	jrne	wfldone

	move	*a4(wflTICKS),a0
	move	*a13(ANI_SPEED),a1
	mpyu	a0,a1
	srl	8,a1
	move	a1,*a10(OANICNT)
	move	*a4(wflATTACKER),a0,L
	move	*a0,a0,L

	.if DEBUG
	jrnz	wflok0
	LOCKUP	;image not loaded! (null pointer)
wflok0
	.endif
	;set the attacker frame
	move	a0,*a10(OCUR_FRAME),L


	;get the slave table
	move	*a11(WRESTLERNUM),a0
	X32	a0
	move	*a4(wflTABLE),a14,L
	add	a14,a0
	move	*a0,a5,L

	.if DEBUG
	move	*a5,a0,L
	jrnz	wflok1
	LOCKUP	;no slave table defined!
wflok1
	.endif

	;get the defender frame
	move	*a4(wflINDEX),a14
	movi	wflTABLE_SIZE,a1
	mpyu	a14,a1
	add	a1,a5
	move	*a5(wflFRAME),a0,L
	move	*a0,a0,L

	.if DEBUG
	jrnz	wflok
	LOCKUP	;image not loaded! (null pointer)
wflok
	.endif

	;set the defender frame
	move	a0,*a11(CUR_FRAME),L

	;compute attach offsets
	; attach Y is raw(table)x + defender Xoff - attacker Xoff

	;attacker anis in a8, defender in a9
	move	*a13(CUR_FRAME),a0,L	;attacker frame
	calla	get_mpart_offsets
	move	a0,a8
	move	*a11(CUR_FRAME),a0,L	;defender frame
	calla	get_mpart_offsets
	move	a0,a9

	;attacker size in a6, defender in a7
	move	*a13(CUR_FRAME),a0,L	;attacker frame
	calla	get_mpart_xsize
	move	a0,a6
	move	*a11(CUR_FRAME),a0,L	;defender frame
	calla	get_mpart_xsize
	move	a0,a7

	;compute Y offset
	move	*a5(wflYOFF),a1		;raw Y

	move	a9,a14
	sra	16,a14
	sub	a14,a1			;sub defender aniY

	move	a8,a14
	sra	16,a14
	add	a14,a1			;add attacker aniY

	move	a1,*a13(ATTACH_YOFF)

	;attach Xoff:
	; no flip:       raw x + def xoff - att xoff
	; def flip:      raw x + (def xsz - def xoff) - att xoff

	;compute X offset
	move	*a5(wflXOFF),a1			;raw X

	;defender part in a2
	move	a9,a2
	andi	0FFFFh,a2		;def xoff
	sext	a2
	callr	wflattacker_flip_test
	jrc	wflaf_match

	;attack X's don't match up
	move	*a5(wflFLIP),a14
	jrz	wfldef_set
	neg	a2
	add	a7,a2			;def xsize
	jruc	wfldef_set

	;attack X's match up
wflaf_match
	move	*a5(wflFLIP),a14
	jrnz	wfldef_set
	neg	a2
	add	a7,a2			;def xsize
wfldef_set

	;attacker part in a3
	move	a8,a3
	andi	0FFFFh,a3		;att xoff

	add	a2,a1
	sub	a3,a1

	;if X's don't match, negate this
	calla	wflattacker_flip_test
	jrc	wflfoox
	neg	a1
wflfoox

	move	a1,*a13(ATTACH_XOFF)


	;set flip bits properly
	move	*a11(OBJ_CONTROL),a3
	move	*a13(FACING_DIR),a14
	btst	PLAYER_RIGHT_BIT,a14
	jrnz	wflright
;left
	andni	M_FLIPH,a3		;clear flip bit
	jruc	wflcnt
wflright
	ori	M_FLIPH,a3		;set flip
wflcnt
	move	*a5(wflFLIP),a0		;flip flag
	jrz	wflskip

	xori	M_FLIPH,a3		;invert
wflskip
	move	a3,*a11(OBJ_CONTROL)

wfldone
	jruc	_exit

 SUBRP	wflattacker_flip_test
	;Test for attacker flip.  When facing right, flip should be off.
	; When facing left, should be on.  Set the carry flag if everything
	; is okay.
	PUSH	a0,a1
	move	*a13(FACING_DIR),a0
	move	*a13(OBJ_CONTROL),a1
	btst	B_FLIPH,a1
	jrnz	wflttf_set

wflttf_clear
	btst	MOVE_LEFT_BIT,a0
	jrnz	wflttf_flip
	jruc	wflttf_noflip
wflttf_set
	btst	MOVE_RIGHT_BIT,a0
	jrnz	wflttf_flip
	jruc	wflttf_noflip

wflttf_flip
	PULL	a0,a1
	clrc
	rets
wflttf_noflip
	PULL	a0,a1
	setc
	rets

********
_ani_setoppmode		;80

	STRUCT	0
	WORD	fghMODE
	LABEL	fghSIZE

	move	a4,a14
	addi	fghSIZE,a14
	move	a14,*a10(OANIPC),L

	move	*a13(ATTACH_PROC),a0,L
	jrz	fghdone
	move	*a0(ATTACH_PROC),a14,L
	jrz	fghdone

	move	*a0(ANIMODE),a1
	move	*a4(fghMODE),a14
	or	a14,a1
	move	a1,*a0(ANIMODE)

fghdone
	jruc	_next_command

********
_ani_clroppmode		;81

	STRUCT	0
	WORD	wybMODE
	LABEL	wybSIZE

	move	a4,a14
	addi	wybSIZE,a14
	move	a14,*a10(OANIPC),L

	move	*a13(ATTACH_PROC),a0,L
	jrz	wybdone
	move	*a0(ATTACH_PROC),a14,L
	jrz	wybdone

	move	*a0(ANIMODE),a1
	move	*a4(wybMODE),a14
	andn	a14,a1
	move	a1,*a0(ANIMODE)

wybdone
	jruc	_next_command

********
_ani_oppoffset		;82

	STRUCT	0
	LONG	xunTABLE
	LABEL	xunSIZE

	move	a4,a14
	addi	xunSIZE,a14
	move	a14,*a10(OANIPC),L

	move	*a13(ATTACH_PROC),a0,L
	jrz	xundone
	move	*a0(ATTACH_PROC),a14,L
	jrz	xundone

	move	*a0(WRESTLERNUM),a1
	X32	a1

	move	*a4(xunTABLE),a14,L
	jrz	xundone
	add	a14,a1

	move	*a0(OBJ_XPOSINT),a2
	move	*a1+,a3
	move	*a0(FACING_DIR),a14
	btst	MOVE_RIGHT_BIT,a14
	jrnz	xunright
	neg	a3
xunright
	add	a3,a2
	move	a2,*a0(OBJ_XPOSINT)

	move	*a0(OBJ_YPOSINT),a2
	move	*a1+,a3
	add	a3,a2
	move	a2,*a0(OBJ_YPOSINT)

xundone
	jruc	_next_command

********
_ani_ifblocked	;83

	move	*a4+,a0,L		;this is a conditional goto
	move	*a13(HITBLOCKER),a1
	jrz	musskip

	move	a0,a4			;new ani pc
musskip
	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1

********
_ani_waitroll	;84

	;Zombies always roll up.
	move	*a13(STATUS_FLAGS),a14
	btst	B_ZOMBIE,a14
	jrnz	arnzombie

	;DEAD check
	move	*a13(PLYRMODE),a14
	cmpi	MODE_DEAD,a14
	jreq	arndead
	move	*a13(I_WILL_DIE),a14
	jrz	arnnotded

	;I_WILL_DIE is set.  If immobilize is zero, die and clear it.
	move	*a13(IMMOBILIZE_TIME),a14
	jrnz	arnrepeat
	clr	a14
	move	a14,*a13(IMMOBILIZE_TIME)
	move	a14,*a13(I_WILL_DIE)
	SETMODE	DEAD

	calla	clear_lifebar
	jruc	arndead


arnnotded	;since we're not dead, set mode onground, just to be safe
	movi	MODE_ONGROUND,a14
	move	a14,*a13(PLYRMODE)

	move	*a13(IMMOBILIZE_TIME),a0
	jrnz	arnrepeat

	move	*a13(GETUP_TIME),a0
	jrnz	arnrepeat

arnroll	;clear stars
	clr	a0
	move	a0,*a13(STARS_FLAG)

	calla	do_roll
	jrz	arngetup

arnrepeat	;come back again next tick.
	clr	a0
	move	a0,*a13(Z_BOUND)
	movk	1,a0
	move	a0,*a10(OANICNT)
	rets

arngetup	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1

arndead	;if player, change anim to xxx_dead_anim.
	;if drone, figure out if we should become a zombie or not.
	; if so, set it and roll up until we can't roll no more.  Then the
	;	mode_dead code takes over so we don't worry about it here.
	; if not, change to xxx_dead_anim.
	move	*a13(PLYR_TYPE),a14
	cmpi	PTYPE_PLAYER,a14
	jreq	arndie

	;drone.
	calla	is_8_on_1
	jrc	arnfin
	move	@royal_rumble,a14
;	jrnz	arnnolife
	jrnz	arnrlife
	jruc	arndie


arnrlife	;royal rumble.  give the human team some life
	movk	4,a0
	clr	a1
	calla	adjust_health
	jruc	arnnolife

arnfin	;this is the final match.
	; see if there's another guy in the hopper.
	; if there is, store his number and become a zombie.

	;first, tho, give the guy who killed us some life.
	move	@PSTATUS2,a1
	dec	a1

	;but not if he's already dead!
	move	a1,a0
	X32	a0
	addi	process_ptrs,a0
	move	*a0,a0,L
	move	*a0(PLYRMODE),a14
	cmpi	MODE_DEAD,a14
	jreq	arnnolife

	movk	8,a0
	calla	adjust_health

arnnolife
	move	@FINAL_PTR,a0,L
	movb	*a0,a1
	jrn	arndie			;no more guys

	;okay, become a zombie.  set our zombie flag, store our new number
	; in NEW_WRESTLERNUM, increment FINAL_PTR, and clear our ZOMBIE_TIME.
	addk	8,a0
	move	a0,@FINAL_PTR,L

	;7-08H hack
	cmpi	7,a1
	jrne	arnvok
	movk	8,a1
arnvok	move	a1,*a13(NEW_WRESTLERNUM)
	move	*a13(STATUS_FLAGS),a14
	ori	M_ZOMBIE,a14
	move	a14,*a13(STATUS_FLAGS)

	clr	a14
	move	a14,*a13(ZOMBIE_TIME)

	;kill our specials
	calla	kill_smove_procs

	;if we're right up against either Z edge of the ring, move away
	; a few pixels so we can roll.
	move	*a13(OBJ_ZPOSINT),a14
	cmpi	RING_TOP+7,a14
	jrle	arnmvdn
	cmpi	RING_BOT-7,a14
	jrle	arnzombie

	;move up a few
	subk	7,a14
	move	a14,*a13(OBJ_ZPOSINT)
	jruc	arnzombie

arnmvdn	;move down a few
	addk	7,a14
	move	a14,*a13(OBJ_ZPOSINT)

arnzombie	movi	J_UP,a14
	move	a14,*a13(DRN_JOY)
	move	a14,*a13(STICK_VAL_CUR)
	jruc	arnroll

arndie	movi	xxx_dead_anim,a14
	move	a14,*a10(OANIBASE),L
	move	a14,*a10(OANIPC),L
	jruc	_next_command

********
_ani_setoppfacing	;85

	move	*a13(ATTACH_PROC),a0,L
	jrz	qandone
	move	*a0(ATTACH_PROC),a14,L
	jrz	qandone

	move	*a0(NEW_FACING_DIR),a14
	move	a14,*a0(FACING_DIR)

qandone
	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1

********
_ani_ifopp		;86

;	.word	ANI_IFOPP,wrestler1,wrestler2,...,wrestler3,-1
; sets STATUS if opponent is one of the wrestlers in the list, else clears.

	move	*a13(CLOSEST_NUM),a11
	X32	a11
	addi	process_ptrs,a11
	move	*a11,a11,L

	move	*a11(WRESTLERNUM),a11

	;clear mode_status
	move	*a13(ANIMODE),a0
	andni	MODE_STATUS2,a0
	move	a0,*a13(ANIMODE)

	;compare loop
tbeloop
	move	*a4+,a0,W
	jrn	tbedone
	cmp	a0,a11
	jrne	tbeloop

	;hit.  set mode_status
	move	*a13(ANIMODE),a0
	ori	MODE_STATUS2,a0
	move	a0,*a13(ANIMODE)

	;run off the rest of the list
tberunoff
	move	*a4+,a14
	jrnn	tberunoff

tbedone
	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1

********
_ani_snot	;87

	move	a4,a0
	addi	32+4*16,a0		;LWWWW
	move	a0,*a10(OANIPC),L

	push	a10
	clr	a1		;proc ID
	move	*a4+,a7,L	;wake address
	move	a4,a8		;* arguments
	move	a13,a11
	calla	GETPRC
	pull	a10

	jruc	_next_command

********
_ani_if_butcount_ge	;88

	STRUCT	0
	WORD	ijqBUTTON
	WORD	ijqBUTCNT
	LONG	ijqADDR
	LABEL	ijqSIZE

	move	a4,a14
	addi	ijqSIZE,a14
	move	a14,*a10(OANIPC),L

	move	*a4(ijqBUTTON),a14
	add	a13,a14
	move	*a14,a14		;button count
	move	*a4(ijqBUTCNT),a0
	cmp	a0,a14			;ijqof presses needed to repeat
	jrlt	ijqfail

	move	*a4(ijqADDR),*a10(OANIPC),L	;take branch
ijqfail
	jruc	_next_command


*********
_ani_if_butcount_lt	;89

	move	a4,a14
	addi	ijqSIZE,a14
	move	a14,*a10(OANIPC),L

	move	*a4(ijqBUTTON),a14
	add	a13,a14
	move	*a14,a14		;button count
	move	*a4(ijqBUTCNT),a0
	cmp	a0,a14			;ijqof presses needed to repeat
	jrge	ijqfail2

	move	*a4(ijqADDR),*a10(OANIPC),L	;take branch
ijqfail2
	jruc	_next_command

********
_ani_if_rptcount	;90

	STRUCT	0
	LONG	xkxADDR
	LABEL	xkxSIZE

	move	a4,a14
	addi	xkxSIZE,a14
	move	a14,*a10(OANIPC),L

	move	*a13(RPT_COUNT),a14
	jrz	xkxfail

	move	*a4(xkxADDR),*a10(OANIPC),L	;take branch
xkxfail
	jruc	_next_command

*********
_ani_ifnot_rptcount	;91

	move	a4,a14
	addi	xkxSIZE,a14
	move	a14,*a10(OANIPC),L

	move	*a13(RPT_COUNT),a14
	jrnz	xkxfail2

	move	*a4(xkxADDR),*a10(OANIPC),L	;take branch
xkxfail2
	jruc	_next_command


********
_ani_ringcheck		;92

	;If caller and nearest opponent's INRING values don't match, jump
	; to anxBRANCH

	STRUCT	0
	LONG	anxBRANCH
	LABEL	anxSIZE

	move	a4,a14
	addi	anxSIZE,a14
	move	a14,*a10(OANIPC),L

	move	*a13(CLOSEST_NUM),a11
	X32	a11
	addi	process_ptrs,a11
	move	*a11,a11,L
	move	*a11(INRING),a0
	move	*a13(INRING),a1
	cmp	a0,a1
	jreq	anxdone

	move	*a4(anxBRANCH),a0,L
	move	a0,*a10(OANIPC),L

anxdone
	jruc	_next_command

********

;--> use this in a PUPPET sequence
;this is the same as calling ani_debris except that
;everything is relative to the wrestler attached to me

_ani_debrisat		;93

	move	a4,a14
	addi	5*16,a14
	move	a14,*a10(OANIPC),L

	move	*a13(ATTACH_PROC),a11,L
	jrz	vxkdone
	move	*a11(ATTACH_PROC),a14,L
	cmp	a13,a14
	jreq	db94
vxkdone
	jruc	_next_command


********
_ani_debris		;94

	.ref	react_debris

	move	a4,a14
	addi	5*16,a14
	move	a14,*a10(OANIPC),L
	move	a13,a11
db94

;Stop debris if other smoke is going on!  Bog reduction...
	move	@no_debris,a1
	move	@reduce_bog,a14
	or	a14,a1
	jrnz	_next_command

;Too much bog outside...
	move	*a13(INRING),a1
	jrnz	_next_command

	push	a10
	clr	a1		;proc ID

	movi	react_debris,a7	;wake address
	move	a4,a8		;* arguments
	calla	GETPRC
	pull	a10

	jruc	_next_command


********
_ani_set_wrestler_xflip	;95

	move	*a13(FACING_DIR),a14
	btst	PLAYER_RIGHT_BIT,a14
	jrnz	fccright

	move	*a13(OBJ_CONTROL),a14
	ori	M_FLIPH,a14
	move	a14,*a13(OBJ_CONTROL)

	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1

fccright
	move	*a13(OBJ_CONTROL),a14
	andni	M_FLIPH,a14
	move	a14,*a13(OBJ_CONTROL)

	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1

********
_ani_slideatopp		;96

;	max ticks to slide
;	target velocity
;	max Z distance
;	target area of opponent
;	x,y,z offset of attack box


	STRUCT	0
	WORD	uvsMAX_TICKS
	LONG	uvsVELOCITY
	WORD	uvsMAX_Z_DIST
	WORD	uvsTRGT
	WORD	uvsATT_X_OFF
	WORD	uvsATT_Y_OFF
	WORD	uvsATT_Z_OFF
	LABEL	uvsSIZE


	move	a4,a14
	addi	uvsSIZE,a14
	move	a14,*a10(OANIPC),L

	move	*a13(CLOSEST_NUM),a11
	X32	a11
	addi	process_ptrs,a11
	move	*a11,a11,L

	;make sure both have the same INRING value
	move	*a11(INRING),a0
	move	*a13(INRING),a1
	cmp	a0,a1
	jrne	_next_command

	move	*a11(OBJ_XPOS),a1,L
	move	*a11(OBJ_ZPOS),a2,L
	move	*a11(OBJ_YPOS),a3,L
	addi	[256,0],a3

	move	*a11(OBJ_XVEL),a5,L
	move	*a11(OBJ_ZVEL),a6,L
	move	*a11(OBJ_YVEL),a7,L
	move	*a11(GROUND_Y),a8
	sll	16,a8
	addi	[256,0],a8

	move	*a4(uvsMAX_TICKS),a0

uvslp0
	add	a5,a1			;x + xvel
	add	a6,a2			;z + zvel

	move	a7,a7
	jrz	uvsok

	add	a7,a3			;y + yvel
;;;;	subi	GRAVITY,a7	;yvel - gravity

	cmp	a3,a8		;hit ground?
	jrgt	uvsok
	move	a8,a3
	jruc	uvsdn
uvsok
	dsj	a0,uvslp0
uvsdn
	subi	[256,0],a3

	move	a1,@oppx,L
	move	a2,@oppz,L
	move	a3,@oppy,L

	move	*a4(uvsTRGT),a0
	jrn	uvsuser
	calla	set_target_offsets
uvsuser

	move	*a13(TGT_XOFF),a0	;target x offset
	sll	16,a0
	move	*a11(OBJ_CONTROL),a14
	btst	B_FLIPH,a14
	jrz	uvsright1
	neg	a0
uvsright1
;;;	move	*a11(OBJ_XPOS),a1,L
	move	@oppx,a1,L
	add	a0,a1			;def target x

	move	*a4(uvsATT_X_OFF),a0
	sll	16,a0
	move	*a13(OBJ_CONTROL),a14
	btst	B_FLIPH,a14
	jrz	uvsright0
	neg	a0
uvsright0
	move	*a13(OBJ_XPOS),a2,L
	add	a0,a2			;att x



	move	*a4(uvsVELOCITY),a0,L
	move	*a13(FACING_DIR),a14
	btst	MOVE_RIGHT_BIT,a14
	jrnz	uvspos
	neg	a0			;left
uvspos
	move	a0,*a13(OBJ_XVEL),L


;	move	*a4(uvsMAX_TICKS),a0
;	move	a0,*a10(OANICNT)

	jruc	_next_command


********
_ani_clr_butcount	;97

	move	a4,*a10(OANIPC),L
	clr	a14
;	move	a14,*a13(PUNCHB_COUNT)
;	move	a14,*a13(BLOCKB_COUNT)
;	move	a14,*a13(SPUNCHB_COUNT)
;	move	a14,*a13(KICKB_COUNT)
;	move	a14,*a13(SKICKB_COUNT)

	move	a14,*a13(PUNCHB_COUNT),L
	move	a14,*a13(SPUNCHB_COUNT),L
	move	a14,*a13(SKICKB_COUNT)

;;;	move	a14,*a13(BUT_COUNT)
	jruc	_next_command

********
_ani_set_rptcount	;98

	STRUCT	0
	WORD	sagVAL
	LABEL	sagSIZE

	;If sagVAL is negative, set RPT_COUNT to RND(0-sagVAL)

	move	*a4+,a0
	jrnn	sagset

	neg	a0
	calla	RNDRNG0

sagset	move	a0,*a13(RPT_COUNT)

	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1


********
_ani_dec_rptcount	;99

	move	*a13(RPT_COUNT),a0
	jrz	awbatz
	dec	a0
awbatz
	move	a0,*a13(RPT_COUNT)

	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1

********
_ani_shadowtrail	;100

	STRUCT	0
	LONG	lwfPALETTE
	WORD	lwfRATE
	WORD	lwfLIFESPAN
	LABEL	lwfSIZE

	move	*a4,a0
	jrnz	lwfnot_off

	addi	010h,a4
	move	a4,*a10(OANIPC),L

	move	*a13(SHADTRAIL_PROC),a0,L	;check proc still exists
	jrz	lwfhuh

	calla 	KILL

	clr	a0
	move	a0,*a13(SHADTRAIL_PROC),L	;proc is toast
lwfhuh
	jruc	_next_command




lwfnot_off
	move	a4,a14
	addi	lwfSIZE,a14
	move	a14,*a10(OANIPC),L

	move	@reduce_bog,a14
	jrnz	_next_command

	push	a10

	move	a4,a8			;* arguments
	move	a13,a11			;* wrestler proc

;	move	*a13(PLYRNUM),a0
;	ori	SHADGEN_PID,a0		;proc ID
;	move	a0,a1			;mask
;	calla	EXISTP			;does process already exist?
;	jrz	lwfno_proc

	move	*a13(SHADTRAIL_PROC),a0,L
	jrz	lwfno_proc
					;exists, so restart with new arguments
	move	*a13(PLYRNUM),a1
	ori	SHADGEN_PID,a1		;same proc ID
	movi	shadow_gen,a7		;wake address
	calla	XFERPROC
	jruc	lwfexit

lwfno_proc
	move	*a13(PLYRNUM),a1
	ori	SHADGEN_PID,a1		;proc ID
	movi	shadow_gen,a7		;wake address
	calla	GETPRC
	move	a0,*a13(SHADTRAIL_PROC),L

lwfexit
	pull	a10
	jruc	_next_command



***
;a8  = * arguments
;a11 = * wrestler proc

shadow_gen

lwflp
	move	*a11(SHADTRAIL_PROC),a0,L
	jrz	lwfdie

	move	*a11(CUR_FRAME),a10,L	;* multi-part image

	clr	a1			;proc ID
	movi	shadow_proc,a7		;wake address
	calla	GETPRC			;create proc for piece

;	move	*a10(-10h),a9		;# pieces
;	addi	(17-7)*16,a10		;1st header
	move	*a10(IPCOUNT),a9		;# pieces
	addi	IANI2Y,a10		;1st header
lwfloop
	dec	a9
	jrz	lwfdone
;	addi	7*16,a10
	addi	(ICBZ-IANI2Y),a10

	clr	a1			;proc ID
	movi	shadow_proc,a7		;wake address
	calla	GETPRC			;create proc for piece

	jruc	lwfloop
lwfdone
	move	*a8(lwfRATE),a0
	calla	PRCSLP			;sleep

	jruc	lwflp
lwfdie
	DIE


***
;created from shadow_gen - creates an image, sleeps, delobj & dies
shadow_proc

	move	*a8(lwfLIFESPAN),a9

	movi	Y_SCALE_MULTIPLIER,a0
	move	*a11(OBJ_ZPOSINT),a1
	mpyu	a0,a1
	move	*a11(OBJ_YPOSINT),a0
	sll	16,a0
	sub	a0,a1			;y pos

	move	*a11(OBJ_XPOS),a0,L	;x pos

	move	a10,a2			;* image

	move	*a11(OBJ_PRIORITY),a3,L
	srl	16,a3			;z pos

	move	*a11(OBJ_CONTROL),a4	;DMA flags

	PUSHP	a0,a1,a2,a3,a4
	SLEEP	1
	PULLP	a0,a1,a2,a3,a4

	move	*a8(lwfPALETTE),a5,L
	move	a5,b0			;palette to use

	clr	a5			;object ID
	clr	a6			;x vel
	clr	a7			;y vel
	calla	BEGINOBJP

	move	a9,a0			;lifespan
	calla	PRCSLP			;sleep
;lwfslp
;	move	@PCNT,a1
;	andi	1,a1
;	sll	12,a1
;	move	*a8(OXPOS),a0
;	andi	0fffh,a0
;	or	a1,a0
;	move	a0,*a8(OXPOS)
;	SLEEP	1
;	dsj	a9,lwfslp

	calla	DELOBJA8
	DIE


********
_ani_createproc	;101

	STRUCT	0
	LONG	bogADDR
	WORD	bogPROCID
	WORD	bogWORD1
	WORD	bogWORD2
	WORD	bogWORD3
	LABEL	bogSIZE


	move	a4,a14
	addi	bogSIZE,a14
	move	a14,*a10(OANIPC),L
	move	a13,a11

	push	a10
	move	*a4(bogPROCID),a1	;proc ID
	move	*a4(bogADDR),a7,L	;wake address
	addi	bogWORD1,a4
	move	a4,a8		;* arguments
	calla	GETPRC
	pull	a10

	jruc	_next_command


********
_ani_target	;102

	;sets leapat target to kytTARGET1 or kytTARGET2, depending on the
	; value of kytMODE.
	;ex: ANI_TARGET,TGT_HEAD,TGT_KNEES,ATM_CLOSEST
	;    target the victim's head or victim's knees, whichever
	;    is closest.

	;NOTE: This assumes that victim is on the ground.  If he's
	; not, the results will be screwy.

	STRUCT	0
	WORD	kytTARGET1		;TGT_???
	WORD	kytTARGET2		;TGT_???
	WORD	kytMODE			;ATM_CLOSEST|ATM_FARTHEST
	LABEL	kytSIZE

	move	a4,a14
	addi	kytSIZE,a14
	move	a14,*a10(OANIPC),L


	;first, figure out the orientation of the wrestlers
	calla	get_opp_process
	move	a0,a11

	;see if our flip bits match
	move	*a13(OBJ_CONTROL),a0
	move	*a11(OBJ_CONTROL),a1
	xor	a1,a0
	btst	B_FLIPH,a0

	;if Z is set, the flips match and thus the we're facing our
	; opponent's feet, thus the kytTARGET with the highest value
	; is closest.  if Z isn't set, the opposite is true.
	jrz	kytfacing_feet
	jruc	kytfacing_head

kytfacing_feet
	move	*a4(kytMODE),a14
	cmpi	ATM_CLOSEST,a14
	jreq	kytchoose_highest
	jruc	kytchoose_lowest

kytfacing_head
	move	*a4(kytMODE),a14
	cmpi	ATM_CLOSEST,a14
	jreq	kytchoose_lowest
	jruc	kytchoose_highest

kytchoose_highest
	move	*a4(kytTARGET1),a0
	move	*a4(kytTARGET2),a1
	cmp	a1,a0
	jrge	kytset
	jruc	kytswitch

kytchoose_lowest
	move	*a4(kytTARGET1),a0
	move	*a4(kytTARGET2),a1
	cmp	a1,a0
	jrle	kytset
	jruc	kytswitch

kytswitch
	move	a1,a0
kytset
	calla	set_target_offsets
	calla	tgt_ground
	jruc	_next_command

********
_ani_hmbwait	;103

	STRUCT	0
	WORD	wfdHIT
	WORD	wfdMISSED
	WORD	wfdBLOCKED
	LABEL	wfdSIZE

	move	a4,a14
	addi	wfdSIZE,a14
	move	a14,*a10(OANIPC),L

	;first check for a block
	move	*a13(HITBLOCKER),a1
	jrz	wfdcheck_hit

	move	*a4(wfdBLOCKED),*a10(OANICNT)
	jrz	_next_command
	rets

	;then for a hit
wfdcheck_hit
	move	*a13(ANIMODE),a14
	btst	MODE_STATUS_BIT,a14
	jrz	wfdMISSED

	move	*a4(wfdHIT),*a10(OANICNT)
	jrz	_next_command
	rets

	;assume a miss
wfdMISSED
	move	*a4(wfdMISSED),*a10(OANICNT)
	jrz	_next_command
	rets

********
_ani_safe_time	;104

	move	*a4+,a0
	move	a0,*a13(SAFE_TIME)

	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1

********
;this won't do anything unless they're attached

_ani_setopp_plyrmode	;105

	move	*a4+,a0
	move	a4,*a10(OANIPC),L

	move	*a13(ATTACH_PROC),a11,L
	move	*a11(ATTACH_PROC),a14,L
	cmp	a13,a14
	jrne	myldone

	move	*a11(PLYRMODE),a14
	cmpi	MODE_DEAD,a14
	jreq	myldone
     
	move	a0,*a11(PLYRMODE)
myldone
	jruc	_next_command

********
;this won't do anything unless they're attached

_ani_xflip_opp		;106

	move	*a13(ATTACH_PROC),a11,L
	move	*a11(ATTACH_PROC),a14,L
	cmp	a13,a14
	jrne	ezvdone

	move	*a11(OBJ_CONTROL),a0
	xori	M_FLIPH,a0
	move	a0,*a11(OBJ_CONTROL)

ezvdone
	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1

********
;sets a LONG in wrestler PDATA
_ani_setlong	;107

	STRUCT	0
	WORD	yslPDOFF
	LONG	yslLONG
	LABEL	yslSIZE

	move	a4,a14
	addi	yslSIZE,a14
	move	a14,*a10(OANIPC),L

	move	*a4(yslPDOFF),a0
	add	a13,a0
	move	*a4(yslLONG),a1,L
	move	a1,*a0,L

	jruc	_next_command

********
*
_ani_immobilize	;108

	move	*a4+,a0

	move	*a13(PLYR_DIZZY),a1
	jrnz	evdskip
	move	*a13(WHOIHIT),a1,L

	;don't immobilize blockers!
	move	*a1(PLYRMODE),a14
	cmpi	MODE_BLOCK,a14
	jreq	evdskip

	move	a0,*a1(IMMOBILIZE_TIME)

	;clear his velocities too.
	clr	a0
	move	a0,*a1(OBJ_XVEL),L
	move	a0,*a1(OBJ_YVEL),L
	move	a0,*a1(OBJ_ZVEL),L
evdskip
	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1

********
;this flips your opponent based upon flip table
;this won't do anything unless they're attached

_ani_xflip_tbl	;109

	STRUCT	0
	LONG	svzFLIPTBL
	LABEL	svzSIZE

	move	a4,a14
	addi	svzSIZE,a14
	move	a14,*a10(OANIPC),L

	move	*a13(ATTACH_PROC),a11,L
	move	*a11(ATTACH_PROC),a14,L
	cmp	a13,a14
	jrne	svzdone

	move	*a11(WRESTLERNUM),a0
	X16	a0

	move	*a4(svzFLIPTBL),a1,L
	add	a1,a0
	move	*a0,a0
	jrz	svzdone			;no flip

	move	*a11(OBJ_CONTROL),a0
	xori	M_FLIPH,a0
	move	a0,*a11(OBJ_CONTROL)
svzdone
	jruc	_next_command

********
* this sets the vels for a wrestler you're attached to
* x-vel and z-vel are relative to attackers facing dir

	;works on attached proc, or WHOIHIT if there isn't one

_ani_setoppvels		;110

	STRUCT	0
	LONG	jhyXVEL
	LONG	jhyYVEL
	LONG	jhyZVEL
	LABEL	jhySIZE

	move	a4,a14
	addi	jhySIZE,a14
	move	a14,*a10(OANIPC),L

	move	*a13(ATTACH_PROC),a11,L
	move	*a11(ATTACH_PROC),a14,L
	cmp	a13,a14
	jreq	jhyattach_match

	;no attach.  instead do this to WHOIHIT
	move	*a13(WHOIHIT),a11,L

jhyattach_match
	move	*a4(jhyYVEL),*a11(OBJ_YVEL),L

	move	*a4(jhyXVEL),a0,L
	move	*a13(FACING_DIR),a14
	btst	MOVE_RIGHT_BIT,a14
	jrnz	jhyxok			;right
	neg	a0			;left
jhyxok
	move	a0,*a11(OBJ_XVEL),L

	move	*a4(jhyZVEL),a0,L
	btst	MOVE_DOWN_BIT,a14
	jrnz	jhyzok			;down
	neg	a0			;up
jhyzok
	move	a0,*a11(OBJ_ZVEL),L

jhydone
	jruc	_next_command


********
;same as waithitgnd except you pass an offset to add to ground Y
;(so you can make the guy hit the ground sooner)

_ani_waithitgnd2	;111

	STRUCT	0
	WORD	swlOFFSET
	LABEL	swlSIZE


	move	*a13(OBJ_YVEL),a0,L	;must have down velocity
	jrp	swlno_gnd

	;if we're the master and the attach is valid, check and see if
	; our puppet has hit the ground.
	move	*a13(ANIMODE),a14
	btst	MODE_KEEPATTACHED_BIT,a14
	jrz	swlskip_pcheck

	move	*a13(ATTACH_PROC),a0,L
	jrz	swlskip_pcheck		;we're attached?
	move	*a0(ATTACH_PROC),a14,L
	jrz	swlskip_pcheck		;they're attached?
	cmp	a13,a14
	jrne	swlskip_pcheck		;to each other?

	;ah, but if the opponent's MODE_GHOST bit is set, ignore him
	move	*a0(ANIMODE),a14
	btst	MODE_GHOST_BIT,a14
	jrnz	swlskip_pcheck

	move	*a0(OBJ_YPOSINT),a1,W
	move	*a0(GROUND_Y),a2,W
	move	*a4(swlOFFSET),a14
	add	a14,a2
	cmp	a2,a1
	jrle	swlhit_gnd

swlskip_pcheck

	move	*a13(OBJ_YPOSINT),a0
	move	*a13(GROUND_Y),a2
	move	*a4(swlOFFSET),a14
	add	a14,a2
	cmp	a2,a0			;a0-a1
	jrgt	swlno_gnd

swlhit_gnd
	sll	16,a2
	move	a2,*a0(OBJ_YPOS),L

	.REF	SMALL_BOUNCE
	CALLA	SMALL_BOUNCE

	move	a4,a14
	addi	swlSIZE,a14
	move	a14,*a10(OANIPC),L
	jruc	_next_command

swlno_gnd
	movk	1,a0
	move	a0,*a10(OANICNT)	;# ticks to hold cur frame
	rets


********
_ani_set_opp_xvel	;112

;args:	.long (XVEL) .word (MODE)	;if MODE=0  vel is absolute
					;if MODE=1  vel is facing relative
					;if MODE=2  vel is hit relative
					;if MODE=3  vel is new_face relative

	move	a4,a14
	addi	30h,a14
	move	a14,*a10(OANIPC),L

	move	*a13(ATTACH_PROC),a11,L
	move	*a11(ATTACH_PROC),a14,L
	cmp	a13,a14
	jrne	wsrdone

	move	*a4+,a0,L
	move	*a4+,a1
	jrz	wsrabs
	dec	a1
	jrz	wsrface
	dec	a1
	jrz	wsrhit

;new_facing relative
	move	*a13(NEW_FACING_DIR),a14
	btst	MOVE_RIGHT_BIT,a14
	jrnz	wsrabs			;right
	neg	a0			;left
	jruc	wsrabs

wsrhit
;hit relative
	move	*a13(PLYR_HIT_SIDE),a14
	btst	MOVE_RIGHT_BIT,a14
	jrnz	wsrabs			;hit from right

	neg	a0			;hit from left
	jruc	wsrabs
wsrface
	move	*a13(FACING_DIR),a14
	btst	MOVE_RIGHT_BIT,a14
	jrnz	wsrabs			;right
	neg	a0			;left
wsrabs
	move	a0,*a11(OBJ_XVEL),L

wsrdone	jruc	_next_command

********
_ani_set_attach	;113
	move	*a13(WHOIHIT),a0,L
	move	a0,*a13(ATTACH_PROC),L
	move	a13,*a0(ATTACH_PROC),L

	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1

********
_ani_inc_combo_count ;114
	move	*a13(COMBO_COUNT),a0
	inc	a0
	move	a0,*a13(COMBO_COUNT)
	CMPI	8,A0
	JRNE	NO_BESERKER
	MOVI	HES_JUST_GONE_BERSERK,A0
	CALLA	IF_SILENT_ADD_VOICE
NO_BESERKER

	MOVE	*a13(WHOIHIT),A0,L
	JRZ	PROBLEMS_SS
	MOVI	30,A14
	move	a14,*a0(IMMOBILIZE_TIME)
PROBLEMS_SS

	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1

********
_ani_clear_combo_count ;115
	move	*a13(COMBO_COUNT),a0
	jrz	wqustart_combo
	CLR	A0
	move	a0,*a13(COMBO_COUNT)
	MOVE	*a13(ATTACH_PROC),A0,L
	jrnz	wquok
	MOVE	*a13(WHOIHIT),A0,L
	jrnz	wquok
;Fix
	LOCKUP
wquok
;	MOVE	*A0(GETUP_TIME),A14
;	JRZ	NO_WORRIES_MATEY
;Time opponent has to execute combo breaker
	clr	a14
	move	a14,*a0(IMMOBILIZE_TIME)
	MOVE	A14,*A0(GETUP_TIME)
	MOVI	10*60,A14
	MOVE	A14,*A0(DELAY_METER)

	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1

wqustart_combo
;problem here!
;Used to stuff a 1 in COMBO_COUNT.
;Mark now writes a 0 to COMBO_COUNT,
;Jake now skips the write altoghter.
;which is correct?
;	movk	1,a0
	clr	a0
	move	a0,*a13(COMBO_COUNT)
	MOVE	*a13(ATTACH_PROC),A0,L
	jrnz	wquok2
	MOVE	*a13(WHOIHIT),A0,L
	jrnz	wquok2
;Fix
	LOCKUP
wquok2
;	MOVE	*A0(GETUP_TIME),A14
;	JRZ	NO_WORRIES_MATEY
;Time opponent has to execute combo breaker
	MOVI	80,A14
	move	a14,*a0(IMMOBILIZE_TIME)
	move	@PCNT,a14
	move	a14,*a0(ANTI_COMBO_TIME)		;Time stamp
	CLR	A14
	MOVE	A14,*A0(GETUP_TIME)
;NO_WORRIES_MATEY
	MOVI	10*60,A14
	MOVE	A14,*A0(DELAY_METER)

	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1


********
_ani_add_move ;116
	move	*a4+,a7
	move	*a4+,a5
	move	*a4+,a6

	MOVE	*A13(WHOIHIT),A0,L
	MOVE	*A0(PLYRMODE),A14
	CMPI	MODE_DEAD,A14
	JREQ	NO_ADD_MORE_JUICE

	mmtm	sp,a0,a4,a8,a10
	calla	ADD_TO_COMBO_COUNT
	mmfm	sp,a0,a4,a8,a10

NO_ADD_MORE_JUICE

	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1

********
;
;if num_ticks is negative then use default value
;
_ani_startattack ;117

	STRUCT	0
	WORD	kzrATT_TYPE
	WORD	kzrNUM_TICKS
	LABEL	kzrSIZE

	move	a4,a14
	addi	kzrSIZE,a14
	move	a14,*a10(OANIPC),L

	move	*a4(kzrATT_TYPE),*a13(ATTACK_TYPE)

	move	*a4(kzrNUM_TICKS),a1
	jrp	kzrok

	movk	30,a1			;default tick count
kzrok
	move	@round_tickcount,a0
	add	a0,a1
	move	a1,*a13(ATTACK_TIME)

	jruc	_next_command

********
_ani_changeanim_tbl	;118

	STRUCT	0
	LONG	aekTABLE
	LABEL	aekEND

	move	*a13(WRESTLERNUM),a0
	X32	a0
	move	*a4(aekTABLE),a14,L
	add	a14,a0
	move	*a0,a0,L

	move	a0,*a10(OANIBASE),L
	move	a0,*a10(OANIPC),L

	jruc	_next_command

********
_ani_if_rptcount_ge	;119

	STRUCT	0
	WORD	ftsVAL
	LONG	ftsADDR
	LABEL	ftsSIZE

	move	a4,a14
	addi	ftsSIZE,a14
	move	a14,*a10(OANIPC),L

	move	*a13(RPT_COUNT),a14
	move	*a4(ftsVAL),a0,W
	cmp	a0,a14
	jrlt	ftsfail

	move	*a4(ftsADDR),*a10(OANIPC),L	;take branch
ftsfail
	jruc	_next_command

********
_ani_if_rptcount_lt	;120

	STRUCT	0
	WORD	uxtVAL
	LONG	uxtADDR
	LABEL	uxtSIZE

	move	a4,a14
	addi	uxtSIZE,a14
	move	a14,*a10(OANIPC),L

	move	*a13(RPT_COUNT),a14
	move	*a4(uxtVAL),a0,W
	cmp	a0,a14
	jrge	uxtfail

	move	*a4(uxtADDR),*a10(OANIPC),L	;take branch
uxtfail
	jruc	_next_command


********
_ani_waithitany	;121
	;holds on current frame until you hit the ground or your opponent.
	;NOTE:  This doesn't use the WAITHITOPP bit.  We poll for a hit,
	; which, now that I think about it, was probably the better way
	; to implement WAITHITOPP anyway...
	;ALSO NOTE:  This doesn't work if you're attached.  People who
	; are attached have no business waiting for a blow to land.

	;have we hit the ground?
	move	*a13(OBJ_YPOSINT),a0
	move	*a13(GROUND_Y),a1
	cmp	a1,a0			;a0-a1
	jrgt	fbvno_gnd

	;hit ground.  make noise and quit.
	calla	SMALL_BOUNCE
	jruc	fbvhit

fbvno_gnd	;have we hit our opponent?
	move	*a13(ANIMODE),a14
	btst	MODE_STATUS_BIT,a14
	jrz	fbvno_hit

fbvhit	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1

fbvno_hit	movk	1,a0
	move	a0,*a10(OANICNT)	;# ticks to hold cur frame
	rets

********
_ani_draw_name	;122

;FIX!!
;This is bog!  Check to see if we want messages before CREATE!
	move	a13,a8
	CREATE	MESSAGE_PID,MOVE_NAME_ANNC
	move	*a4+,a14
	move	a14,*a0(PA10),L

	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1

********
_ani_set_idiot  ;123
	;Allow players off screen on toss outs
	movi	80,a0
	move	a0,@allow_offscrn

	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1

********
_ani_attchimage2 ;124

	STRUCT	0
	LONG	gfvIMAGE
	WORD	gfvXOFF
	WORD	gfvYOFF
	WORD	gfvZOFF
	LABEL	gfvSIZE

;	move	*a4(gfvXOFF),*a13(ATTACHIMG_XOFF)
;	move	*a4(gfvYOFF),*a13(ATTACHIMG_YOFF)

	move	*a4(gfvXOFF),*a13(ATTACHIMG_XOFF),L
	move	*a4(gfvZOFF),*a13(ATTACHIMG_ZOFF)
	move	*a4(gfvIMAGE),a0,L

	addi	gfvSIZE,a4
	jruc	attach_cont69

********
_ani_ground 	;125
	move	*a13(GROUND_Y),a0
	move	a0,*a13(OBJ_YPOSINT)
	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1

********
_ani_rot	;126

	movk	1,a14
	move	a14,*a10(OANICNT)
	rets

********
_ani_scroll_ctrl;127

	STRUCT	0
	WORD	oasY_VAL
	LABEL	oasSIZE

	move	a4,a14
	addi	oasSIZE,a14
	move	a14,*a10(OANIPC),L

	move	*a4(oasY_VAL),a14
	jrn	oascont
	move	a14,*a13(SCROLL_Y)

oascont	move	*a13(STATUS_FLAGS),a14
	ori	M_SCROLL_CTRL,a14
	move	a14,*a13(STATUS_FLAGS)

	jruc	_next_command

********
_ani_clear_climb	;128
	clr	a14
	move	a14,*a13(CLIMBING_THRU)
	inc	a14
	move	a14,*a13(SAFE_TIME)

	move	a4,*a10(OANIPC),L
;	jruc	_next_command
	jruc	_next_command1

********
_ani_opp_face	;129

	move	*a4+,a0
	move	a4,*a10(OANIPC),L

	move	*a13(ATTACH_PROC),a11,L
	move	*a11(ATTACH_PROC),a14,L
	cmp	a13,a14
	jrne	xsjdone

	move	*a11(OBJ_CONTROL),a14
	btst	B_FLIPH,a14
	jrz	xsjno_flip
	xori	MOVE_LEFT|MOVE_RIGHT,a0
xsjno_flip
	move	a0,*a11(FACING_DIR)
xsjdone
	jruc	_next_command

********
_ani_setflag	;129

	move	*a13(STATUS_FLAGS),a14,L
	move	*a4+,a0,L
	or	a0,a14
	move	a14,*a13(STATUS_FLAGS),L
	move	a4,*a10(OANIPC),L
	jruc	_next_command1

*****************************************************************************
* used inside anim commands - doesn't call animate_wrestler
;a0 = * animation script
;a2 = * wrestler process

 SUBR	change_anim_anim

	move	a0,*a2(ANIBASE),L
	move	a0,*a2(ANIPC),L

	movi	GRAVITY,a0		;reset gravity
	move	a0,*a2(OBJ_GRAVITY),L
	clr	a0
	move	a0,*a2(ANIMODE)
	movk	1,a0
	move	a0,*a2(ANICNT)

	rets

*****************************************************************************
;primary animation
;a0 = * animation script

 SUBR	change_anim1

	move	*a13(ANIMODE),a2
	btst	MODE_END_BIT,a2		;if anim has ended, then
	jrnz	change_anim1a		;always restart it

	move	*a13(ANIBASE),a2,L
	cmp	a0,a2
	jreq	qctno_change

 SUBR	change_anim1a

	move	a0,*a13(ANIBASE),L
	move	a0,*a13(ANIPC),L

	clr	a0
	move	a0,*a13(ANIMODE)
	movk	1,a0
	move	a0,*a13(ANICNT)

	movi	GRAVITY,a0		;reset gravity
	move	a0,*a13(OBJ_GRAVITY),L
	callr	animate_wrestler1

qctno_change
	rets

*****************************************************************************
;secondary animation
;a0 = * animation script

 SUBR	change_anim2

	move	*a13(ANIMODE2),a2
	btst	MODE_END_BIT,a2		;if anim has ended, then
	jrnz	change_anim2a		;always restart it

	move	*a13(ANIBASE2),a2,L
	cmp	a0,a2
	jreq	vaono_change

 SUBR	change_anim2a

	move	a0,*a13(ANIBASE2),L
	move	a0,*a13(ANIPC2),L

	clr	a0
	move	a0,*a13(ANIMODE2)
	movk	1,a0
	move	a0,*a13(ANICNT2)

	callr	animate_wrestler2

vaono_change
	rets

*****************************************************************************

 SUBR	slaveanim_tbl

 .long wres_slave_anim	;Bret
 .long wres_slave_anim	;Razor
 .long wres_slave_anim	;Taker
 .long wres_slave_anim	;Yokozuna
 .long wres_slave_anim	;Shawn
 .long wres_slave_anim	;BamBam
 .long wres_slave_anim	;Doink
 .long wres_slave_anim	;Adam
 .long wres_slave_anim	;Lex


 SUBR	wres_slave_anim

	.word	ANI_SETMODE,MODE_UNINT+MODE_NOAUTOFLIP+MODE_NOGRAVITY
	.word	ANI_ZEROVELS
	.word	ANI_SETSPEED,100h
	.word	ANI_END

*****************************************************************************

 SUBR	set_images

	PUSH	a13

	movi	process_ptrs,a1
	movi	NUM_WRES,a2
sjoslp
	move	*a1+,a13,L
	jrz	sjoskp_mtp
	PUSH	a1,a2
	callr	sjoset_image
	PULL	a1,a2
sjoskp_mtp
	dsj	a2,sjoslp

	PULL	a13
	rets


sjoset_image

;	CLR	A5
;	MOVE	A5,*A13(SCREENY)

	move	*a13(OBJ_ZPOS),a0,L
	ori	[01000h,0],a0
	move	*a13(INRING),a14
	jrz	sjoinring
	cmpi	[015ach,0],a0
	jrgt	sjoinring

	subi	[01e5h,0],a0		;below mat
sjoinring
	move	a0,*a13(OBJ_PRIORITY),L


	move	*a13(OBJ_XPOS),a5,L	;x val

	movi	Y_SCALE_MULTIPLIER,a0
	move	*a13(OBJ_ZPOSINT),a1
	mpyu	a0,a1
	move	a1,a6			;y val

	move	*a13(OBJ_BASE),a3,L


	move	a3,a0
	movk	MAX_PIECES,a1
	movi	[-100,0],a14		;set all images offscreen
	move	*a13(OBJ_PRIORITY),a2,L
	clr	a7
sjolp
	move	*a0+,a8,L
	move	a7,*a8(OSAG),L
	move	a14,*a8(OXVAL),L
	move	a6,*a8(OYVAL),L		;keep updating YVAL to keep priorities
	move	a2,*a8(OZVAL),L
	dsj	a1,sjolp

;	move	*a13(OBJ_CONTROL),a7	;flip bits & pixel ops
;	andni	00111b,a7
;	movi	DMAWNZ,a0
;	andi	01111b,a0
;	or	a0,a7

	move	*a13(OBJ_CONTROL),a7	;flip bits & pixel ops
	andi	0110000b,a7
	ori	DMAWNZ,a7

	clr	a10			;x offset
	move	*a13(GROUND_Y),a11	;y offset


;	move	*a13(CUR_FRAME),a0,L
;	move	*a0(12*16),a0		;shadow index
	clr	a0			;<------temp!!!!!!
	move	a0,*a13(PLYR_SHADOW)
;	X32	a0
;	addi	shadows,a0
;	move	*a0,a0,L

	movi	shadow,a0

;make shadow low priority

	move	*a13(OBJ_PRIORITY),a14,L
	PUSH	a14

	movi	[013c8h,0],a14		;inside ring
	move	*a13(INRING),a1
	jrz	sjoin
	movi	[0106Ah,0],a14		;outside ring
sjoin
	move	a14,*a13(OBJ_PRIORITY),L

	callr	sjoplot_object		;plot shadow
	PULL	a14
	move	a14,*a13(OBJ_PRIORITY),L

	move	*a8(OXPOS),a0

	move	*a13(ANIMODE),a14
	btst	MODE_NOSHADOW_BIT,a14
	jrz	sjoshadow_on
	clr	a0
sjoshadow_on
	andni	1,a0
	move	@PCNT,a1
	andi	1,a1
	or	a1,a0
	move	*a8(OYPOS),a1
	andi	1,a1
	xor	a1,a0
	move	a0,*a8(OXPOS)		;shake shadow

	;leave him off if in mode_invisible
	move	*a13(ANIMODE),a14
	btst	MODE_INVISIBLE_BIT,a14
	jrnz	sjodone2


	move	*a13(OBJ_CONTROL),a7	;flip bits & pixel ops
	andi	0111111b,a7


	clr	a10			;x offset
	move	*a13(OBJ_YPOSINT),a11	;y offset


	move	*a13(CUR_FRAME),a0,L
	callr	sjoplot_object		;image

	move	*a13(OBJ_PAL),a1
	move	a1,*a8(OPAL)

;	move	*a0(-10h),a4		;# pieces
	move	*a0(IPCOUNT),a4		;# pieces

	.if DEBUG
	.bss	part_count,16
	;part count check
	move	a4,@part_count
	.endif

;	addi	(13+4-7)*16,a0		;1st header
	addi	IANI2Y,a0		;1st header
sjoloop1
	dec	a4
	jrz	sjodone1
;	addi	7*16,a0
	addi	(ICBZ-IANI2Y),a0
	callr	sjoplot_object		;image

	move	*a13(OBJ_PAL),a1
	move	a1,*a8(OPAL)

	jruc	sjoloop1
sjodone1

	move	*a13(CUR_FRAME),a9,L
	move	*a9(IANI2X),a14,L		;secondary X & Y
	inc	a14				;should be 0
	jrz	sjono_2nd_piece

	move	*a9(IANIOFFX),a10		;display x offset
	move	*a9(IANI2X),a14			;secondary X
	sub	a14,a10

	move	*a9(IANIOFFY),a1		;display y offset
	move	*a9(IANI2Y),a14			;secondary Y
	sub	a14,a1
	add	a1,a11

	move	*a13(CUR_FRAME2),a0,L
	callr	sjoplot_object

	move	*a13(OBJ_PAL),a1
	move	a1,*a8(OPAL)

;	move	*a0(-10h),a4		;# pieces
	move	*a0(IPCOUNT),a4		;# pieces

	.if DEBUG
	;part count check
	move	@part_count,a14
	add	a4,a14
	cmpi	5,a14
	jrle	sjookay
	LOCKUP	;too many pieces!!!
sjookay
	.endif

;	addi	(13+4-7)*16,a0		;1st header
	addi	IANI2Y,a0		;1st header
sjoloop2
	dec	a4
	jrz	sjodone2
;	addi	7*16,a0
	addi	(ICBZ-IANI2Y),a0
	callr	sjoplot_object		;image

	move	*a13(OBJ_PAL),a1
	move	a1,*a8(OPAL)

	jruc	sjoloop2

sjono_2nd_piece
	movi	MODE_END,a0		;don't bother animating
	move	a0,*a13(ANIMODE2)	;if no 2nd piece

sjodone2

;	move	a13,a3
;	addi	ATTACH_IMG1,a3
;	movk	4,a4
;sjoattloop
;	move	*a3+,a8,L
;	jrz	sjoskip

;set the x,y & z of image
;;	LOCKUP

	move	*a13(ATTIMG_IMG),a8,L
	move	*a13(ATTIMG_CUR_FRAME),a0,L
	jrnz	sjoonscr

	move	a0,*a8(OXVAL),L
	movi	[-100,0],a0			;set all images offscreen
	move	a0,*a8(OYVAL),L
	rets

sjoonscr
	move	*a13(ATTIMG_LAST_FRAME),a1,L
	cmp	a0,a1
	jreq	sjono_change

;image has just changed

	move	*a13(ATTIMG_IMG),a8,L
	move	a0,*a8(OIMG),L
	move	*a0(0),*a8(OSIZE),L
	move	*a0(ISAG),*a8(OSAG),L

	.if 1
	move	*a0(ICMAP),a0,L

	.ref	pal_getf
	calla	pal_getf
;;;	calla	pal_find
	jrnz	sjoAOK

	LOCKUP	;can't get palette

sjoAOK
	move	a0,*a8(OPAL)
	.endif
	move	*a8(OIMG),a0,L
	movb	*a0(ICTRL+7),*a8(OCTRL+7)	;Write 5 z comp bits + bits pp

	move	*a13(OBJ_CONTROL),a7	;flip bits & pixel ops
	andi	0111111b,a7
	setf	6,0,0
	move	a7,*a8(OCTRL)			;Write 6 low bits
	setf	16,1,0

	move	*a13(OBJ_CONST),*a8(OCONST)

	move	*a13(ATTIMG_CUR_FRAME),*a13(ATTIMG_LAST_FRAME),L

sjono_change
	clr	a1
	move	*a13(ATTACHIMG_XOFF),a0
	move	*a13(OBJ_CONTROL),a14
	btst	B_FLIPH,a14
	jrz	sjono_flip
	movi	M_FLIPH,a1
	neg	a0
sjono_flip
	sll	16,a0
	add	a5,a0
	move	a0,*a8(OXVAL),L

	move	*a8(OFLAGS),a0
	andni	M_FLIPH,a0
	or	a1,a0
	move	a0,*a8(OFLAGS)

	move	*a13(ATTACHIMG_YOFF),a0
	sll	16,a0
	neg	a0
	add	a6,a0
	move	a0,*a8(OYVAL),L

	move	*a13(OBJ_PRIORITY),a0,L
	move	*a13(ATTACHIMG_ZOFF),a1
	sll	16,a1
	add	a1,a0
	move	a0,*a8(OZVAL),L

	move	*a13(OBJ_YPOSINT),a11	;y offset
	move	*a8(OIMG),a0,L
	move	*a0(IANIOFFY),a1
	add	a11,a1			;add in Y pos & ani-offset
	move	a1,*a8(ODYOFF)		;display y offset

	move	*a0(IANIOFFX),*a8(ODXOFF)

sjoskip
;	dsj	a4,sjoattloop

	rets

sjoplot_object

	move	*a3+,a8,L		;* object

	move	a5,*a8(OXVAL),L
	move	a6,*a8(OYVAL),L

	move	*a13(OBJ_PRIORITY),*a8(OZVAL),L

	move	a0,*a8(OIMG),L
	move	*a0(0),*a8(OSIZE),L
	move	*a0(ISAG),*a8(OSAG),L

	move	*a0(IANIOFFX),a1
	add	a10,a1				;add in X ani-offset (if any)
	move	a1,*a8(ODXOFF)			;display x offset

	move	*a0(IANIOFFY),a1
	add	a11,a1				;add in Y pos & ani-offset
	move	a1,*a8(ODYOFF)			;display y offset

	movb	*a0(ICTRL+7),*a8(OCTRL+7)	;Write 5 z comp bits + bits pp

	setf	6,0,0
	move	a7,*a8(OCTRL)			;Write 6 low bits
	setf	16,1,0

	move	*a13(OBJ_CONST),*a8(OCONST)

	rets


*****************************************************************************



shadows
	.ref	shadow
	.long	shadow


******************************************************************************

	.end

