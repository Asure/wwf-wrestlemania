	.file	"audit.asm"
	.title	"audits and ajustments handling"
	.width	132
	.option	b,d,l,t
	.mnolist


	.include	"mproc.equ"		;mproc equates
	.include	"display.equ"		;display proc. equates
	.include	"sys.equ"		;z unit system equates
	.include	"gsp.equ"
	.include	"game.equ"
	.include	"link.equ"		;link equates
	.include	"menu.equ"		;menu equates
	.include	"audit.equ"
	.include	"macros.h"
	.include	"sound.h"

	.include	"fontsimg.glo"
	.include	"miscimg.glo"
	.include	"bgndtbl.glo"
	.include	"imgtbl.glo"


			
	.BSS	BAD_AUD		,16	;(BAD_AUD...NOT BAD_DOG!)	
	.bss	playtimer	,16	;timer units for game
	.BSS	C_FRAC		,16	;TIME 10 SECONDS TO
					;INDICATE COIN ACTIVITY
	.BSS	C_FLAGS		,5*32	;INTERRUPT COIN BOUNCE
	.BSS	COINCNTR	,32	;MECH COIN COUNTER TIMERS AND COUNTS	
COINCNT1	.EQU	COINCNTR
COINCNT2	.EQU	COINCNTR+8
	.BSS	OCT_FLG,16		;!0=Did 1st part
	BSSX	THIS_GAME_TIME,16

	BSSX	audit_ud_flag,16	;audit_ud process active (EXISTP is
					; too slow and we check this often.)

			
	.def	ADJ_PAGE
	.def	BAD_AUD
	.def	C_FRAC,COINCNTR			
	.def	C_FLAGS
	.def	L_MESS,AUD,AUD1,GET_ADJ
	.def	GET_AUD,SLAM_SW,STORE_AUDIT
	.def	CAT_A0
	.def	CCCC
	.def	CK_MAX
	.def	CLR_AUD,FAC_SET
	.def	CLR_AUDR
	.def	CMOS_VAL
	.def	COIN_PAG
	.def	CR_STRTP
	.def	CR_CONTP
	.def	CRD_SCRN
	.def	CRED_P	
	.def	DEF_PAGE
	.def	FORM_ADC
	.def	F_ADC_S
	.def	GET_CREDITS
	.def	GET_CSTR
	.def	HTOHXASC
	.def	L_TIMER
	.def	LD_CTAB
	.def	LM_SETUP
	.def	LM_FINIS
	.def	NO_CREDS
	.def	P_START
	.def	P_CONT	
	.def	PUT_ADJ
	.def	ROM_NAME
	.def	STRCAT
	.def	UNIT_CLR
	.def	WAIT_MUT
	.DEF	KILL_AUD
	.ref	PCNT

	.def	CCOIN,RCOIN,SERVICE,XCOIN,LCOIN
	.DEF	DBV

	.ref	osgemd_ascii,ogmd10_ascii,wgsf24_ascii
	.ref	mess_cursy
	.ref	mess_line_spacing

	.ref	print_message,setup_message
	.ref	print_string_C,print_string_C2
	.ref	dec_to_asc
	.ref	copy_string,copy_rom_string
	.ref	concat_string,concat_rom_string
	.ref	BAKMODS
	.ref	BGND_UD1
	.ref	COUNTER_MODE

	.GLOBAL	SYNCHALF,WDOGDIS,GAMSTATE

	.ref	IRQSKYE
	.ref	PSTATUS,PSTATUS2
	.ref	attract_mode


	.ref	_coin_addr
	.ref	_dipswitch_addr

	;from DCSSOUND.ASM
	.ref	triple_sound

	.REF	PSTARTS


	.ref		SET_PAGE
	.ref		P_FORK
	.ref		DEC_HSR
	.ref		RC_BYTEI
	.ref		RC_BYTE
	.ref		RC_WORD
	.ref		RC_LONG
	.ref		RC_LONGI
	.ref		WC_BYTE
	.ref		WC_BYTEI
	.ref		WC_WORD
	.ref		WC_WORDI
	.ref		WC_LONG
	.ref		WC_LONGI


	.ref		GET_CSPT
	.ref		STR_OBJ
	.ref		STR_FREE
	.ref		CKPROMPT
	.ref		TWO_TS,TWO_TP
	.ref		BUILD_ST
	.ref		HID_P


	.ref		WIPEOUT



	.ref	FORM_SWS
	.ref	opmsg_clr




	.ref	dirqtimer
	.ref	SOUNDSUP
	.ref	RD15FONT,RD7FONT,STRCNRM
	.ref	STRNGRAM,STRLNRM,HEXTOASC
	.ref	CLR_SCRN
	.ref	KILALL
	.ref	SUCIDE
	.ref	dpageflip
	.ref	TAMPEREDP
	.ref	_switch_addr


	.text



L_TIMER
	move	@GAMSTATE,a0
	cmpi	INAMODE,a0
	jrne	omrjNO_CK_OCTO 		;ATTRACT MODE..CHECK OCTOPUS!

	move	@_switch_addr,a0,L
	move	*a0,a0
	not	a0
	andi	07f7fH,a0		;Get sticks 'n starts
	move	@OCT_FLG,a1
	jrgt	omrjp2			;Got part one?

	cmpi	07171H,a0		;P1&P2 all buts down & both sticks up
	jrne	omrjNO_CK_OCTO			;Wrong?
	movi	TSEC,a1			;One sec to get part two
omrjp2
	subk	1,a1
	move	a1,@OCT_FLG
	jrgt	omrjNO_CK_OCTO			;Still counting?
	cmpi	0202H,a0
	jrne	omrjNO_CK_OCTO			;Wrong?

	movi	ACTIVE,a13
	movi	AMODE_PID,a1
	.ref	octopus_page
	movi	octopus_page,a7
	calla	GETPRC
omrjNO_CK_OCTO 		;ATTRACT MODE..CHECK OCTOPUS!

	move	@dirqtimer,a1		;get elapsed time
	move	@playtimer,a0		;get play timer
	sub	a1,a0			;add elapsed time
	move	a0,@playtimer
	jrgt	omrjnot5			;Under 5 seconds?

	CREATE	AUDIT_UD_PID,audit_ud

	movi	TSEC*5,a0		;reset the countdown
omrjnot5
	move	a0,@playtimer
	rets


 SUBRP	audit_ud

	movi	1,a14
	move	a14,@audit_ud_flag

	move	@GAMSTATE,a14
	jrn	omrjskip			;in diagnostics

	move	@PSTATUS2,a14
	jrz	omrjskip			;no players

	movi	AUD_1PLAYTIME,a0	;update the 1/2P time
	cmpi	3,a14
	jrne	omrj1pmode
	movi	AUD_2PLAYTIME,a0
omrj1pmode
	callr	AUD1
	MOVE	@PSTATUS2,A14
	JRZ	NO_NEED_TO_DO_ANYTHING
	CMPI	3,A14
	JREQ	BETTER_STOP_THIS
	MOVE	@PSTARTS,A0
	JRZ	NO_NEED_TO_DO_ANYTHING
	MOVE	@THIS_GAME_TIME,A0
	INC	A0
	MOVE	A0,@THIS_GAME_TIME
	JRUC	NO_NEED_TO_DO_ANYTHING
BETTER_STOP_THIS
	CLR	A0
	MOVE	A0,@PSTARTS
	MOVE	A0,@THIS_GAME_TIME
NO_NEED_TO_DO_ANYTHING
	SLEEPK	1

	movi	AUD_PLTIME,a0
	callr	AUD1

	SLEEPK	1
omrjskip
	movi	AUD_UPTIME,a0		;update the total uptime
	callr	AUD1

	clr	a14
	move	a14,@audit_ud_flag

	DIE


 .if 0


	move	@PSTATUS2,a2
	jrz	omrjaudup

	move	@GAMSTATE,a2
	jrn	omrjaudup

	movi	AUD_1PLAYTIME,a0	;update the 1/2P time
	cmpi	3,a2
	jrne	omrj1pmode
	movi	AUD_2PLAYTIME,a0
omrj1pmode
	callr	AUD1

	movi	AUD_PLTIME,a0
	callr	AUD1

omrjaudup
	movi	AUD_UPTIME,a0		;update the total uptime
	callr	AUD1

	movi	TSEC*5,a0		;reset the countdown

omrjnot5
	rets

 .endif



SERVICE
	move	@GAMSTATE,a0
	jrn	ihfbx 			;In diagnostics?

	move	@_coin_addr,a0,L	;Get COIN inputs
	move	*a0,a0
	btst	CDI_BIT,a0		;Coin Door Closed ?
	jrz	ihfbx			;Yes - Then NO Service Credits Allowed

	callr	CCCC			;MAKE SURE THINGS ARE IN TACT

	movk	AUDSERV,a0
	callr	AUD1			;CHALK UP A SERVICE CREDITS!

	callr	getcoin

	callr	GET_CREDITS
	addk	1,a0			;Add in the new ones
	callr	PUT_CREDITS		;NOW STORE EM BACK (ENFORCE MAX)

	callr	FORM_COIN_CKSUM_AND_STORE

	;Update little credit message
	.ref	update_credit_msg
	calla	update_credit_msg

	jruc	CREDSP

ihfbx	DIE



LCOIN	MOVK	ADJLMULT,A8	;CMOS RAM ADJUST
	MOVI	LC_FLAG,A10	;LEFT COIN FLAG
	MOVI	AUDLCOIN,A11	;AUDIT NUMBER
	JRUC	VALID_COIN

CCOIN	MOVK	ADJCMULT,A8
	MOVI	CC_FLAG,A10	;CENTER COIN FLAG
	MOVI	AUDCCOIN,A11
	JRUC	VALID_COIN

RCOIN	MOVK	ADJRMULT,A8
	MOVI	RC_FLAG,A10	;RYTE COIN FLAG
	MOVI	AUDRCOIN,A11
	JRUC	VALID_COIN

XCOIN	MOVK	ADJXMULT,A8
	MOVI	XC_FLAG,A10	;XTRA (FOURTH) COIN FLAG
	MOVI	AUDXCOIN,A11
	JRUC	VALID_COIN

DBV	MOVK	ADJDBVMULT,A8
	MOVI	DBV_FLAG,A10	;XTRA (FOURTH) COIN FLAG
	MOVI	AUD_DBV,A11
	JRUC	VALID_COIN
LC_FLAG 	.EQU	C_FLAGS		;UHB LEFT COIN
RC_FLAG 	.EQU	C_FLAGS+8	;UHB RGT   "
CC_FLAG 	.EQU	C_FLAGS+16	;UHB CNTR  "
XC_FLAG 	.EQU	C_FLAGS+24	;UHB XTRA  "
DBV_FLAG 	.EQU	C_FLAGS+32	;UHB DOLLAR BILL VALIDATOR  

VALID_COIN
	move	@GAMSTATE,a0
	jrn	CRX			;In diagnostics?

	MOVE	A8,A0			;MOVE MULTIPLIER ADJUST NUMBER TO A0
	CALLA	GET_ADJ 		;FETCH IT
	MOVE	A0,A8			;AND BACK TO STATIC REG...ANY THERE?
	JRZ	CRX			;NOPE....DON'T WASTE THE TIME!

	CALLR	SLAM_P			;SLAM AROUND?
	JRNZ	CRX			;THEN NO ACTION
	MOVI	LC_PID,A0		;ALL 4 SLOTS USE THIS ID NOW
	MOVE	A0,*A13(PROCID)		;SET OUR ID (IN CASE TABLE IS WRONG)

	MOVB	*A10,A0 		;GET FLAG BYTE
	JRNZ	CRX			;SOMEONE ELSE THERE...WE'RE A BOUNCE!


	movk	5,a0			;Wait a few ticks
	movb	a0,*a10

COIN_LOOP
	SLEEPK	1			;SLEEP TILL WE GET SUCCESS OR FAIL
	MOVB	*A10,A0 		;GET THE TIMER
	JRGT	COIN_LOOP

	CALLR	SLAM_P			;SLAM?
	JRNZ	CRX			;THEN WE'RE OUT OF HERE

					
	CLR	A0
	MOVE	A0,@SOUNDSUP		;TURN SOUNDS ON. (A-MODE SOUND SUPRESSOR)

	callr	getcoin

	MOVI	15*40H/8,A0		;DON'T WIPE ON GAME OVER IF ITS WITHIN
	MOVE	A0,@C_FRAC		;15 SECONDS (THIS TIMES OUT TO OVER 20)

	MOVE	A11,A0
	CALLR	AUD1			;CHALK THE DIRECT AUDIT

	MOVE	@COUNTER_MODE,A0,W
	CMPI	1,A0
	JRNE	MECH20

	MOVI	ADJTOTALIZER,A0
	CALLA	GET_ADJ
	JRZ	NORMAL_TOTALIZER
	MOVI	ADJTOTALIZER,A0
	ADD	A11,A0
	CALLA	GET_ADJ
	MOVE	A0,A2
	MOVI	COINCNT1,A1
	JRUC	RE_ENTER_FROM_CUST_TOTALIZER
NORMAL_TOTALIZER

	CALLA	GET_CSPT		;POINT TO COIN TABLE A6

	ADDI	CS_LVAL,A6		;ADD IN OFFSET TO CHUTE VALUES
	DEC	A11			;GET YOUR CLICK COUNT
	SLL	4,A11			;OFFSET FOR CHUTE, WORD CORRECT
	ADD	A11,A6
	MOVE	*A6,A2			;GET MONEY VALUE
	MOVE	A2,A2
	JRZ	MECH10			;SOMETHING ILLEGAL HAPPENED, JUST ONE

RE_ENTER_FROM_CUST_TOTALIZER
	MOVI	COINCNT1,A1
	JRUC	MECH3B
MECH10
	MOVK	2,A0			;VALUE OVER 10, JUST GIVE ONE CLICK
MECH20
	MOVI	COINCNT1,A1
	CMPI	2,A0
	JREQ	MECH3A			;CLICK COUNTER 1 MODE
	
	CMPI	AUDLCOIN,A11
	JREQ	MECH3A
	CMPI	AUDRCOIN,A11
	JRNE	MECH4
	ADDK	8,A1
MECH3A
	MOVK	1,A2
MECH3B
	DINT
	MOVB	*A1,A0
	ADD	A2,A0
	MOVB	A0,*A1
	EINT
MECH4
	MOVE	A8,A8			;NO CREDIT UNITS?
	JRZ	CRX			;THEN NO MORE WORK TO DO.
	CALLR	ADJUST_CREDITS		;GIVE CREDIT FOR THE MONEY.
	CALLR	DEF_PAGE		;POINT PAGE AWAY!


CREDSP

	calla	update_credit_msg

	MOVE	@PSTATUS2,A0
	JRNZ	CRX
	move	@GAMSTATE,a0
	subk	INAMODE,a0		;A DISPLAY IN AMODE ONLY!
	jrne	CRX

CRY	jruc	CRD_SCRN		;PUT UP THE CREDITS SCREEN

CRX	JAUC	SUCIDE






CR_STRTP
	PUSH	a0,a1
	MOVK	ADJFREPL,A0
	CALLR	GET_ADJ 		;ARE WE IN FREE PLAY?
	CMPI	1,A0			;WE ARE IF ITS NOT ZERO.
	JRHS	CR_STX

	CALLR	CCCC			;MAKE SURE THINGS ARE IN TACT
	CALLR	COIN_PAG
	CALLR	GET_CREDITS		;GET CURRENT CREDITS
	MOVE	A0,A1
	MOVK	ADJCSTRT,A0
	CALLR	GET_ADJ 		;GET NUMBER NEEDED
	CMP	A0,A1			;DO WE HAVE ENOUGH TO START?

CR_STX	MMFM	SP,A0,A1
	RETS

CR_CONTP
	PUSH	a0,a1
	MOVK	ADJFREPL,A0
	CALLR	GET_ADJ 		;ARE WE IN FREE PLAY?
	CMPI	1,A0			;WE ARE IF ITS NOT ZERO.
	JRHS	CR_STX1

	CALLR	CCCC			;MAKE SURE THINGS ARE IN TACT
	CALLR	COIN_PAG
	CALLR	GET_CREDITS		;GET CURRENT CREDITS
	MOVE	A0,A1
	MOVK	ADJCCONT,A0
	CALLR	GET_ADJ 		;GET NUMBER NEEDED
	CMP	A0,A1			;DO WE HAVE ENOUGH TO START?
CR_STX1
	MMFM	SP,A0,A1
	RETS

P_START
	MMTM	SP,A0,A1
	CALLR	CRED_P
	MOVE	A0,A1
	MOVK	ADJCSTRT,A0
	CALLR	GET_ADJ 		;GET NUMBER NEEDED
	CALLR	REMOVE_CREDITS
	CALLA	DEC_HSR 		;TAKE 1 FROM HIGH SCORE RESET COUNTER

	calla	update_credit_msg

	MMFM	SP,A0,A1
	RETS

P_CONT
	MMTM	SP,A0,A1
	CALLR	CRED_P
	MOVE	A0,A1
	MOVK	ADJCCONT,A0
	CALLR	GET_ADJ 		;GET NUMBER NEEDED
	CALLR	REMOVE_CREDITS
	CALLA	DEC_HSR 		;TAKE 1 FROM HIGH SCORE RESET COUNTER

	calla	update_credit_msg

	MMFM	SP,A0,A1
	RETS

REMOVE_CREDITS
	SUB	A0,A1			;REMOVE START AMOUNT FROM WHAT WE HAVE
	JRHS	PS1			;WE'RE OK.

	CLR	A1			;IT WENT NEGATIVE....MAKE ZERO.
PS1	CALLR	COIN_PAG
	MOVI	CREDITS,A7
	MOVE	A1,A0			;PUT WHATS LEFT OUT TO WRITE
	CALLA	WC_BYTE 		;WRITE THE NEW AMOUNT

	CALLR	FORM_COIN_CKSUM_AND_STORE
	CALLR	DEF_PAGE		;POINT AT DEFAULT PAGE.
	RETS
		
NO_CREDS
	MMTM	SP,A0,A1,A7
	CALLR	FORM_COIN_CKSUM ;MAKE THE REAL CKSUM
	MOVI	COIN_CKSUM,A7
	MOVE	A1,A0
	INC	A0		;MAKE THE CKSUM BAD!
	CALLA	WC_BYTE
	MMFM	SP,A0,A1,A7
	RETS





ADJUST_CREDITS
	
	MMTM	SP,A0,A1,A2,A3,A4,A5,A6,A7,A8,A9,A10,A11
	CALLR	CK_MAX		;ARE WE AT MAXIMUM CREDITS?
	JRHS	ADCRXX		;YEP.....DON'T ROCK THE BOAT!

	CALLR	CCCC		;VALIDATE THE CURRENT TOTALS (OR CLEAR!)

	CALLR	FETCH_REQ	;GET THE REQUIRED FOR CREDIT, BONUS AND MINIMUM


	CALLR	ADD_TO_CUNITS	;ADD TO OUR CUNITS
	MOVE	A3,A3		;BONUS EFFECTIVE?
	JRZ	NO_BUNITS	;NOPE....DON'T RUN UP THE COUNTER!

	CALLR	ADD_TO_BUNITS	;ADD TO BONUS UNITS

NO_BUNITS
	MOVE	A4,A4		;MINIMUM REQUIRED?
	JRZ	NO_MINIMUM	;NOPE.....LEAVE ALONE.

	MOVI	MINUNITS,A7	;POINT AT MINIMUM
	CALLA	RC_WORD 	;GET THE AMOUNT ACCUMULATED
	ADD	A8,A0		;ADD AMOUNT RECEIVED
	CALLA	WC_WORD 	;WRITE THE MINUNITS BACK IN CASE NOT ENOUGH.

	SUB	A4,A0		;DO WE HAVE ENOUGH TO ACT?
	JRLO	ADCRX		;NOPE....NO CREDITS YET!

	CLR	A0		;CLEAR OUT MINIMUM FOR NEXT SHOT!
	CALLA	WC_WORD 	;REMOVE ACCUMULATED MINIMUM.

NO_MINIMUM
	CLR	A6		;COUNT ACCUMULATED CREDITS IN A6
	CLR	A10		;IN CASE NO BONUS!

	CLR	A8
	MOVI	BUNITS,A7
	CALLA	RC_WORD 	;GET THE NUMBER OF BUNITS
	MOVE	A0,A9		;INTO A9

	MOVE	A3,A3		;DON'T DIVIDE BY ZERO!
	JRZ	NO_BU_BU
	DIVU	A3,A8		;DIVIDE BUNITS BY NUMBER NEEDED FOR BONUS

	MOVE	A9,A0		;WRITE REMAINDER BACK
	CALLA	WC_WORD

	MOVE	A8,A6		;NUMBER OF BONUS CREDITS EARNED.
	MOVE	A8,A10		;REMEMBER IF ANY BONUS CREDITS WERE EARNED!

NO_BU_BU
	CLR	A8
	CALLR	GET_CUNITS	;READ IN THE CUNITS
	MOVE	A0,A9

	MOVE	A2,A2		;DON'T DIVIDE BY ZERO.
	JRZ	NO_CR

	DIVU	A2,A8		;GET CREDITS!
	MOVE	A9,A0		;REMAINDER IS LEFTOVER CUNITS
	CALLR	PUT_CUNITS
	ADD	A8,A6		;A6 HAS WHAT WE'VE WON!

NO_CR
	MOVE	A6,A1
	MOVI	AUDPAIDC,A0
	CALLA	AUD		;CHALK UP THE EARNED CREDITS!

	CALLR	GET_CREDITS
	ADD	A6,A0		;ADD IN THE NEW ONES.
	CALLR	PUT_CREDITS	;NOW STORE EM BACK (ENFORCE MAX)

	MOVE	A10,A10 	;WAS THE BONUS EARNED?
	JRZ	ADCRX		;NOPE...EXIT!
	CALLR	CLEAR_UNITS

ADCRX	CALLR	FORM_COIN_CKSUM_AND_STORE

ADCRXX	MMFM	SP,A0,A1,A2,A3,A4,A5,A6,A7,A8,A9,A10,A11
	RETS

PUT_CREDITS
	MMTM	SP,A0,A6,A7
	CALLR	GET_MAX 	;GET MAX CREDS IN A1....BE ON COIN PAGE
	CMP	A1,A0		;SEE HOW WE STACK UP.
	JRLO	USE_A0		;WE'RE LOWER...JUST STORE.
	CALLR	CLEAR_UNITS	;CLEAR OUT THE UNIT FRACTIONS.
	MOVE	A1,A0		;USE MAXIMUM

USE_A0	MOVI	CREDITS,A7
	CALLA	WC_BYTE 	;WRITE THE CREDITS OUT.
	MMFM	SP,A0,A6,A7
	RETS

GET_MAX
	PUSH	a0
	MOVK	ADJMAXC,A0
	CALLA	GET_ADJ_FOR_COIN	;FETCH MAXIMUM CREDITS (PUT US ON COIN PAGE)
	MOVE	A0,A1
	MMFM	SP,A0
	RETS

CK_MAX
	MMTM	SP,A0,A1
	CALLR	GET_MAX 		;GET MAXIMUM IN A1
	CALLR	CRED_P			;GET CREDITS IN A0 (AND FLIP PAGE AWAY)
	CMP	A1,A0			;JRHS FOR MAXIMUM CREDITS!
	MMFM	SP,A0,A1
	RETS

UNIT_CLR
	PUSH	a0
	MOVE	@C_FRAC,A0			;DO WE GIVE HIM A REPRIEVE?
	JRNZ	UC1				;YEP!
	CALLR	CCCC				;VALIDATE COINAGE
	CALLR	CLEAR_UNITS			;CLEAR OUT FRACTIONAL UNITS
	CALLR	FORM_COIN_CKSUM_AND_STORE	;MAKE ALL GOOD.
UC1
	MMFM	SP,A0
	RETS

CLEAR_UNITS
	MMTM	SP,A0,A7
	CLR	A0
	MOVI	CUNITS,A7		;3 CONSECUTIVE WORDS OF CMOS
	CALLA	WC_WORDI
	CALLA	WC_WORDI
	CALLA	WC_WORD
	MMFM	SP,A0,A7
	RETS


CRED_P
	CALLR	CCCC		;CHECK TO SEE IF DATA IS OK.

GET_CREDITS
	PUSH	a7
	CALLR	COIN_PAG
	MOVI	CREDITS,A7	;
	CALLA	RC_BYTE 	;READ CURRENT CREDITS
	JRNZ	GC1		;WE GOT SOME!

				;PUSH THE ZERO!
	PUSH	a0
	MOVK	ADJFREPL,A0
	CALLR	GET_ADJ 	;SEE IF FREEPLAY......(Z BIT CLEAR IF SO!)
	MMFM	SP,A0		;RESTORE A0

GC1	CALLR	DEF_PAGE	;FLIP CMOS AWAY
	MMFM	SP,A7
	RETS

ADD_TO_CUNITS
	MMTM	SP,A0,A7
	CALLR	GET_CUNITS
	ADD	A8,A0
	CALLR	PUT_CUNITS
	MMFM	SP,A0,A7
	RETS

GET_CUNITS
	PUSH	a7
	MOVI	CUNITS,A7
	CALLA	RC_WORD
	MMFM	SP,A7
	RETS

PUT_CUNITS
	PUSH	a7
	MOVI	CUNITS,A7
	CALLA	WC_WORD
	MMFM	SP,A7
	RETS

ADD_TO_BUNITS
	MMTM	SP,A7,A0
	MOVI	BUNITS,A7
	CALLA	RC_WORD
	ADD	A8,A0
	CALLA	WC_WORD
	MMFM	SP,A7,A0
	RETS



CRD_SCRN

	CLR	a10			;Sleep 7 secs

 SUBR	CRD_SCRN2			;Entry pnt for shorter sleep

	clr	a0
	move	a0,@SHOW_CRD_FLAG
	.ref	SHOW_CRD_FLAG

	MOVI	CP_PID1,A0		;CHANGE TO "CREDIT PAGE" ID 1
	MOVE	A0,*A13(PROCID)
	MOVI	0FFFFH,A1		;CHECK TO SEE IF CREDIT PAGE IS UP
	CALLA	EXISTP
	jrnz	ihfbexists			;credit page up, so reprint text only

	calla	display_blank
	calla	WIPEOUT			;CLEAN SYSTEM OUT

	movk	1,a0			;page flipping on
	move	a0,@dpageflip

	movi	SCRNEND,a0		;[256,405]
	move	a0,@SCRNLR,L

	clr	a0
	move	a0,@WORLDTLX,L
	move	a0,@WORLDTLY,L

	SLEEPK	2

	movi	coinin_mod,a0
	move	a0,@BAKMODS,L
	calla	BGND_UD1

	movk	1,a0
	move	a0,@DISPLAYON		;Display processor on

	callr	crd_updatetxt

	SLEEPK	2

	movi	4<<10+4<<5+7,a0
	move	a0,@IRQSKYE

	SLEEPK	2
	calla	display_unblank

	jruc	ihfbcont


ihfbexists
	move	@HEBLNK,a0
	cmpi	HEBLNKINIT,a0
	jrne	ihfbinscl
	move	@dtype,a0
	jrge	ihfbnotinscl
ihfbinscl	move	a10,a10
	jrnz	KILL_CRD2
	jruc	ihfbdie
ihfbnotinscl
	SLEEPK	3
ihfbcont
	callr	crd_updatetxt		;Display players per credit messages

	movi	HEBLNKINIT,a0			;Display on (just in case)
	move	a0,@HEBLNK


	SLEEP	1*TSEC


	movi	4*TSEC,a11
ihfblp	SLEEPK	1
	.ref	get_all_buttons_cur2
	calla	get_all_buttons_cur2
	jrz	ihfbnob
	movi	bounce_snd,a0
	calla	triple_sound
	move	a10,a10
	jrnz	KILL_CRD2
	jruc	KILL_CRD
ihfbnob
	dsj	a11,ihfblp

ihfbck2
	move	a10,a10
	jrnz	KILL_CRD2

	movi	10*TSEC,a11
ihfblp1	SLEEPK	1
	calla	get_all_buttons_cur2
	jrz	ihfbnob1
	movi	bounce_snd,a0
	calla	triple_sound
	jruc	KILL_CRD
ihfbnob1
	dsj	a11,ihfblp1

KILL_CRD
	calla	display_blank
	calla	WIPEOUT			;CLEAN SYSTEM OUT
	SLEEPK	1

	CREATE	AMODE_PID,attract_mode

ihfbdie	DIE


KILL_CRD2
	RETP

coinin_mod
	.long	slateBMOD
	.word	0,0
	.long	0



 SUBRP	crd_updatetxt

	movi	CP_PID1,a0		;PID
	movi	0ffffh,a1		;mask bits
	calla	KILALL			;kill all CP_PID1 procs except self

	movi	TYPTEXT,a0		;object ID
	clr	a1			;mask
	calla	obj_delc		;delete existing text


	move	@_dipswitch_addr,a0,L
	move	*a0,a0
	btst	6,a0			;UJ2 switch 1
	jrnz	ihfbnotfair		;OFF?


	MOVI	dollar_mes,a2		;Dollar bill message
	calla	print_message
ihfbnotfair

	PUSH	A10
	callr	credits_string
	PULL	A10
	rets


	.asg	25,YSPACE
	.asg	17,YSPACE0

	.asg	40,LN0
	.asg	70,LN1
	.asg	100,LN2
	.asg	130,LN3
	.asg	90,LN3x		;free play y-line
	.asg	160,LN4
	.asg	190,LN5
	.asg	220,LN6


CM_Y_GAP	EQU	13
CM_Y_GAP2	EQU	80
CM_Y_ADDGAP	EQU	[CM_Y_GAP,200]


credits_string

	MOVK	ADJFREPL,A0		;ARE WE IN FREE PLAY?
	CALLA	GET_ADJ
	JRZ	dhzhnot_freeply

	movi	LN3x_setup,a2
	calla	setup_message
	movi	40,a0
	move	a0,@mess_line_spacing
	movi	dhzhstr_freeply,a4
	calla	print_string_C2
	
	rets

dhzhnot_freeply







	calla	GET_CSPT		;a6 = * current pricing table
	movk	2,a10			;min number strings to print
	move	*a6(CS_LIST),a11,L	;a11 = * string list
	jrz	dhzhno_strings

	move	a11,a2
dhzhnext_string
	move	*a2+,a0,L		;count up number of strings
	jrz	dhzhlast
	inc	a10
	jruc	dhzhnext_string
dhzhlast
dhzhno_strings
	callr	CRED_P			;get number credits
	move	a0,a3
	MOVK	ADJCSTRT,A0
	callr	GET_ADJ 		;# credits to start
	divu	a0,a3			;credits / credits to start
	move	a3,a3
	jrz	dhzhnot_enough1
	inc	a10			;+1 string	(READY FOR...)
dhzhnot_enough1



	movi	LN1_setup,a2
	calla	setup_message

	callr	CRED_P			;# credits in a0
	PUSH	a0

	movi	dhzhcrd_str,a4
	calla	copy_rom_string

	PULL	a0
	PUSH	a0
	movi	99,a1			;max string value
	calla	dec_to_asc
	calla	concat_string

	MOVK	ADJMAXC,a0
	calla	GET_ADJ_FOR_COIN 	;a0 = max credits
	PULL	a1
	cmp	a0,a1
	jrlo	dhzhnot_max_crds
	movi	dhzhstr_max,a4		;max credits
	calla	concat_rom_string
dhzhnot_max_crds
	calla	print_string_C		;"CREDITS : NN"



	movi	LN2_setup,a2
	calla	setup_message

	movi	140,a0
	movi	YSPACE0,a1
	mpyu	a10,a1			;# strings * Y spacing
	srl	1,a1			;/2
	sub	a1,a0
	move	a0,@mess_cursy		;centered Y

	calla	TAMPEREDP
	JRZ	dhzhdone

dhzhnext_string2
	move	*a11+,a4,L            	;* next string
	jrz	dhzhdone

	move	@mess_cursy,a0
	addi	YSPACE0,a0
	move	a0,@mess_cursy

	calla	print_string_C2

	jruc	dhzhnext_string2
dhzhdone



	move	@mess_cursy,a0
	addi	YSPACE0,a0
	move	a0,@mess_cursy

	MOVK	ADJCSTRT,a0
	callr	GET_ADJ 		;# credits to start
	PUSH	a0
	movi	99,a1			;max string value
	calla	dec_to_asc
	calla	copy_string

	movi	dhzhcrd_2start,a4
	PULL	a0
	dec	a0
	jrz	dhzh1credit
	movi	dhzhcrd_2starts,a4
dhzh1credit
	calla	concat_rom_string
	calla	print_string_C



	move	@mess_cursy,a0
	addi	YSPACE0,a0
	move	a0,@mess_cursy

	MOVI	ADJCCONT,a0		;# credits to continue
	callr	GET_ADJ
	PUSH	a0
	movi	99,a1			;max string value
	calla	dec_to_asc
	calla	copy_string
	movi	dhzhcrd_2cont,a4
	PULL	a0
	dec	a0
	jrz	dhzh1_creditb
	movi	dhzhcrd_2conts,a4
dhzh1_creditb
	calla	concat_rom_string
	calla	print_string_C


	movi	LN5_setup,a2
	calla	setup_message

	callr	CRED_P			;get number credits
	move	a0,a3

	MOVK	ADJCSTRT,A0
	callr	GET_ADJ 		;# credits to start

	divu	a0,a3			;credits / credits to start
	move	a3,a3
	jrz	dhzhnot_ready
	dec	a3


	cmpi	2,a3
	jrlo	dhzhnot_max
	movi	1,a3

dhzh4_plyrs
dhzhnot_max
	sll	5,a3		;x 32 bits
	addi	dhzhready_for_lookup,a3
	move	*a3,a4,L
	calla	print_string_C2

	movi	dhzhstr_start,a4
	jruc	dhzhready

dhzhnot_ready
	movi	dhzhstr_insert,a4
dhzhready
	move	@mess_cursy,a0
	addi	YSPACE,a0
	move	a0,@mess_cursy

	calla	print_string_C2

	rets



LN1_setup
	JAM_STR	osgemd_ascii,10,0,200,LN1+4,GOLD,0
	.even
LN2_setup
	JAM_STR	ogmd10_ascii,5,0,200,LN2,SGMD8GLD,0
	.even
LN3_setup
	JAM_STR	osgemd_ascii,5,0,200,LN3,GREENPAL,0
	.even
LN3x_setup
	JAM_STR	wgsf24_ascii,8,0,200,LN3x,WGSF_Y_P,0
	.even
LN5_setup
	JAM_STR	osgemd_ascii,10,0,200,LN5+10,GREENPAL,0
	.even
LN6_setup
	JAM_STR	osgemd_ascii,10,0,200,LN6,GOLD,0
	.even

dhzhstr_value
	.string	"BEST VALUE:",0
dhzhstr_fullg1
	.string	"PURCHASE FULL GAMES FOR ONLY ",0
dhzhstr_fullg2
	.string	" CREDITS PER PLAYER!",0
dhzhstr_max
	.string	" (MAXIMUM)",0
dhzhcrd_str
	.string	"CREDITS : ",0
dhzhcrd_2start
	.string	" CREDIT TO START",0
dhzhcrd_2starts
	.string	" CREDITS TO START",0
dhzhcrd_2cont
	.string	" CREDIT TO CONTINUE",0
dhzhcrd_2conts
	.string	" CREDITS TO CONTINUE",0
dhzhstr_freeply
	.string	"FREE  PLAY",1
dhzhstr_start
	.string	"PRESS  START",0
dhzhstr_insert
	.string	"INSERT COINS",0
	.even
dhzhready_for_lookup
	.long	dhzhstr_1p,dhzhstr_2p
	.long	dhzhstr_3p,dhzhstr_4p
dhzhstr_1p	.string	"READY FOR 1 PLAYER",0
dhzhstr_2p	.string	"READY FOR 1 OR 2 PLAYERS",0
dhzhstr_3p	.string	"READY FOR 1 - 3 PLAYERS",0
dhzhstr_4p	.string	"READY FOR 1 - 4 PLAYERS",0
	.even


 .if 0

CM_LINE1  EQU	  CUSTOM_MESSAGE
CM_LINE2  EQU	  CUSTOM_MESSAGE+CMESS_LINE_SIZE
CM_LINE3  EQU	  CUSTOM_MESSAGE+(2*CMESS_LINE_SIZE)



        CALLA   ADJ_PAGE 
        MOVI    VALID_CUSTOM,A7
        CALLA   RC_WORD
        CMPI    VALID_VALUE,A0		; CHECK TO SEE IF MESSAGE IS VALID
	JRNZ	dhzhzippo


	movi	CM_LINE3,A10		;CHECK LINE 3
	callr	CK_LINE 		;3 VALID LINES?
	jrz	GO_FOR_2
	movi	LN2_setup,a2
	calla	setup_message
	movi	STRNGRAM,a4
	calla	print_string_C2
GO_FOR_2
	movi	CM_LINE2,A10		;CHECK LINE 2
	callr	CK_LINE 		;2 VALID LINES?
	jrz	GO_FOR_1
	movi	LN3_setup,a2
	calla	setup_message
	movi	STRNGRAM,a4
	calla	print_string_C2
GO_FOR_1
	movi	CM_LINE1,A10		;CHECK LINE 1
	callr	CK_LINE 		;1 VALID LINES?
	jrz	dhzhzippo
	movi	LN4_setup,a2
	calla	setup_message
	movi	STRNGRAM,a4
	calla	print_string_C2
dhzhzippo
 .endif


	.if 0
HELP_TAB
	.LONG	 L_MESS 		;0 SAYS USE L_MESS
	.LONG	 JUST_LIST		;1 SAYS USE LISTED MESSAGES ONLY
	.LONG	 LINE_ONE_PLUS		;2 SAYS USE 1ST LINE W/ 2 TO START
	.LONG	 LINE_TWO_PLUS		;3
	.LONG	 LINE_THREE_PLUS	;4
	.LONG	 LINE_ONE_PLUS_2	;5 USE 1ST LINE 2/ 2 CREDITS PER PLAYER
	.LONG	 LINE_TWO_PLUS_2	;6
	.LONG	 LINE_THREE_PLUS_2	;7
	.LONG	 OUTPUT_CUSTOM		;8 CUSTOM MESSAGE!

JUST_LIST
	MOVE	A8,A3			;STASH WHERE IT WILL SURVIVE
	MOVE	*A3(LONG_SIZE),A2,L	;ONE WORD ONLY?
	JRZ	JUST_ONE		;YEP....CENTER IT NICELY
	MOVE	*A3(2*LONG_SIZE),A2,L  ;IS THERE A 3RD LINE?
	JRZ	JUST_TWO		;NOPE

	MOVI	SETUP_3_OF_3,A8
	JSRP	SET_THEN_A2

	MOVE	*A3(LONG_SIZE),A2,L	;GET LINE 2

	MOVI	SETUP_2_OF_3,A8
	JSRP	SET_THEN_A2

	MOVI	SETUP_1_OF_3,A8		;SET HEIGHT FOR TOP LINE
	JRUC	FIRST_LINE

JUST_TWO
	MOVE	*A3(LONG_SIZE),A2,L	;GET LINE 2
	MOVI	SETUP_2_OF_2,A8
	JSRP	SET_THEN_A2

	MOVI	SETUP_1_OF_2,A8

FIRST_LINE
	MOVE	*A3,A2,L
	JRUC	SET_THEN_A2		  ;DO TOP LEN AND RETURN

JUST_ONE
	MOVI	SETUP_1_OF_1,A8
	JRUC	FIRST_LINE		  ;DO TOP LEN AND RETURN

CM_LINE1  EQU	  CUSTOM_MESSAGE
CM_LINE2  EQU	  CUSTOM_MESSAGE+CMESS_LINE_SIZE
CM_LINE3  EQU	  CUSTOM_MESSAGE+(2*CMESS_LINE_SIZE)

OUTPUT_CUSTOM
	MOVI	CM_LINE3,A10		;CHECK LINE 3
	CALLR	CK_LINE 		;3 VALID LINES?
	JRZ	GO_FOR_2

	MOVI	SETUP_3_OF_3,A8
	JSRP	SET_THEN_STRNGRAM	;PUT IT OUT

	MOVI	CM_LINE2,A10
	MOVI	SETUP_2_OF_3,A8
	JSRP	SET_THEN_STRNGRAM

	MOVI	CM_LINE1,A10
	MOVI	SETUP_1_OF_3,A8
	JRUC	SET_THEN_STRNGRAM

GO_FOR_2
	MOVI	CM_LINE2,A10		;CHECK LINE 2
	CALLR	CK_LINE 		;2 VALID LINES?
	JRZ	GO_FOR_1

	MOVI	SETUP_2_OF_2,A8
	JSRP	SET_THEN_STRNGRAM	;PUT IT OUT

	MOVI	CM_LINE1,A10
	MOVI	SETUP_1_OF_2,A8
	JRUC	SET_THEN_STRNGRAM

GO_FOR_1
	MOVI	CM_LINE1,A10
	MOVI	SETUP_1_OF_1,A8
	JRUC	SET_THEN_STRNGRAM

	.endif

SET_THEN_A2
	CALLA	LM_SETUP
	MOVE	A2,A8
	JAUC	LM_FINIS		;THAT DOES LINE 3

SET_THEN_STRNGRAM
	CALLR	CK_LINE 		;TRANSFER TO STRNGRAM
	CALLR	LM_SETUP
	MOVI	STRNGRAM,A8
	JAUC	LM_FINIS

CK_LINE
	MMTM	SP,A0,A7,A1,A2,A10
	MOVE	A10,A7			;INPUT POINTER TO CMOS
	MOVE	A13,A10 		;OUR PDATA AREA
	ADDI	PDATA,A10		;A10 IS DESTINATION.
	MOVE	A10,A2			;ITERATE TO LOAD IT UP.

	MOVI	CMESS_CHARS,A1		;COUNTER
	CALLA	ADJ_PAGE		;POINT THE PAGE

CK_LOOP
	CALLA	RC_BYTEI		;FETCH A BYTE
	MOVB	A0,*A2			;STORE
	ADDK	BYTE_SIZE,A2
	DSJS	A1,CK_LOOP

	CALLA	DEF_PAGE		;POINT AWAY NOW
	CALLA	BUILD_ST		;NOW XFER TO STRNGRAM (REMOVING SPACES ETC)
	MMFM	SP,A0,A7,A1,A2,A10	;RETURN .EQ. IF ITS ALL SPACES.
	RETS




LINE_ONE_PLUS
	MOVE	*A8,A2,L		;GET LINE 1
LOP_1
	MOVI	SETUP_1_OF_3,A8
	CALLR	LM_SETUP
	MOVE	A2,A8			;SWAP IN TEXT POINTER
	JSRP	LM_FINIS		;PRINT IT

LOP_2
	MOVI	TWO_TS,A8		;TWO TO START STUFF
	JAUC	L_MESS			;PRINT IT AND RETURN

LINE_THREE_PLUS
	MOVE	*A8(2*LONG_SIZE),A2,L	;FETCH LINE 3
	JRZ	LOP_2			;NOTHING ON LINE 3
	JAUC	LOP_1			;THEN ITS THE SAME AS ABOVE!

LINE_TWO_PLUS
	MOVE	*A8(LONG_SIZE),A2,L	;FETCH LINE 2
	JRZ	LOP_2			;NOTHING ON LINE 2
	JAUC	LOP_1			;THEN ITS THE SAME AS ABOVE!

LINE_ONE_PLUS_2
	MOVE	*A8,A2,L		;GET LINE 1
LOP_12
	MOVI	SETUP_1_OF_2,A8
	CALLR	LM_SETUP
	MOVE	A2,A8			;SWAP IN TEXT POINTER
	JSRP	LM_FINIS		;PRINT IT

LOP_22
	MOVI	TWO_TP,A8		;TWO CREDITS PER PLAYER
	JAUC	L_MESS			;PRINT IT AND RETURN

LINE_TWO_PLUS_2
	MOVE	*A8(LONG_SIZE),A2,L	;FETCH LINE 2
	JRZ	LOP_22			;NOTHING ON LINE 2
	JAUC	LOP_12			;THEN ITS THE SAME AS ABOVE!

LINE_THREE_PLUS_2
	MOVE	*A8(2*LONG_SIZE),A2,L	;FETCH LINE 3
	JRZ	LOP_22			;NOTHING ON LINE 3
	JAUC	LOP_12			;THEN ITS THE SAME AS ABOVE!

SELECT_SETUP
	PUSH	a0
	MOVI	MESS_CNUM,A8		  ;ASSUME NO EXTRA PROMPT

	CALLA	CKPROMPT		  ;IS THERE ONE?
	JRZ	NO_EXTRA

	MOVI	MESS_LOWNUM,A8
NO_EXTRA
	MMFM	SP,A0			
	RETS

FETCH_REQ
	PUSH	a0
	MOVK	ADJCUNIT,A0
	CALLR	GET_ADJ
	MOVE	A0,A2

	MOVK	ADJBUNIT,A0
	CALLR	GET_ADJ
	MOVE	A0,A3

	MOVK	ADJMUNIT,A0
	CALLR	GET_ADJ_FOR_COIN
	MOVE	A0,A4
	MMFM	SP,A0
	RETS

SLAM_P
	MOVI	SLAM_PID,A0		;SLAM PROCESS ACTIVE?
	MOVI	0FFFFH,A1
	jauc	EXISTP

SLAM_SW
	movi	SLAM_PID|0ffff0000H,a0	;So we can kill other indestructables
	move	a0,*a13(PROCID)		;Set our ID
	calla	KIL1C			;Kill others

	SLEEP	TSEC			;1 second of coin ignoring
	jauc	SUCIDE

FORM_COIN_CKSUM
	MMTM	SP,A0,A7,A2
	CALLR	COIN_PAG		 ;MAKE SURE WE'RE ON THE RIGHT PAGE.
	MOVI	COIN_CKSUM_START,A7	  ;POINT AT FIRST BYTE TO CHECK
	MOVI	COIN_CKSUM_BYTES,A2
	CLR	A1			  ;CLEAR OUT CHECKSUM

CN_SUM
	CALLA	RC_BYTEI		  ;FETCH A BYTE IN A0
	ADD	A0,A1			  ;ADD TO SUM
	DSJS	A2,CN_SUM		  ;TILL WE HAVE EM ALL

	NOT	A1			  ;COMPLEMENT OF COURSE
	sll	32-8,a1
	srl	32-8,a1

	MOVI	COIN_CKSUM,A7
	CALLA	RC_BYTE 		  ;FETCH THE CURRENT CKSUM
	CMP	A0,A1			  ;COMPARE TO THIS
	MMFM	SP,A0,A7,A2
	RETS

FORM_COIN_CKSUM_AND_STORE
	MMTM	SP,A1,A7,A0
	CALLR	FORM_COIN_CKSUM
	MOVI	COIN_CKSUM,A7
	MOVE	A1,A0
	CALLA	WC_BYTE
	MMFM	SP,A1,A7,A0
	RETS

CCCC
	MMTM	SP,A0,A1,A7,A2
	CALLR	FORM_COIN_CKSUM		;THIS SETS US TO THE COINAGE PAGE!
	JRZ	CCCCX			;ALL IS OK!

	MOVI	COIN_CKSUM_START,A7  ;POINT AT FIRST BYTE
	MOVI	COIN_CKSUM_BYTES,A2  ;NUMBER OF BYTES TO CLEAR
	CLR	A0

CCCC_LOOP
	CALLA	WC_BYTEI		;WRITE A BYTE
	DSJS	A2,CCCC_LOOP		;UNTIL THEY'RE DONE!

	CALLR	FORM_COIN_CKSUM_AND_STORE  ;NOW MAKE THE CKSUM VALID

CCCCX
	MMFM	SP,A0,A1,A7,A2
	RETS

COIN_PAG
	PUSH	a1
	MOVI	COIN_SELECT,A1		;THIS IS COIN/CREDITS PAGE
	CALLA	SET_PAGE		;SET IT PLEASE
	MMFM	SP,A1
	RETS



 SUBR	aud_addnumplyrs

	movk	1,a1		;1 plyr
	move	@PSTATUS2,b0
	subk	3,b0
	jrne	aanp50		;Only 1?
	movk	2,a1		;2 plyrs
aanp50	jruc	AUD


POINT_AT_AUDIT
	PUSH	a1
	CALLR	AUDIT_PAGE

	MOVI	AUD_SIZE,A7		;THIS IS SIZE PER AUDIT
	MPYU	A0,A7			;A1 NOW HAS OFFSET
	ADDI	AUDITORG,A7		;ADD BASE
	MMFM	SP,A1
	RETS

AUDIT_PAGE
	PUSH	a1
	MOVI	AUDIT_SELECT,A1		;THIS IS AUDIT PAGE
	CALLA	SET_PAGE		;SET IT PLEASE
	MMFM	SP,A1
	RETS

FORM_AUD_CKSUM
	MMTM	SP,A0,A4,A7
	CALLR	POINT_AT_AUDIT		  ;A7 = POINTER TO CURRENT ENTRY
	MMTM	SP,A7			  ;SAVE POINTER TO ENTRY
	MOVI	AUD_BYTES_TO_CHECK,A4	  ;COUNT DOWN THE BYTES
	CLR	A1			  ;KEEP SUM IN A1
ADD_A_BYTE
	CALLA	RC_BYTEI		  ;GET A BYTE INTO A0
	ADD	A0,A1			  ;ADD TO SUM
	DSJ	A4,ADD_A_BYTE		  ;ONE MORE ADDED
	NOT	A1			  ;CHECKSUM IS NOW IN LOW WORD
	ZEXT	A1
	MMFM	SP,A7			  ;GET POINTER BACK
	ADDI	AUD_CKSUM,A7		  ;POINT AT CHECKBYTE
	CALLA	RC_WORD 		  ;READ IN THE CKSUM
	CMP	A0,A1			  ;COMPARE WHAT'S THERE TO WHAT WE GOT
	MMFM	SP,A0,A4,A7		  ;Z BIT RETURNS COMPARE
	RETS				  ;A1 RETURNS CKSUM

STORE_AUD_CKSUM
	MMTM	SP,A7,A0		  ;POINTING REGISTER
	CALLR	POINT_AT_AUDIT		  ;A7 POINTS AT AUDIT
	ADDI	AUD_CKSUM,A7		  ;POINT AT CHECKBYTE
	MOVE	A1,A0			  ;GET CHECKBYTE IN A0
	CALLA	WC_WORD 		  ;WRITE THE CKSUM
	MMFM	SP,A7,A0		  ;POINTING REGISTER
	RETS

FORM_AUD_CKSUM_AND_STORE
	MMTM	SP,A1,A2			;SAVE A1!
	CALLR	FORM_AUD_CKSUM
	MOVE	@BAD_AUD,A2			;GET THE "FUDGE" WORD
	XOR	A2,A1				;MAKE CKSUM BAD IF AUDIT IS BAD
	CALLR	STORE_AUD_CKSUM
	MMFM	SP,A1,A2
	RETS

GET_AUD
	MMTM	SP,A0,A7
	CALLR	FORM_AUD_CKSUM		;SEE IF CKSUM IS OK
	JRZ	FETCH_AUDIT_1		;ITS OK....

	MOVK	1,A1			;CHECKSUM IS BAD
	MOVE	A1,@BAD_AUD		;SET THE FLAG!

FETCH_AUDIT_1
	CALLR	POINT_AT_AUDIT		;A7 POINTS AT AUDIT
	ADDI	AUD_DATA,A7		;ADD ZERO OFFSET
	CALLA	RC_LONG			;FETCH THE LONG WORD TO A0
	MOVE	A0,A1			;RETURN IN A1
	MMFM	SP,A0,A7
	RETS

STORE_AUDIT
	
	MMTM	SP,A0,A7
	CALLR	POINT_AT_AUDIT		;A7 POINTS AT AUDIT
	ADDI	AUD_DATA,A7		;ADD ZERO OFFSET
	MOVE	A1,A0			;MOVE DATA TO WRITING REGISTER
	CALLA	WC_LONG 		;WRITE THE DATA BACK
	MMFM	SP,A0,A7		;GET AUDIT NUMBER BACK
	JRUC	FORM_AUD_CKSUM_AND_STORE	;STORE GOOD OR BAD CKSUM BASED
						;ON BAD_AUD

CLR_AUDR
	MMTM	SP,A0,A1,A2
	MOVE	A1,A2			  ;MOVE "LAST" TO A2
	CLR	A1			  ;WE'LL STORE ZEROS
	MOVE	A1,@BAD_AUD		  ;MAKE CKSUMS GOOD ON STORING
CAR1
	CALLR	STORE_AUDIT		  ;STORE THIS AUDIT
	INC	A0			  ;KICK TO NEXT AUDIT
	CMP	A2,A0
	JRLS	CAR1
	MMFM	SP,A0,A1,A2
	RETS

	
KILL_AUD
	PUSH	a1
	CLR	A1			  ;WE'LL STORE ZEROS
	MOVE	A1,@BAD_AUD		  ;MAKE CKSUMS GOOD ON STORING
	CALLR	STORE_AUDIT		  ;STORE THIS AUDIT
	MMFM	SP,A1
	RETS

AUD
	MMTM	SP,A1,A2
	CLR	A2			;SET "BAD_AUD" GOOD UNTIL OTHERWISE PROVEN!
	MOVE	A2,@BAD_AUD		;ITS GOOD.
	MOVE	A1,A2			;COPY OUR COUNT
	CALLR	GET_AUD 		;FETCH THE CURRENT AUDIT COUNTER
	ADD	A2,A1			;ADD THE NEW COUNT
	CALLR	STORE_AUDIT		;STORE IT BACK
	CALLR	DEF_PAGE		;SWITCH PAGE AWAY FROM THE DATA!
	MMFM	SP,A1,A2
	RETS

AUD1
	PUSH	a1
	MOVK	1,A1
	CALLR	AUD
	MMFM	SP,A1
	RETS

CLR_AUD
	MMTM	SP,A0,A1
	MOVK	1,A0			;START AT AUDIT 1
	MOVI	N_AUDITS-1,A1		;THIS IS TOTAL ALLOCATED
	CALLR	CLR_AUDR
	MMFM	SP,A0,A1
	RETS

CMOS_VAL
	callr	form_crc32
	jrnz	CMOS_BAD
	CALLR	FORM_ADC  ;SEE IF CKSUM IS OK.
	JRNZ	CMOS_BAD	;NOPE....RETURN .NE.

	CALLR	CHECK_NAME_AND_REV	;HOW ABOUT THE NAME AND REV?
CMOS_BAD
	RETS

FORM_ADC
	MMTM	SP,A7,A0,A6
	CALLR	ADJ_PAGE	  ;SET CMOS PAGE FOR ADJUSTMENTS
	MOVI	ADJUSTORG,A7		;POINT AT FIRST BYTE
	MOVI	ADJ_BYTES_TO_CHECK,A6  ;NUMBER OF BYTES
	CLR	A1			;ACCUMULATE CKSUM HERE

ADJ_C1
	CALLA	RC_BYTEI		;READ A BYTE
	ADD	A0,A1			;ADD THE BYTE TO THE SUM
	DSJS	A6,ADJ_C1
	NOT	A1			;COMPLEMENT THE SUM
	ZEXT	A1
	MOVI	ADJ_CKSUM,A7
	CALLA	RC_WORD 		;FETCH THE CHECKSUM
	CMP	A0,A1			;COMPARE TO FETCHED VALUE
	MMFM	SP,A7,A0,A6
	RETS

 SUBR	form_crc32
	mmtm	sp,a7,a0,a6
	movi	ADJUSTORG,a7
	movi	ADJ_BYTES_TO_CHECK,a6
	clr	a1
crc_lp
	calla	RC_BYTEI
	xor	a0,a1
	rl	1,a1
	dsjs	a6,crc_lp
	movi	ADJ_CRC32,a7
	calla	RC_LONG
	cmp	a0,a1
	mmfm	sp,a7,a0,a6
	rets

F_ADC_S
	MMTM	SP,A0,A1,A7
	CALLR	FORM_ADC		;FORM THE CKSUM
	MOVE	A1,A0			;PUT IN CMOS WRITING REGGIE
	MOVI	ADJ_CKSUM,A7
	CALLA	WC_WORD 		;AND STORE IT
	callr	form_crc32
	move	a1,a0
	movi	ADJ_CRC32,a7
	calla	WC_LONG
	MMFM	SP,A0,A1,A7
	RETS

GET_ADJ
	PUSH	a1,a7
	CALLR	ADJPOINT		;POINT AT ADJUSTMENT
	CALLA	RC_LONG 		;FETCH THE ADJUST PLEASE
	CALLR	DEF_PAGE
	PULL	a1,a7
	MOVE	A0,A0			;RETURN Z BIT BASED ON ADJUSTMENT!
	RETS

PUT_ADJ
	PUSH	a0,a7
	CALLR	ADJPOINT		;POINT AT REQUESTED ADJ.
	MOVE	A1,A0			;GET VALUE IN WRITING REGGIE!
	CALLA	WC_LONG 		;WRITE THE ADJUSTMENT
	CALLR	DEF_PAGE		;SWAP PAGE AWAY.
	MMFM	SP,A7,A0
	RETS

ADJPOINT
	CALLR	ADJ_PAGE		;SET CMOS PAGE FOR ADJUSTMENTS
	MOVI	ADJ_SIZE,A7		;SIZE PER ADJUSTMENT IN A7
	MPYU	A0,A7			;TIMES ADJUSTMENT REQUESTED.
	ADDI	ADJUSTORG,A7		;ADD TO BASE
	RETS

GET_ADJ_FOR_COIN
	CALLR	GET_ADJ 		;GET THE ADJUSTMENT
	JAUC	COIN_PAG		;THEN RE-INSTATE THE COIN PAGE!

CHECK_NAME_AND_REV
	MMTM	SP,A0,A1,A2,A3,A7
	CALLR	ADJ_PAGE	  ;MAKE SURE WE'RE ON THE CORRECT PAGE

	MOVI	NAME_REV,A7		;POINT AT CMOS NAME STORAGE
	MOVI	ROM_NAME,A1		;POINT AT OUR VERSION
	MOVI	NAME_REV_SIZE,A2	;MAXIMUM NAME SIZE

NEXT_LET1
	CALLA	RC_BYTEI		;FETCH A BYTE
	MOVB	*A1,A3			;GET 1 FROM ROM
	SLL	24,A3
	SRL	24,A3

	CMP	A3,A0			;THEY BETTER BE THE SAME
	JRNZ	RETURN_NOW		;NOPE....BYE  (RETURN .NE.)

	ADDK	BYTE_SIZE,A1		;KICK SOURCE POINTER
	MOVE	A0,A0			;WAS IT A ZERO?
	JRZ	RETURN_NOW		;YEP....NO MORE (RETURN .EQ.)
	DSJS	A2,NEXT_LET1
	CLR	A0			;RETURN .EQ.
	
RETURN_NOW
	MMFM	SP,A0,A1,A2,A3,A7
	RETS

ADJ_PAGE
	PUSH	a1
	MOVI	ADJUST_SELECT,A1	;THIS IS AUDIT PAGE
	CALLA	SET_PAGE		;SET IT PLEASE
	MMFM	SP,A1
	RETS


DEF_PAGE
 .if 0
	PUSHST				;PRESERVE CODES THAT ARE BEING RETURNED
	PUSH	a1
	MOVI	TODAYS_SELECT,A1	;THIS IS TODAY'S HIGH SCORES PAGE
	CALLA	SET_PAGE		;SET IT PLEASE
	PULL	a1
	POPST
 .endif
	RETS


FAC_SET
	PUSH	a1,a2,a7

	move	a0,-*sp
	subk	1,a0
	jreq	fs20			;Just coinage?

	calla	opmsg_clr



	CALLR	NO_CREDS		;REMOVE ANY COINS
	CALLR	ADJ_PAGE		;SET CMOS PAGE CORRECTLY

	MOVI	FACTORY_TABLE,A1	;ROM
	MOVI	ADJUSTORG,A7		;CMOS
	MOVI	N_ADJUSTS,A2		;NUMBER OF ADJUSTMENTS ALLOCATED

FACS1
	MOVE	*A1+,A0			;FETCH A ROM LONG WORD
	ZEXT	A0
	CALLA	WC_LONGI		;WRITE THE WORD TO CMOS
	DSJS	A2,FACS1		;WRITE 1 LONG WORD PER ADJUST
fs20

	callr	LD_CTAB			;EXPAND THE CSELCT VALUE
	callr	F_ADC_S			;MAKE THE CHECKSUM CORRECT.

	move	*sp+,a0
	subk	1,a0
	jreq	fsx			;Only coinage?


	MOVI	NAME_REV,A7		;POINT AT CMOS NAME STORAGE
	MOVI	ROM_NAME,A1		;POINT AT OUR VERSION
	MOVI	NAME_REV_SIZE,A2	;MAXIMUM NAME SIZE

NEXT_LETTER
	MOVB	*A1,A0			;FETCH A BYTE
	CALLA	WC_BYTEI		;WRITE IT TO CMOS
	ADDK	BYTE_SIZE,A1		;KICK SOURCE POINTER
	move	a0,a0
	jrz	fsx			;End?
	DSJS	A2,NEXT_LETTER
	
fsx	PULL	a1,a2,a7
	rets

	.even


LD_CTAB
	mmtm	sp,a0,a6,a1

	calla	GET_CSPT		;A6=CSELCT table

 .IF 0
	movk	1,a1
	move	*a6(16*4),a0
	jrnn	lct5			;Normal 1 credit to start?
	movk	2,a1
lct5	movk	ADJCSTRT,a0
	callr	PUT_ADJ
	movk	1,a1
	movk	ADJCCONT,a0
	callr	PUT_ADJ

	movk	ADJC1,a0		;1st one to store
lct8	move	*a6+,a1			;Get word
	abs	a1
	callr	PUT_ADJ 		;Write this one to memory
	addk	1,a0
	cmpi	ADJCX,a0
	jrls	lct8

 .ENDIF


	movi	ADJLMULT,a0
	move	*a6+,a1
	calla	PUT_ADJ

	movi	ADJCMULT,a0
	move	*a6+,a1
	calla	PUT_ADJ

	movi	ADJRMULT,a0
	move	*a6+,a1
	calla	PUT_ADJ

	movi	ADJXMULT,a0
	move	*a6+,a1
	calla	PUT_ADJ

	movi	ADJDBVMULT,a0
	move	*a6+,a1
	calla	PUT_ADJ

	movi	ADJCUNIT,a0
	move	*a6+,a1
	calla	PUT_ADJ

	movi	ADJBUNIT,a0
	move	*a6+,a1
	calla	PUT_ADJ

	movi	ADJMUNIT,a0
	move	*a6+,a1
	calla	PUT_ADJ

	movi	ADJCSTRT,a0
	move	*a6+,a1
	calla	PUT_ADJ

	movi	ADJCCONT,a0
	move	*a6+,a1
	calla	PUT_ADJ

	movi	ADJCDIV,a0
	move	*a6+,a1
	calla	PUT_ADJ

	movi	ADJFRAC,a0
	move	*a6+,a1
	calla	PUT_ADJ

	PUSH	A6
	MOVI	ADJLTOTMULT,A0
	MOVE	*A6+,A1,W
	CALLA	PUT_ADJ
	MOVI	ADJCTOTMULT,A0
	MOVE	*A6+,A1,W
	CALLA	PUT_ADJ
	MOVI	ADJRTOTMULT,A0
	MOVE	*A6+,A1,W
	CALLA	PUT_ADJ
	MOVI	ADJXTOTMULT,A0
	MOVE	*A6+,A1,W
	CALLA	PUT_ADJ
	MOVI	ADJBTOTMULT,A0
	MOVE	*A6+,A1,W
	CALLA	PUT_ADJ
	PULL	A6

	movk	ADJVIRGIN,a0		;THIS SAYS 1ST 8 UNTOUCHED.
	movk	1,a1
	callr	PUT_ADJ

	movk	ADJ1ST6,a0		;THIS SAYS 1ST 6 UNTOUCHED.
	movk	1,a1
	callr	PUT_ADJ 		;DONE!

	mmfm	sp,a0,a6,a1
	rets


L_MESS_LOOP
	addk	BYTE_SIZE,a8		;PUSH BEYOND THIS BYTE
L_MESS	addk	0fH,a8			;Round up word
	srl	4,a8
	sll	4,a8

	MMFM	A8,A1,A6,A9,A10,A11	;LOAD UP REGGIES FROM A8.
	CLR	A0			;NEVER SLEEP!

	MOVI	L_RET,A7
	MOVE	A7,-*A12,L	;PUSH RET ADDR
	JUMP	A1		;JUMP TO THE ROUTINE.
L_RET	MOVB	*A8,A0		;CHECK NEXT BYTE 0=DONE...1=MORE.
	JRNZ	L_MESS_LOOP
	RETP
	
LM_SETUP
	MMFM	A8,A1,A6,A9,A10,A11	  ;LOAD UP REGGIES FROM A8.
	CLR	A0			  ;DON'T SLEEP
	RETS

LM_FINIS
	JUMP	A1				;THIS RUNS ROUTINE AND

GET_CSTR
	MOVK	ADJFREPL,A0		;ARE WE IN FREE PLAY?
	CALLA	GET_ADJ
	JRZ	NOT_FREE

	MOVI	MESS_FREEP,A8		;RETURN POINTING AT FREE PLAY MESSAGE
	JRUC	GET_CX

NOT_FREE
	CALLA	STR_OBJ 		;ALLOCATE AN OBJECT PLEASE
	JRC	NO_SOBJ 		;NONE TO USE!
	
	MOVI	MESS_CREDITS,A8 	;POINT AT TEXT PART
	CALLA	STRCAT			;BUILD THIS IN.
	CALLR	CRED_P
	MOVE	A0,A10			;SAVE CREDITS
	CALLR	CAT_A0
	MOVK	ADJFRAC,A0
	CALLA	GET_ADJ 		;CHECK THE ADJUSTMENT
	JRZ	NSFRAC			;DON'T SHOW IT!
	CALLR	COIN_PAG		;PUT US ON COIN PAGE
	CALLR	GET_CUNITS		;A0 HAS CUNITS
	CALLR	DEF_PAGE		;FLIP CMOS AWAY
	MOVE	A0,A0			;ZERO?
	JRZ	NSFRAC			;THEN NO FRACTION.
	MOVE	A10,A10 		;WE SAVED EM IN A10
	JRNZ	NZM			;NON ZERO MANTISSA

	MOVE	A7,A8			;WALK DOWN STRING LOOKING FOR THE "ZERO"
KILL_Z
	MOVB	*A8,A1			;GET A BYTE
	JRZ	NZM			;COULDN'T FIND IT....GO ON.

	CMPI	LET_0,A1		;IS THIS THE ZERO?
	JRZ	GOT_ZERO

	ADDK	BYTE_SIZE,A8
	JRUC	KILL_Z

GOT_ZERO
	CLR	A1
	MOVB	A1,*A8			;KILL THE ZERO

NZM
	MOVI	MESS_2SPACE,A8		;SPACE BET. MANTISSA AND DENMO
	CALLA	STRCAT

NOT_ZM
	CALLR	CAT_A0			;ADD A0 ONTO FRACTION

	MOVI	MESS_SLASH,A8
	CALLA	STRCAT			;ADD SLASH

	MOVK	ADJCUNIT,A0		;UNITS REQUIRED FOR CREDIT
	CALLA	GET_ADJ
	CALLR	CAT_A0			;DENOMINATOR

NSFRAC
	MOVE	A7,A8			;MOVE "OBJECT" TO A8
	MOVI	STRNGRAM,A7		;POINT AT STRING RAM
	CLR	A0
	MOVB	A0,*A7			;STRINGRAM IS NULL
	CALLA	STRCAT			;COPY THE STRING OUT OF OBJECT BLOCK
	MOVE	A7,A8
	CALLA	STR_FREE		;AND FREE UP THE OBJECT BLOCK

GET_CX
	CLRC				;RETURN OK
GET_CXX
	RETS
NO_SOBJ
	MOVI	MESS_NULL,A8
	SETC
	JRUC	GET_CXX 		;RETURN BLANK STRING!

CAT_A0
	PUSH	a8
	MOVE	A0,A8			;CREDIT COUNT IN A8
	CALLA	HEXTOASC		;STRING
	CALLA	STRCAT			;NOW WE HAVE WHOLE NUMBER.
	MMFM	SP,A8
	RETS

ADD_PROMPT
	MOVI	PROMPT_PROC,A7
	CALLA	P_FORK			;START UP ANOTHER W/ SAME ID TO FLASH!
	RETP

PROMPT_PROC
	MOVK	ADJFREPL,A0
	CALLA	GET_ADJ
	JRNZ	rf4			;ALWAYS READY FOR 4 PLAYERS!

	CALLR	CRED_P
	JRZ	PP1

	MOVE	A0,A1			;PUT CREDITS IN A1
	MOVK	ADJCSTRT,A0		;GET AMOUNT NEEDED TO START.
	CALLA	GET_ADJ
	CMP	A0,A1			;ARE THERE ENOUGH TO START?
	JRLO	PP1			;NOPE...."INSERT COIN"
	jrz	PP2
	move	a0,a2
	add	a2,a2
	cmp	a1,a2
	jrz	RF2
	jrhi	PP2
	add	a0,a2
	cmp	a1,a2
	jrhi	RF2
	add	a0,a2
	cmp	a1,a2
	jrhi	rf3


rf4
	MOVI	MESS_READY_4,A1
	JRUC	RED_1
rf3
	MOVI	MESS_READY_3,A1
	JRUC	RED_1
RF2
	MOVI	MESS_READY_2,A1
	JRUC	RED_1

PP1
	MOVI	MESS_INS_COIN,A0
	CLR	A1
	JRUC	RED_2

PP2
	MOVI	MESS_READY_1,A1
RED_1
	MOVI	MESS_PRESS_START,A0
RED_2
	MOVE	A0,*A13(PDATA),L		;HOLD MESSAGES
	MOVE	A1,*A13(PDATA+LONG_SIZE),L

BLINK_LOOP
	MOVE	*A13(PDATA),A8,L		;FIRST MESSAGE
	JSRP	L_MESS
	MOVE	*A13(PDATA+LONG_SIZE),A8,L	;2ND MESSAGE
	JRZ	BL1				;NOT HOME!

	JSRP	L_MESS

BL1
	SLEEPK	10H

	MOVE	*A13(PDATA),A8,L
	CALLR	LM_SETUP
	CLR	A6			;BLACK
	JSRP	LM_FINIS

BL2
	SLEEPK	10H
	JRUC	BLINK_LOOP

ROM_NAME
	.byte	"WRESTLEMANIA REV 1.30 8/10/95",0
	.even

FACTORY_TABLE

	.word	0	;ADJNULL	0
	.word	1	;ADJPRICE	1	;MASTER PRICING
	.word	1	;ADJLMULT	2
	.word	4	;ADJCMULT	3
	.word	1	;ADJRMULT	4
	.word	0	;ADJXMULT	5
	.word	0	;ADJDBVMULT	6	;DOLLR BILL VALIDATOR
	.word	1	;ADJCUNIT	7
	.word	0	;ADJBUNIT	8
	.word	0	;ADJMUNIT	9
	.word	4	;ADJCDIV	10
	.word	1	;ADJFRAC	11	;NON ZERO SAYS SHOW HALF CREDITS
	.word	2	;ADJCSTRT	12	;CREDITS REQUIRED TO START
	.word	2	;ADJCCONT	13	;CREDITS REQUIRED TO CONTINUE

	.word	5	;ADJDIFF	14	;Difficulty Level (1-10)

	.word	0	;		15
	.word	0	;		16
	.word	1	;ADJMUSIC	17	;attract mode music = off
	.word	50	;ADJMAXC	18	;MAXIMUM CREDITS
	.word	0	;ADJFREPL	19	;NON-ZERO MEANS FREE PLAY
	.word	1	;ADJVIRGIN	20	;NON-ZERO MEANS 1ST 8 OF COIN ADJUST BLOCK UNTOUCHED
	.word	8	;ADJFULLG	21	;credits needed to purchase full game (4-16)
	.word	1	;ADJ1ST6	22	;NON-ZERO MEANS 1ST 6 UNTOUCHED.
	.word	0	;ADJNOCPAG	23
	.word	1	;ADJCNTR	24	;COIN COUNTER MODE
	.word	3	;ADJSPEED	25	;game timer speed (1-5)
	.word	1	;ADJHEADSZ	26	;player head sizes (1-2)
	.word	1	;ADJWINMODE	27	;(winner stays free)
	.word	30	;ADJVOLUME	28	;sound volume (4-255)
	.WORD	0	;CUSTOM TOTALIZER
	.WORD	1	;TOTALIZER CHUTE 1
	.WORD	1	;TOTALIZER CHUTE 2
	.WORD	1	;TOTALIZER CHUTE 3
	.WORD	1	;TOTALIZER CHUTE 4
	.WORD	1	;TOTALIZER DBV

	.if 0
	.word	0	;ADJ_UNUSED		0
	.word	2	;ADJ_PRICING		1  ;MASTER PRICING
	.word	1	;ADJ_LEFT_MULT		2
	.word	1	;ADJ_RIGHT_MULT		4
	.word	4	;ADJ_CENTER_MULT	3
	.word	0	;ADJ_EXTRA_MULT		5
	.word	1	;ADJ_UNITS_CREDIT	6
	.word	0	;ADJ_UNITS_BONUS	7
	.word	0	;ADJ_MIN_UNITS		8
	.word	4	;ADJCDIV		9  ;COINS PER DOLLAR
	.word	1	;SHOW FRACTIONS		10
	.word	1	;ADJ_START_CRED		11 ;CREDITS REQUIRED TO START
	.word	1	;ADJ_CONT_CRED		12 ;CREDITS REQUIRED TO CONTINUE
	.word	3	;ADJ_DIFFICULTY		13
	.word	5000	;ADJ_HSRESET		14
	.word	3	;ADJ_LIVES		15
	.word	0	;ADJ_AMODE_MUSIC	16
	.word	50	;MAXIMUM CREDITS	17
	.word	0	;FREE PLAY		18
	.word	1	;NON-ZERO MEANS COIN BLOCK (1ST 8) UNTOUCHED 19
	.word	0	;ZERO MEANS NORMAL GORE ... 1 = SOFTEN IT  20
	.word	1	;NON-ZERO MEANS 1ST 6 UNTOUCHED.		21
	.word	0	;NON-ZERO MEANS NO COIN-SPECIFIC MESSAGE ON COIN PAGE  21
	.word	1	;ADJCNTR  23   ADJUST MECH COIN COUNTER
	.endif


MESS_CREDITS
	.byte	"CREDITS: ",0
	.even

MESS_CNUM
	MESS_MAC  RD15FONT,SPACING20,CP_CX,135,ROBO_LF,STRCNRM,0
MESS_LOWNUM
	MESS_MAC  RD15FONT,SPACING20,CP_CX,135,ROBO_LF,STRCNRM,0

MESS_FREEP
	.byte	"FREE  PLAY",0,0
	.even

MESS_READY_1
	MESS_MAC  RD15FONT,SPACING20,CP_CX,155,ROBO_YELLOW,STRCNRM,0
	.byte	"READY FOR  1  PLAYER",0,0
	.even

MESS_READY_2
	MESS_MAC  RD15FONT,SPACING20,CP_CX,155,ROBO_YELLOW,STRCNRM,0
	.byte	"READY FOR  1 - 2  PLAYERS",0,0
	.even

MESS_READY_3
	MESS_MAC  RD15FONT,SPACING20,CP_CX,155,ROBO_YELLOW,STRCNRM,0
	.byte	"READY FOR  1 - 3  PLAYERS",0,0
	.even

MESS_READY_4
	MESS_MAC  RD15FONT,SPACING20,CP_CX,155,ROBO_YELLOW,STRCNRM,0
	.byte	"READY FOR  1 - 4  PLAYERS",0,0
	.even

MESS_INS_COIN
	 MESS_MAC  RD15FONT,SPACING20,CP_CX,175,ROBO_YELLOW,STRCNRM,0


	.byte	"INSERT COINS",0,0


	.even

MESS_PRESS_START
	MESS_MAC RD15FONT,SPACING20,CP_CX,175,ROBO_YELLOW,STRCNRM,0
	.byte	"PRESS START",0,0
	.even

 .if 0

DUMP_FS
	CALLR	DUMP_PAGE
	CLR	A0
	MOVI	DUMP_PTR,A7
	CALLA	WC_WORD 		;SET NUMBER OF DUMPS TO ZERO
	RETS

DUMP_SIZE	 .equ	 10*C_LONG_SIZE		;9 LONG WORDS.
DUMP_LAST	 .equ	 CMOS+08000H-DUMP_SIZE	;Let em use the whole page!
MAX_DUMP	 .equ	 8			;DON'T HOLD MORE THAN 12/PAGE

ADD_DUMP
	MMTM	SP,B0,B1,B2
	MMTM	SP,A0,A1,A7
	CALLR	DUMP_PAGE		;SET CMOS PAGE CORRECTLY.
	MOVE	A0,B0
	MOVE	A7,B2			;SAVE THESE!
	MOVE	A1,B1

	MOVI	DUMP_PTR,A7
	CALLA	RC_WORD 		;GET THE INDICATOR OF HOW MANY.
	MOVI	DUMP_SIZE,A1
	MPYU	A0,A1			;THIS IS OFFSET INTO CMOS FOR THIS ENTRY!

	ADDI	DUMP_DATA,A1		;NOW A1 POINTS WHERE WE'RE PUTTING THE DATA!
	CMPI	DUMP_LAST,A1		;ARE WE TOO FAR FOR ANOTHER?
	JRHS	NO_DUMP 		;YEP....SKIP IT

	INC	A0			;1 MORE OUT THERE!
	CALLA	WC_WORD 		;CHALK IT!

	MOVE	A1,A7			;THIS IS POINTER TO STORE DATA.
	MOVE	B0,A0			;THIS IS A0
	CALLA	WC_LONGI
	MOVE	B1,A0			;THIS IS A1
	CALLA	WC_LONGI
	MOVE	A2,A0			;THIS IS A2
	CALLA	WC_LONGI
	MOVE	A3,A0			;THIS IS A3
	CALLA	WC_LONGI
	MOVE	A4,A0			;THIS IS A4
	CALLA	WC_LONGI
	MOVE	A5,A0			;THIS IS A5
	CALLA	WC_LONGI
	MOVE	A6,A0			;THIS IS A6
	CALLA	WC_LONGI
	MOVE	B2,A0			;THIS IS A7
	CALLA	WC_LONGI
	MOVE	A8,A0			;THIS IS A8
	CALLA	WC_LONGI
	MOVE	A9,A0			;THIS IS A9
	CALLA	WC_LONGI
NO_DUMP
	MMFM	SP,A0,A1,A7
	MMFM	SP,B0,B1,B2
	RETS

DUMP_PAGE
	PUSH	a1
	MOVI	DUMP_SELECT,A1		;THIS IS DUMP PAGE
	CALLA	SET_PAGE		;SET IT PLEASE
	MMFM	SP,A1
	RETS

DISPDUMP
	CALLR	DUMP_PAGE
	MOVI	DUMP_PTR,A7
	CALLA	RC_WORD 		;GET THE INDICATOR OF HOW MANY.
	JRZ	NOTHIN_TO_DUMP

	CLR	A9			;THIS IS CURRENT ONE
	MOVE	A0,A8			;THIS IS THE LAST ONE TO DO

DO_ANOTHER_DPAGE
	CALLA	CLR_SCRN		;CLEAR SCREEN
	CALLR	DUMP_PAGE
	movk	20,a10			;This is y coordiante of current one!
	MOVI	MAX_DUMP,A11		;THIS IS MAX NUMBER PER PAGE.

DO_ANOTHER_DUMP
	JSRP	DO_DUMP
	addk	30,a10			;Kick y up
	INC	A9			;KICK TO NEXT DUMP
	CMP	A8,A9			;UNTIL THEY'RE ALL DONE!
	JRHS	DUMP_DONE		;WE'RE NOT ALL DONE YET!

	DSJS	A11,DO_ANOTHER_DUMP	;NOT FOR THIS PAGE EITHER!

	JSRP	WAIT_MUT		;WATCH FOR STICKS!
	JRUC	DO_ANOTHER_DPAGE

 .endif

WAIT_MUT
	CALLA	FORM_SWS	;1ST STATE DOESN'T COUNT
WB1
	SLEEPK	1

	CALLA	FORM_SWS
	MOVE	A0,A2		
	ANDI	2002H,A2
	CMPI	2002H,A2
	JRNZ	WB2			;NOT "CLEAR"



	JRUC	WB1

getcoin
	movi	coin_snd,a0
	;one time in 512, do a different sound
	move	@PCNT,a14
	sll	32-9,a14
	srl	32-9,a14
	jrnz	wugxcsnd
	movi	39h,a0
wugxcsnd	calla	triple_sound
	rets


WB2	NOT	A1			;LAST = 0 AND NOW = 1 MEANS EDGE!
	AND	A1,A0			;1'S WHERE WE HAVE POSITIVE EDGE.
	ANDI	BUTTONS,A0		;IS IT A BUTTON?
	JRZ	WB1


	movi	beep2_snd,a0
	calla	triple_sound
	RETP


DUMP_DONE
	RETP				;AND RETURN TO CALLER!

NOTHIN_TO_DUMP
	CALLA	CLR_SCRN		;PRINT SOMETHING PLEASE
	MOVI	MESS_NODUMP,A8
	JSRP	L_MESS
	RETP


 .if 0
DO_DUMP
	MMTM	A12,A8,A9,A10,A11

	MOVI	DUMP_SIZE,A7
	MPYU	A9,A7			;THIS IS OFFSET INTO CMOS FOR THIS ENTRY!

	ADDI	DUMP_DATA,A7		;NOW A1 POINTS WHERE WE'RE PUTTING THE DATA!
	MOVE	A10,A3			;Y IN A3
	MOVK	30,A2			;STORE X IN A2
	MOVK	10,A5			;NUMBER OF WORDS TO DUMP
NEXT_ELE
	CALLA	RC_LONGI		;GET A WORD
	MOVE	A0,A4			;HEX IN A4

	MOVE	A7,*A13(PDATA),L
	MOVE	A2,*A13(PDATA+LONG_SIZE),L
	MOVE	A3,*A13(PDATA+(2*LONG_SIZE)),L
	MOVE	A5,*A13(PDATA+(3*LONG_SIZE)),L

	JSRP	WRITE_HEX		;WRITE IT OUT.....A0 = DATA
	MOVE	*A13(PDATA),A7,L
	MOVE	*A13(PDATA+LONG_SIZE),A2,L
	MOVE	*A13(PDATA+(2*LONG_SIZE)),A3,L
	MOVE	*A13(PDATA+(3*LONG_SIZE)),A5,L

	ADDI	48H,A2

	CMPI	6,A5			;WHEN WE'RE DOWN TO 4 SKIP TO NEXT LINE
	JRNZ	NO_SKIP_NOW

	ADDK	12,A3			;PUSH TO 2ND LINE
	MOVI	33,A2			;RE-MARGIN OVER. (30)

NO_SKIP_NOW
	DSJ	A5,NEXT_ELE

	MMFM	A12,A8,A9,A10,A11
	RETP

 .endif

WRITE_HEX
	MOVI	MESS_DUMP,A8
	CALLR	LM_SETUP		;SETUP FOR A DUMP!
	MOVE	A3,A9			;MOVE Y DOWN
	SLL	16,A9			;SHIFT Y INTO PLACE
	ADD	A2,A9			;ADD IN X

	MOVE	A4,A8
	CLR	A3			;NO COMMAS!
	CALLR	HTOHXASC		;CONVERT PLEASE!
	JSRP	LM_FINIS
	RETP


HTOHXASC
	MMTM	SP,A1,A2,A9
	CLR	A1
	CLR	A2			;COMMA COUNT
	MOVE	A1,-*SP			;HERE'S THE NULL TERMINATOR
	MOVK	16,A1			;DIVISOR FOR HEX
	MOVE	A8,A9
HEXTASC2
	CLR	A8
	DIVU	A1,A8
	ADDI	'0',A9			;MAKE THE REMAINDER ASCII
	CMPI	'9',A9			;IS IT IN A-F RANGE?
	JRLS	HHH1
	ADDI	7,A9			;MAKE ALPHA!
HHH1
	MOVE	A9,-*SP			;SAVE HERE
	MOVE	A8,A9
	JRZ	HEXTASC3		;BR = DONE!
	INC	A2
	CMPI	3,A2			;COMMA CHECK	
	JRLO	HEXTASC2		;BR = NO COMMA
	MOVE	A3,A3			;COMMAS?
	JRZ	HEXTASC2		;NOPE....IGNORE!

	MOVI	',',A2
	MOVE	A2,-*SP			;STUFF A COMMA
	CLR	A2
	JRUC	HEXTASC2
HEXTASC3
	MOVI	STRNGRAM,A1		;STORE HERE FOR BLOW OUT	
	MOVE	A1,A8

HEXTASC4
	MOVE	*SP+,A9
	MOVB	A9,*A1
	ADDK	8,A1
	MOVE	A9,A9
	JRNZ	HEXTASC4
	MMFM	SP,A1,A2,A9
	RETS


STRCAT
	MMTM	SP,A7,A0,A8
STRC2
	MOVB	*A7,A0		;WALK DOWN A7 TO ITS ZERO.
	JRZ	STRC1		;WE'RE THERE!

	ADDK	BYTE_SIZE,A7	;KICK TO NEXT BYTE
	JRUC	STRC2
STRC1
	MOVB	*A8,A0		;GET A BYTE FROM 2ND STRING
	MOVB	A0,*A7		;ADD THIS TO 1ST STRING
	ADDK	BYTE_SIZE,A7
	ADDK	BYTE_SIZE,A8
	MOVE	A0,A0		;DID WE JUST MOVE TERMINATOR?
	JRNZ	STRC1		;NOPE...MOVE ANOTHER

	MMFM	SP,A7,A0,A8
	RETS

MESS_DUMP
	MESS_MAC RD7FONT,SPACING07,23,227,ROBO_WHITE,STRLNRM,0

MESS_NODUMP
	MESS_MAC RD15FONT,SPACING20,200,128,ROBO_ORANGE,STRCNRM,0
	.byte	"NOTHING HERE....PRESS ADVANCE!",0,0
	.even

MESS_SLASH
	.byte	"/",0
	.even

MESS_2SPACE	.byte	"  "
MESS_NULL	.byte	0
		.even

SETUP_1_OF_3
	 MESS_MAC  RD15FONT,SPACING20,CP_CX,CP_13,ROBO_LASER,STRCNRM,0
SETUP_2_OF_3
	 MESS_MAC  RD15FONT,SPACING20,CP_CX,CP_23,ROBO_LASER,STRCNRM,0
SETUP_3_OF_3
	 MESS_MAC  RD15FONT,SPACING20,CP_CX,CP_33,ROBO_LASER,STRCNRM,0

SETUP_1_OF_2
	 MESS_MAC  RD15FONT,SPACING20,CP_CX,CP_12,ROBO_LASER,STRCNRM,0

SETUP_2_OF_2
	 MESS_MAC  RD15FONT,SPACING20,CP_CX,CP_22,ROBO_LASER,STRCNRM,0

SETUP_1_OF_1
	 MESS_MAC  RD15FONT,SPACING20,CP_CX,CP_11,ROBO_LASER,STRCNRM,0

dollar_mes
	JAM_STR	ogmd10_ascii,5,0,200,53,SGMD8YEL,print_string_C2
	.byte	"THIS GAME ACCEPTS DOLLAR BILLS",0,0
	.even





	.end

